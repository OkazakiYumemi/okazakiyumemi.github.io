<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[转区软件 Locale Emulator 简介]]></title>
    <url>%2Fblog%2FLocale-Emulator%2F</url>
    <content type="text"><![CDATA[由于 App Locale 本身就有一堆 bug，也有可能是我不会搞，反正是从来没有能用过。 于是在 GitHub 上找了找，总算找到个好使的转区软件。 xupefei/Locale-Emulator，以 GPL v3.0 开源。 star 好多（ 然后操作很方便，这里就不加叙述了。 有兴趣的话可以自己编译一个？ 有一说一 latest commit 记录比 latest release 晚了一年多，不知道修了什么 bug。 发现真没啥东西能写的，于是本篇博客大概就是这样一个小作品了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[又一个弥生月，近况报告]]></title>
    <url>%2Fblog%2F20210226%2F</url>
    <content type="text"><![CDATA[已逝世。 本人未来几个月（？）的规划；本博客未来的规划；碎碎念。 20210228这个博客该修了。 应当大改 categories 和 tags，将 oi 题解等创建的大量 tags 处理掉，并将 oi 相关内容移至统一 category 内。 至于怎么处理掉 tags，由于 hexo next 自身的局限性，即 tags 无法嵌套，categories 无法并列，暂时只能想到删去 tags 并在每篇文章末尾或开头加入摘要，通过搜索访问之前相同 tag 中的文章。 oi 还搞不搞的问题现在也还没有定论。总之还是暂且勉强跟一下集训罢，只要不停课就行。 放不下 oi 的主要原因，可能是我对自己文化课的不自信。所以手上如果拿着个 ag，不知道能多拿到多少优势呢。而且你省毕竟高考大省，，，我这种文科拉垮壬有什么资本和别人拼文化课呢？ 当然也可以提前躺平。但是你愿意接受吗？反内卷斗士最终还是得成为自己最讨厌的样子。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>计划与总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021WC 听课记录]]></title>
    <url>%2Fblog%2F2021WC-notes%2F</url>
    <content type="text"><![CDATA[总结：自闭了。 0201上午在讲简单东西，跳了。 下午的一些题目： GYM102832J(from 2020 China Collegiate Programming Contest Changchun Onsite) 注意到方案合法仅当 $[x-r,x+r]$ 这些区间互相之间只有严格包含和相离关系，且没有完全相同的线段。考虑从左到右维护扫描线，记录前 $10$ 个端点哪一些是合法的。插入一条 $[x, y]$ 的线段会使得 $[x + 1, y − 1]$ 非法，打标记即可。时间复杂度 $O(n\times 2^{10})$。 GYM102822I(from 2020 China Collegiate Programming Contest Mianyang Onsite) 这题见过。 $n$ 棵树高度为 $\langle h\rangle$，可以任意买可使一棵树长高 $i$、单价 $i^2+C$ （$C$ 为常数）的肥料，求每棵树都长到不低于 $k$ 的最小花费。$n,q\le 10^5,c\le 10^4,h_i,k\le 10^9$ 且 $h,k$ 随机生成。 考虑若我们要将某棵树高度提升 $h$。假设我们操作了 $k$ 次，显然会有 $h \bmod k$ 次 $\lfloor\frac{h}{k}\rfloor$ 和 $k-h\bmod k$ 次 $\lfloor\frac{h}{k}\rfloor$。 所以直接令 $f(h)$ 为升高 $h$ 最优（且最大）的操作次数，不难发现 $h&gt;O(C)$ 时有约为 $O(\sqrt{C})$ 的周期，所以小暴力，大按剩余类做扫描线即可。而又因为数据随机，问到小的概率很小，所以复杂度没问题。 GYM102798F(from 2020 China Collegiate Programming Contest Weihai Onsite) GYM102769L(from 2020 China Collegiate Programming Contest Qinhuangdao Onsite) 虽然我知道这是什么但是不会描述所以直接抄课件了（ 平面上有 $n$ 组石柱，第 $i$ 组包含了坐标为 $(i,l_i),(i,r_i)$ 的石柱，除此之外没有石柱。每一年，如果一个石柱旁边四格中存在一个空格子，则在当年结束时，其会崩塌，形成一个空格子。问每一组石柱哪一年会全部崩塌。$\sum n\le 1.2\times 10^7,1\le l_i,r_i\le 5\times 10^8$。 考虑一个石柱 $(x,y)$ 与一个空格子 $(x’,y’)$，则该石柱显然会在 $|x-x’|+|y-y’|$ 年内崩塌。于是设第 $i$ 组的答案为 $ans_i$，则显然有 $ans_i−1\le ans_i+1\le ans_i+1$。因而 $i−ans_i,i+ans_i$, 也就是极大合法的左右端点均单调增。 不妨设 $(i,l_i−1),(i,r_i+1)$ 为上下关键点，考虑用单调栈分别维护左右侧的上下关键点的四个单调队列。队列维护的是 $x,y$ 两轴的坐标的和差，用于计算当前石柱没有崩塌的区间的上下边界。 我们同时维护队列左右两侧 $4$ 个方向的单调队列，同时记录当前极大合法区间左右端点 $L,R$。从 $i−1$ 转移到 $i$ 的时候，右端点最多向右移动 $2$，因而这些零散的部分可以通过暴力询问求得。 每一次中点的移动，合法区间左右端点的移动，相当于从若干个队列中删去起始元素，加入末尾元素。检验合法性等价于求最小值，因而直接维护 $4$ 个单调队列即可。时间复杂度 O(n)。 NC9925H(from 2020 ICPC,Shanghai Regional Contest) 这题见过。 一个圆形餐桌，有 $n$ 个位置，现有 $k$ 个人分别在 $a_i$，$k$ 碗饭分别在 $b_i$。每个时刻你可以顺时针或逆时针将桌子转一个位置，如果一碗饭转到了一个人面前，他可以不花时间取走饭，每个人恰好会取走一碗饭。大家都想最小化最后拿到饭的人的时间，求出这个时间。$n\le 10^9,k\le 2000$。 有一个结论是：我们把每个人和对应的饭在圆盘上连线，那么这些连线是不会相交的。这样我们可以直接枚举第一个人对应的饭编号，然后转一圈计算答案。复杂度 $O(n^2\log n)$。 证明略。 NC9925K(from 2020 ICPC,Shanghai Regional Contest) 这题见过。 $n$ 个点 $m$ 条边无向简单图，每个点有颜色0/1，保证点 $1$ 初始颜色为0。每当你离开一个点，该点颜色会改变。你希望经过节点颜色依次为010101...，判断是否存在这样的路径，$n,m\le 2\times 10^5$。 考虑第一个在路径中出现两次的点 $x$，和第二次 $x$ 出现前上一个点 $y$，显然初始 $x,y$ 同色，而路径 $1\to x\to y$ 每条边均为异色边。 把异色边提出来，求出点双，求出圆方树 $T$，则存在 $1\to x\to y$ 的不经过重复节点的路径仅当「$y$ 在 $x$ 子树内」或「$x$ 父节点为方点，且 $y$ 在 $x$ 父亲的子树内」。 总时间复杂度 $O(n)$。 NC9328H(from 2020 XiaoMi Invitational Programming contest) 见过不会。 给定一个 $n$ 层的满二叉树，所有叶子节点有固定权值 $v_i$。自行确定其他节点的权值最小化 $\sum(v_i-v_{fa(i)})^2$ 并输出最小值 $\bmod 998244353$。$Q$ 次单点修改，$n\le 18,Q\le 2\times 10^5$。 设 $f_x(t)$ 为 $v_x=t$、其子树内节点权值任意，其子树贡献最小值。不难发现 $f_x(t)$ 为一个二次函数。 因此直接对于树上每个节点维护多项式对应系数即可。注意到二次项系数仅与树结构相关，因此可省去修改时求逆部分。时间复杂度 $O((n+m)(\log n + \log mod))$。 援交完全在睡大觉，也许以后（指退役以后）会补吧。 0202上午讲的smjb。下午的一些没做过的题目：咕咕咕。援交比我更早咕掉了！ 02030204显而易见，咕了。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>GYM</tag>
        <tag>NowCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1442F」Differentiating Games]]></title>
    <url>%2Fblog%2FCF1442F%2F</url>
    <content type="text"><![CDATA[题意简述CF 1442F 给一个 $n$ 个点 $m$ 条边的 DAG，你可以进行至多 $4242$ 次修改操作，每次删掉一条边或加上一条边（修改之后允许有环、重边、自环）。 在这个图上定义函数 $f(S)$ ，表示如果在多重集合 $S$ 的每一个元素上放一个球，两人轮流操作，每次把一个球向某一条出边移动，不能操作者输，那么是先手是胜还是输，或者永远玩不完（平）。（双方的策略均为先尽量赢，再尽量平。） 接下来 $T$ 组数据，每组数据中交互器确定一个特殊点 $x$ ，你要通过询问来找到这个特殊点。 一次询问可以问大小不超过 $20$ 的多重集合 $S$ ，返回 $f(S+{x})$ 的值。最多问 $20$ 次，集合大小的总和不能超过 $20$ 。 $n\le 1000,m\le 10^5,T\le 2000$ 主要思路假设图无环，则没有平局情况，故两点的SG值必须两两不同，图这必须是一个完全 DAG。 那么，一个显然的想法是给除了那个完全 DAG 里的点都加上一个自环。称 DAG 里的点是 A 类点，有自环的点是 B 类点。 不难发现，如果至少 2 个球在 B 类点上，一定是Draw；有 1 个球在 B 类点上，不可能Lose，因为其可以什么都不做。于是现在考虑仅有 1 个球在 B 类点上的情况，考虑先手什么时候会将球移出去。 显然，先手不会将球移到另一个 B 类点上，因为此时不可能Win。故先手仅可能将球移到一个 A 类点上。 不妨假设我们每次仅询问大小为 1 的集合，即，将 A 类点都询问一遍。A 类点的SG值都不相同，所以如果出现了Lose，仅可能是询问点和答案相同。 否则，只会有一堆Win和Draw。类似地，Win的情况为答案有连向询问点的出边。所以只需保证每个 B 类点对 A 类边连边的集合不同即可。 于是钦定 A 类点不超过 $20$ 个，直接冲即可。 最后大概会修改 $3900$ 条边。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;using namespace std;#define FOR(i, a, b) for (int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;typedef vector&lt;int&gt; VI;#define pb emplace_back#define N 1024#define M 25#define BB 20vector&lt;tuple&lt;char, int, int&gt;&gt; ans;int n, m, esac, B;VI E[N];int ind[N], que[N];int id[N], rd[M];int tb[1048599], val[N];inline void AddEdge(int u, int v)&#123; ans.pb('+', u, v); &#125;inline void DelEdge(int u, int v)&#123; ans.pb('-', u, v); &#125;inline int Query(int u)&#123; printf("? 1 %d\n", u), fflush(stdout); static char s[10]; scanf("%s", s); return *s == 'L' ? -1 : (*s == 'W' ? 1 : 0);&#125;inline void Report(int u)&#123; printf("! %d\n", u), fflush(stdout); static char s[10]; scanf("%s", s); assert(*s == 'C');&#125;inline void Init1()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;esac); FOR(i, 1, m)&#123; int u, v; scanf("%d%d", &amp;u, &amp;v); E[u].pb(v), ++ind[v]; &#125; // B = min(n, BB); if(n &lt;= BB) B = n; else&#123; B = 1; FOR(i, 1, BB - 1) if(i+(i*(i-1))/2+(i*(i-1)*(i-2)/6)&lt;=n) ++B; &#125;&#125;inline void Init2()&#123; int *ql(que), *qr(que); FOR(i, 1, n) if(!ind[i]) *qr++ = i; while(ql != qr)&#123; int u = *ql++; for(int v: E[u])&#123; if(!(--ind[v])) *qr++ = v; &#125; &#125;&#125;inline void Init3()&#123; static int e[M][M]; memset(id, -1, sizeof(int) * N); FOR(i, 1, B)&#123; id[que[n - i]] = i - 1; rd[i - 1] = que[n - i]; &#125; // FOR(i, 0, n - 1) printf("%d%c", que[i], " \n"[i == ed_i]); // FOR(i, 0, B - 1) printf("%d%c", rd[i], " \n"[i == ed_i]); FOR(i, 0, B - 1)&#123; int u = rd[i]; for(int v: E[u]) if(id[v] != -1)&#123; assert(id[v] &lt; i); e[i][id[v]] = 1; &#125; FOR(j, 0, i - 1) if(!e[i][j])&#123; AddEdge(rd[i], rd[j]); &#125; &#125; FOR(i, 1, n) if(id[i] == -1) AddEdge(i, i);&#125;inline void Init4()&#123; VI s[3]; FOR(i, 1, (1 &lt;&lt; B) - 1)&#123; int t = __builtin_popcount(i); if(t &lt;= 3) s[t - 1].pb(i); &#125; FOR(i, 1, n) if(id[i] == -1)&#123; for(int v: E[i]) if(id[v] != -1)&#123; val[i] |= 1 &lt;&lt; id[v]; &#125; if(!tb[val[i]]) tb[val[i]] = i; &#125; // FOR(i, 1, n) printf("%d%c", val[i], " \n"[i == ed_i]); // FOR(i, 0, (1 &lt;&lt; B) - 1) printf("%d%c", tb[i], " \n"[i == ed_i]); auto UpdNode = [s](int p) -&gt; void&#123; FOR(o, 0, 2) for(int j: s[o]) if(!tb[val[p] ^ j])&#123; ROF(i, B - 1, 0) if((j &gt;&gt; i) &amp; 1)&#123; (((val[p] &gt;&gt; i) &amp; 1) ? DelEdge : AddEdge)(p, rd[i]); &#125; tb[val[p] ^= j] = p; return; &#125; &#125;; FOR(i, 1, n) if(id[i] == -1 &amp;&amp; tb[val[i]] != i)&#123; UpdNode(i); &#125; printf("%d\n", (int)ans.size()); for(auto [x, y, z]: ans)&#123; printf("%c %d %d\n", x, y, z); &#125; fflush(stdout);&#125;inline void Work()&#123; int v = 0, t; FOR(i, 0, B - 1)&#123; t = Query(rd[i]); if(t == -1) return Report(rd[i]); if(t == 1) v |= 1 &lt;&lt; i; &#125; assert(tb[v] != 0); Report(tb[v]);&#125;int main() &#123; Init1(); Init2(); Init3(); Init4(); while(esac--) Work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>Codeforces</tag>
        <tag>交互题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「GYM102392H」Tree Permutations]]></title>
    <url>%2Fblog%2FGYM102392H%2F</url>
    <content type="text"><![CDATA[为啥集训队作业只有 NEERC，没有 SEERC 题意简述GYM102392H 神树爷爷建了一棵树，大小为 $n$，根为 $1$，每个节点的父亲 $p_i&lt;i$，连向父亲的边的边权 $w_i$。 神树爷爷把所有 $p_i, w_i$ 混在一起之后乱序扔给了你，记这个序列为 $a$。 显然一个 $a$ 可能对应多棵可能的树。 神树爷爷认为一棵树是k-good的，仅当 $1$ 到 $n$ 的路径上有 $k$ 条边； 一棵树是k-perfect的，仅当这棵树是k-good的树中，$1$ 到 $n$ 路径上的边权和是最大的。 现在神树爷爷希望你对所有 $1\le k\le n-1$，求出k-perfect树 $1$ 到 $n$ 路径上的边权和。 如果没有k-perfect树，输出-1。 $n\le 2\le 10^5, 1\le a_i\le n - 1$。 主要思路先排序，下文中出现的序列，若未特殊说明，也默认已按不降排序。 【引理 1】如果对于某些 $i$ 有 $a_i&gt;i$，那么根本没有合法的树。 【证明】假设 $a_i&gt;i$。显然节点 $j\in[2, i+1]$ 的父亲都不大于 $i$，而此时最多仅有 $i-1$ 个不大于 $i$ 的数，故矛盾。 【引理 2】如果对于某些 $i$ 有 $a_i=i$，那么节点 $i$ 在 $1$ 到 $n$ 的路径上。 【证明】注意到节点的编号形成堆结构，即，$1$ 到 $n$ 的路径为每次选择最大的儿子向下走。假设 $a_i=i$。类似【引理 1】的证明，$i-1$ 个不大于 $i$ 的数分别应是点 $j\in[2, i]$ 的父亲，而对于节点 $j&gt;i$，由于没有更多小于 $i$ 的数，其父亲均不小于 $i$。 我们令 $T$ 为那些 $a_i=i$ 的位置集合，并令 $S$ 为所有未在 $T$ 中出现的 $a_i$ 第一次出现位置集合。称k-perfect树 $1$ 到 $n$ 路径为路径，其上的边权和为k-perfect树的权值。 【引理 3】对于任意 $|T|\le k\le |T|+|S|$，有k-good的树。并且，k-perfect树的权值可以用以下方法计算： 标记 $T$ 中所有元素，以及 $S$ 中 $k-|T|$ 个最小元素。k-perfect树的权值即为未标记的位置中最大的 $k$ 个值的和。 【证明】显然地，$|T|$ 是下界，$|T|+|S|$ 是上界。我们仅需证明他们都可被成功构造。 记 $k-|T|$ 个 $S$ 中最小的元素为 $s_i(i\in[1,k-|T|])$。那么路径上应该包含节点 $a_i(i\in s\cup T)$ 与 $n$。标记 $s, T$ 中所有位置，同时也标记所有在路径上的节点（这些节点除了 $1$ 都已有了父亲）。 未标记的 $2n-2-k$ 个位置记为 $\langle x\rangle$，未标记的 $n-k-1$ 个节点记为 $\langle v\rangle$。钦定 $a_{x_i}$ 为 $v_i$ 的父亲 $(i\in[1,n-k-1])$。剩下的 $n-1$ 个位置对应的 $a_i$ 均为边权，将最大的 $k$ 个分给路径，其他的任意分给其他边。 这样我们得到了上述的答案，下面我们证明通过此方法构造出的确实是一棵树。 由于我们希望分配 $a_{x_i}$ 为 $v_i$ 的父亲，故只需证明 $a_{x_i}&lt;v_i$。 不妨假设对于某些 $i$ 有 $a_{x_i}\ge v_i$。 记路径上的点为 $\langle p\rangle$，由于 $p_{k+1}=n$，我们可以找到 $j$ 使 $p_j\le a_{x_i}\le p_{j+1}$。即，有 $j$ 个已标记的节点不大于 $a_{x_i}$。并且由于 $a_{x_i}\ge v_i$，即有 $i$ 个未标记的节点不大于 $a_{x_i}$。因此，有 $a_{x_i}\ge i+j$。 现在来考虑 $x_i$，有 $i-1$ 个未标记的位置不大于 $x_i$。根据 $S,T$ 的定义，$p_j$ 对应的已标记位置应在 $x_i$ 之前。即，有 $j$ 个已标记位置在 $x_i$ 之前。 于是 $i-1+j$ 个位置在 $x_i$ 之前，即 $x_i=i+j$。即，$a_{x_i}\ge x_i$。 【引理 1】中已经证明 $a_{x_i}\le x_i$，且根据【引理 2】，若 $a_{x_i}=x_i$，则 $x_i$ 必定在路径上。Contradiction! 实现可以类似 two pointers，复杂度 $O(n)$。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;#define FOR(i, a, b) for (int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)inline int read() &#123; int x = 0; char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; return x;&#125;#define N 100010int n;int c[N], b[N], a[N];int L, R;long long ans;int main() &#123; n = read(); FOR(i, 1, (n - 1) * 2) R += !(c[read()]++); FOR(i, 1, n - 1)&#123; b[i] = b[i - 1] + c[i] - 1; if(b[i] &lt; 0)&#123; FOR(i, 1, n - 1) printf("-1 "); return 0; &#125; a[i] = c[i]; if(!b[i - 1]) --a[i], ++L; &#125; int l = 1, r = n - 1, d = 0; FOR(i, 1, n - 1)&#123; if(i &lt; L || i &gt; R)&#123; printf("-1 "); continue; &#125; if(i &gt; L)&#123; while(!b[l - 1] || !c[l]) ++l; if(a[l]) --a[l]; else ans -= l, --d; ++l; &#125; while(d != i)&#123; while(!a[r]) --r; --a[r], ++d, ans += r; &#125; printf("%lld ", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>猜结论</tag>
        <tag>树论</tag>
        <tag>GYM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「GYM102341」Dedenne]]></title>
    <url>%2Fblog%2FGYM102341D%2F</url>
    <content type="text"><![CDATA[题意简述GYM102341D 一堆01串是 dictionary 仅当其中没有一个串为另一个的前缀，且每个串都不含子串00。 一个 dictionary $S$ 的 cost，是所有01串 $s$（不仅包含 $S$ 中的串）的 cost 的和。 对于一个01串 $s$，若其为 $k$ 个 $S$ 中串的前缀，则其 cost 为 $\sum\limits_{j=1}^k\lfloor1+\log_2j\rfloor$。 $t$ 组询问大小为 $n$ 的 dictionary 的 cost 的最小值，$t\le 5\times 10^4, 2\le n\le 10^{15}$。 主要思路首先 $f(k)=\sum\limits_{j=1}^k\lfloor1+\log_2j\rfloor$ 可以在 $O(\log n)$ 预处理后 $O(1)$ 计算。 设 $D(n)$ 为构造大小为 $n$ 的 dictionary 的最小代价，则 $D(1)=1$。 我们把串扔到 trie 上，那么显然地，$D(n) = f(n)+\min\limits_{i\le k&lt;n}\{f(k)+D(k)+D(n-k)\}$。这里 $k$ 是枚举左子树的叶子个数，$f(k)$ 是因为左边的串（因为不能出现00）要以01开头。（$k=1$ 时则不需要加上 $f(1)$。） 可以证明 $D$ 是下凸函数，同时 $f$ 也是下凸函数，因此 $f(k)+D(k)+D(n-k)$ 也是下凸的。因此可以三分 $k$。于是我们可以 $O(\log^2n)$ 地求出任意一个 $D(n)$。 显然这不够。我们不妨枚举增量 $\delta$，每次求出最大 $n’$ 使 $D(n’)=D(n)+\delta\cdot(n’-n)$，其中 $n$ 是目前确定的最远 $D$ 值。$n’$ 可以二分，且当 $n$ 足够大时，计算 $D(n’)$ 不会用到未确定的 $D$ 值。可以证明 $\delta$ 是 $O(\log^2n)$ 级别。（经过尝试，$n\le 10^{15}$ 时，增量 $\delta$ 仅有 $1840$。） 于是可以 $O(\log^5 n)$ 预处理上述所有东西，每次询问再 $O(\log n)$ 二分一下即可。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long i64;typedef vector&lt;i64&gt; VI;#define pb emplace_back#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;constexpr i64 inf = 1'00000'00000'00000;constexpr i64 B = 1'000; // limit of brute forcei64 fp[55];i64 f(i64 k) &#123; int t = 64 - __builtin_clzll(k); return fp[t] + (k + 1 - (1ll &lt;&lt; (t - 1))) * t;&#125;// #define fk1(k) ((k) == 1 ? 0 : f(k))VI a, D;i64 Dsm[1024];i64 Dbrute(i64 n) &#123; // assert(n &lt;= B); if (Dsm[n] != 0) return Dsm[n]; i64 res = 1 + Dsm[n - 1]; // assert(Dsm[n - 1] != 0); for (i64 i = 2; i &lt;= n / 2; ++i) &#123; i64 tmp = f(i) + Dsm[i] + Dsm[n - i]; chkmin(res, tmp); &#125; return Dsm[n] = res + f(n);&#125;i64 Dget(i64 n) &#123; if (n &lt;= B) return Dbrute(n); int k = upper_bound(a.begin(), a.end(), n) - a.begin(); return D[k - 1] + k * (n - a[k - 1]);&#125;i64 Dcalc(i64 n) &#123; if (n &lt;= B) return Dbrute(n); i64 l = n / 3, r = n / 2; while (l &lt; r) &#123; i64 m = (l + r) / 2; i64 Dl = f(m) + Dget(m) + Dget(n - m); i64 Dr = f(m + 1) + Dget(m + 1) + Dget(n - m - 1); if (Dl &lt; Dr) r = m; else l = m + 1; &#125; return f(n) + f(l) + Dget(l) + Dget(n - l);&#125;int main() &#123; for (int i = 1; i &lt; 54; ++i) fp[i + 1] = fp[i] + (1ll &lt;&lt; (i - 1)) * i; a.pb(1), D.pb(1); Dsm[1] = 1; int delta = 1;#define Dexp(i) (D.back() + delta * ((i) - a.back())) // expect while (a.back() &lt; inf) &#123; i64 n = a.back(); while (n &lt; B &amp;&amp; Dcalc(n + 1) == Dexp(n + 1)) ++n; if (n &lt; B) &#123; D.pb(Dcalc(n)), a.pb(n), ++delta; continue; &#125; // assert(Dcalc(n / 2 * 3) != Dexp(n / 2 * 3)); i64 l = n, r = n / 2 * 3 - 1; while (l &lt; r) &#123; i64 m = (l + r + 1) / 2; if (Dcalc(m) == Dexp(m)) l = m; else r = m - 1; &#125; D.pb(Dcalc(l)), a.pb(l), ++delta; &#125; int Q; scanf("%d", &amp;Q); while (Q--) &#123; i64 n; scanf("%lld", &amp;n); printf("%lld\n", Dget(n)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>GYM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「GYM102798F」Skeleton Dynamization]]></title>
    <url>%2Fblog%2FGYM102798F%2F</url>
    <content type="text"><![CDATA[题意简述GYM102798F 想象一只 skeleton，抽象其骨头为无向边，关节为顶点，可以得到一个无向连通图。假设定点数为 $J$，该图为 $G$。 这只 skeleton 开始动了起来，我们记录了其在连续 $F$ 帧中的动作，并且建立了一张 spatial-temporal graph。 spatial-temporal graph 是一个有 $F\times J$ 个节点的图。每个节点可以用 $(f, j)$ 唯一表示，前者为其出现的帧，后者为其在 $G$ 中对应的标号。 两点 $(f_1, j_1), (f_2, j_2)$ 间有边，仅当满足以下条件之一： $j_1 = j_2, f_1 + 1 = f_2$； $f_1 = f_2$，且在 $G$ 中有边 $(j_1, j_2)$。 现在 $G$ 丢失了，只剩下了标号被打乱的 spatial-temporal graph。请还原可能的 $F, J$ 并构造方案。如有多个方案，请最大化 $F$。 $n\le 10^5, m\le 2\times 10^5$。 主要思路上面讲了那么多废话，其实题意就是将给定的图看作分层图，每层内部边相同，相邻层只有对应点连边，最大化层数。 设度数最小的点为 $s$，显然其（在某个最优方案）一定是第一层的点。显然，$s$ 的度数不超过 $O(\sqrt{m})$。 枚举 $s$ 在第二层对应的点 $t$。从 $s,t$ 开始 bfs，则以 $s$ 为起点 bfs 到的点即为第一层的点。 已知第一层的点，就可以确定第二层的点，然后确定所有层的点。 如果过程中出现矛盾，则退出。 最后，检查每一层内部的边是否都相同。 时间复杂度 $O(m\sqrt{m})$。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;#define FOR(i, a, b) for (int i = (a), ed_##i = (b); i &lt; ed_##i; ++i)#define ROF(i, a, b) for (int i = (a), ed_##i = (b); i &gt; ed_##i; --i)// Note the unusual definitiontypedef long long i64;typedef vector&lt;int&gt; VI;#define pb emplace_back#define X first#define Y second#define SZ(x) ((int)(x).size())#define Templ(T) template &lt;typename T&gt;inline int read() &#123; int x = 0; char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; return x;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define N 100010int n, m;int F, J;// Frames, Jointsint ans[N];int S;VI E[N];inline void work(const int &amp;T)&#123; static int B[N], Q[N], w[N], res[N]; static VI e[N]; memset(B, -1, n &lt;&lt; 2); memset(w, -1, n &lt;&lt; 2); memset(res, -1, n &lt;&lt; 2); int *ql(Q), *qr(Q); B[S] = 0, B[T] = 1; *qr++ = S, *qr++ = T; while(ql != qr)&#123; int u = *ql++; for(int v: E[u]) if(B[v] == -1)&#123; B[v] = B[u]; *qr++ = v; &#125; &#125; int j(0), f, t(0); // (now) joints, frames FOR(i, 0, n) if(B[i] == 0)&#123; res[j] = i; w[i] = j++; t += SZ(E[i]); &#125;; if(n % j != 0) return; f = n / j; if(f &lt; F) return; t -= j; if(t &amp; 1) return; t &gt;&gt;= 1; if(f * t + (f - 1) * j != m) return; FOR(o, 1, f)&#123; int c = 0, *a = res + (o - 1) * j; FOR(i, 0, j)&#123; int u = a[i]; for(int v: E[u]) if(w[v] == -1)&#123; if(a[i + j] != -1) return; w[v] = w[u] + j; a[i + j] = v; ++c; &#125; &#125; if(c != j) return; &#125; FOR(i, 0, n) e[i].resize(0); FOR(o, 0, f)&#123; int *a = res + o * j; FOR(i, 0, j)&#123; int u = a[i]; for(int v: E[u]) if(w[v] / j == w[u] / j) e[w[v]].pb(w[u] % j); &#125; &#125; FOR(i, j, n) if(e[i] != e[i - j]) return; J = j; F = f; memcpy(ans, res, n &lt;&lt; 2);&#125;int main() &#123; n = read(), m = read(); FOR(i, 0, m)&#123; int u(read() - 1), v(read() - 1); E[u].pb(v), E[v].pb(u); &#125; &#123; int mn = m; FOR(i, 0, n) if(chkmin(mn, SZ(E[i]))) S = i; &#125; F = 1, J = n; FOR(i, 0, n) ans[i] = i; for(int i: E[S]) work(i); printf("%d %d\n", F, J); FOR(i, 0, n) printf("%d%c", ans[i] + 1, " \n"[i % J == J - 1]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>GYM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeChef LUCKYDAY」Lucky Days]]></title>
    <url>%2Fblog%2FCC-LUCKYDAY%2F</url>
    <content type="text"><![CDATA[题意简述CodeChef LUCKYDAY 有序列 $S$，其中 $S_1=A,S_2=B;S_i=X\cdot S_{i-1}+Y\cdot S_{i-2}+Z(i&gt;2)\% P$。$Q$ 个询问求 $\sum\limits_{i=L}^{R}[S_i=C]$。$A,B,X,Y,C,P,Q$ 均给定，$P$ 为不超过 $10007$ 的质数，$0\le A,B,X,Y,C&lt;P$，$Q\le 2\times 10^4$，$1\le L\le R\le 10^{18}$。 主要思路先把 $X=0$ 或 $Y=0$ 等情况判了。此时循环节长度 $O(P)$，暴力找出即可。注意到此时可能循环节从 $3$ 开始。 设 $F_i=\begin{bmatrix}S_i\\S_{i+1}\\1\end{bmatrix},M=\begin{bmatrix}0&amp;1&amp;0\\Y&amp;X&amp;Z\\0&amp;0&amp;1\end{bmatrix}$，则有 $F_i = M\times F_{i-1}$。 不同的 $F_i$ 仅有 $P^2$ 个，由HDU 5451的经验，循环节一定是 $P^2-1$ 的约数，并且 $X&gt;0,Y&gt;0$ 时因为转移矩阵可逆，故一定是纯循环。 那么就先来找最小循环节 $R$。枚举约数矩阵快速幂即可。 然后考虑如何找到循环节中所有 $S_i=C$。由于循环节内相同 $F_i$ 只会出现一次，我们试图枚举 $m$，找到所有 $t=\begin{bmatrix}C\\m\\1\end{bmatrix}$ 的位置。即，找到 $0\le k&lt;R$ 使 $M^k F_1=t$ 成立。 设一阈值 $L$，则 $M^{dL-e}F_1=t$。由于 $M$ 可逆，变成 $M^{dL}F_1=M^et$，且 $d$ 是 $O({R\over L})$ 级别，$e$ 是 $O(L)$ 级别。 不难想到可以 $O({R\over L})$ 预处理出所有左边的可能值，扔到 Hash Table 里，就支持 $O(1)$ 查询。那么每次查询时，枚举 $e$，即可做到 $O(L)$ 单次查询。喂这不就是 BSGS…… 由于有 $O(P)$ 次查询（枚举 $m$），所以时间复杂度是 $O(LP)+O({R\over L})$，由于 $R$ 是 $O(P^2)$ 级别，故 $L$ 取 $\sqrt{P}$ 时复杂度最优为 $O(P\sqrt{P})$。 之后，每个询问就 $O(\log P)$ 了。 总时间复杂度 $O(P\sqrt{P} + Q\log P)$。 参考代码代码真的很烦，我的 Hash Table 都是抄 Sunli Chen 的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224#include &lt;bits/stdc++.h&gt;using namespace std;#define FOR(i, a, b) for (int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;#define Templ(T) template &lt;typename T&gt;inline int read() &#123; int x = 0; char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; return x;&#125;inline i64 read64() &#123; i64 x = 0; char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; return x;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;int __MOD__;#define P __MOD__inline void inc(int &amp;x, const int &amp;y) &#123; x += y; if (x &gt;= P) x -= P;&#125;inline void dec(int &amp;x, const int &amp;y) &#123; x -= y; if(x &lt; 0) x += P;&#125;inline int ksm(int x, i64 y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = (i64)x * x % P) if (y &amp; 1) res = (i64)res * x % P; return res;&#125;/*[ S(i) ] [0 1 0] [S(i-1)][S(i+1)] = [Y X Z] * [ S(i) ][ 1 ] [0 0 1] [ 1 ]*/#define MR 160#define SL 150// Thanks Eric Sunli Chen for his AMAZING hash table!#define Hash_P 2333333#define Hash_N 888888struct Hash_T &#123; int head[Hash_P], nxt[Hash_N], a[Hash_N], val[Hash_N], tot; void Clear() &#123; memset(head, 0, sizeof(head)); tot = 0; &#125; Hash_T() &#123; Clear(); &#125; inline int &amp;operator[](const int &amp;x) &#123; int tx = x % Hash_P; for (int i = head[tx]; i; i = nxt[i]) if (val[i] == x) return a[i]; nxt[++tot] = head[tx]; head[tx] = tot; val[tot] = x; a[tot] = 0; return a[tot]; &#125; inline int Find(const int &amp;x) const &#123; int tx = x % Hash_P; for (int i = head[tx]; i; i = nxt[i]) if (val[i] == x) return a[i]; return -1; &#125;&#125;;Hash_T rem;struct Matrix&#123; int a[3][3]; inline Matrix()&#123; memset(a, 0, 36); &#125; inline bool Unit()&#123; FOR(i, 0, 2) FOR(j, 0, 2) if(a[i][j] != (i == j)) return false; return true; &#125; inline Matrix operator *(const Matrix &amp;y)const&#123; Matrix z; FOR(i, 0, 2) FOR(k, 0, 2) FOR(j, 0, 2) (z.a[i][j] += a[i][k] * y.a[k][j]) %= P; return z; &#125;&#125;IE;struct Vector&#123; int a[3]; inline Vector()&#123; memset(a, 0, 12); &#125; friend inline Vector operator *(const Matrix &amp;x, const Vector &amp;y)&#123; Vector z; z.a[0] = (x.a[0][0] * y.a[0] + x.a[0][1] * y.a[1] + x.a[0][2] * y.a[2]) % P; z.a[1] = (x.a[1][0] * y.a[0] + x.a[1][1] * y.a[1] + x.a[1][2] * y.a[2]) % P; z.a[2] = 1; return z; &#125;&#125;;inline Matrix ksm(Matrix x, int y)&#123; Matrix z = IE; for(; y; y &gt;&gt;= 1, x = x * x) if(y &amp; 1) z = z * x; return z;&#125;inline int Hash(const Vector &amp;x)&#123; return x.a[0] * P + x.a[1];&#125;Matrix M, MM;Vector S;int A, B, X, Y, Z, C, Q;int Per, MxP;// int SL;vector&lt;int&gt; W;inline void work0()&#123; i64 L, R, res; while(Q--)&#123; L = read64(), R = read64(); res = 0; if(L == 1) res += R &gt;= 1 &amp;&amp; A == C, ++L; if(L == 2) res += R &gt;= 2 &amp;&amp; B == C, ++L; if(Z == C &amp;&amp; L &lt;= R) res += R - L + 1; printf("%lld\n", res); &#125;&#125;inline void work1()&#123; int *F = (int*)malloc(sizeof(int) * 5 * P), Per = 0; F[1] = A, F[2] = B; FOR(i, 3, 4 * P)&#123; F[i] = ((i64)F[i - 1] * X + (i64)F[i - 2] * Y + Z) % P; &#125; FOR(i, 5, 4 * P)&#123; if(F[i - 1] == F[3] &amp;&amp; F[i] == F[4])&#123; Per = i - 4; break; &#125; &#125; *F = 0; FOR(i, 1, Per) F[i] = F[i - 1] + (F[i + 2] == C); function&lt;i64(i64)&gt; Qry = [F, Per](i64 Lim)&#123; i64 res = 0; if(Lim &gt;= 1) res += A == C, --Lim; if(Lim &gt;= 1) res += B == C, --Lim; if(Lim &lt;= 0) return res; return res + F[Per] * (Lim / Per) + F[Lim % Per]; &#125;; i64 L, R; while(Q--)&#123; L = read64(), R = read64(); printf("%lld\n", Qry(R) - Qry(L - 1)); &#125; free(F);&#125;inline void init()&#123; M.a[0][1] = 1; M.a[1][0] = Y; M.a[1][1] = X; M.a[1][2] = Z; M.a[2][2] = 1; S.a[0] = A; S.a[1] = B; S.a[2] = 1; W.clear(); rem.Clear();&#125;inline int Find(Vector v)&#123; FOR(i, 0, SL - 1)&#123; int t = rem.Find(Hash(v)); if(t != -1 &amp;&amp; t - i &lt;= Per) return t - i; v = M * v; &#125; return 0;&#125;void work()&#123; A = read(), B = read(); X = read(), Y = read(), Z = read(); P = read(), C = read(), Q = read(); if(X == 0 &amp;&amp; Y == 0) return work0(); if(X == 0 || Y == 0) return work1(); init(); Per = MxP = P * P - 1; FOR(i, 1, P) if(MxP % i == 0)&#123; if(ksm(M, i).Unit()) chkmin(Per, i); if(ksm(M, MxP / i).Unit()) chkmin(Per, MxP / i); &#125; // SL = sqrt(Per); MM = ksm(M, SL); &#123; Vector v = ksm(M, SL - 1) * S; for(int i = SL, ed_i = Per + SL; i &lt; ed_i; i += SL)&#123; int &amp;tmp = rem[Hash(v)]; if(!tmp) tmp = i; v = MM * v; &#125; v.a[0] = C; v.a[2] = 1; FOR(i, 0, P - 1)&#123; v.a[1] = i; int t = Find(v); if(t) W.emplace_back(t); &#125; sort(W.begin(), W.end()); &#125; i64 L, R; const int t = W.size(); function&lt;i64(i64)&gt; Qry = [t](const i64 &amp;Lim)&#123; return t * (Lim / Per) + upper_bound(W.begin(), W.end(), Lim % Per) - W.begin() - 1; &#125;; while(Q--)&#123; L = read64(), R = read64(); printf("%lld\n", Qry(R) - Qry(L - 1)); &#125;&#125;int main() &#123; IE.a[0][0] = 1; IE.a[1][1] = 1; IE.a[2][2] = 1; int T = read(); while(T--) work(); return 0;&#125; 然后喜提最速解（]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>CodeChef</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1408H」Rainbow Triples]]></title>
    <url>%2Fblog%2FCF1408H%2F</url>
    <content type="text"><![CDATA[被模拟网络流打爆了。 题意简述CF1408H 给定一个长度为 $n$ 的序列 $a$。每次可以选出三个数删掉，需要保证左边和右边的都是 $0$，中间的不是 $0$ 且不能是之前删过的数。求删掉数的最大次数。$n\le 5\times 10^5$。 主要思路设 $cnt(x)$ 为序列中 $x$ 的数量，那么显然答案上界为 $m=\lfloor{cnt(0)\over 2}\rfloor$。假设一个位置左边至少有 $m$ 个 $0$，那么其左边一定可以选出一个 $0$ 来合成答案。右边同理。不难发现每个点总会满足上述性质中的一条，于是可以据此将节点划分为 $L, R$ 两个集合，$L$ 表示满足右边至少有 $m$ 个点的点集，$R$ 反之。 同时不难发现，如果 $L$ 中有数 $x$ 出现至少两次，更右的出现位置更优。$R$ 中同理。所以对于每种颜色 $x$，仅保留两个节点，记为 $l(x), r(x)$。 考虑网络流建图： 源点 $S$ 向每个颜色 $x$ 连一条流量为 $1$ 的边（颜色边）； $x$ 向 $l(x),r(x)$ 连一条流量为 $1$ 的边； $L$ 中每个下标 $i$ 向 $i - 1$ 连边，$R$ 中每个下标 $i$ 向 $i + 1$ 连边，流量均为 $+\infty$； 每个 $0$ 向汇点 $T$ 连一条流量为 $1$ 的边（零边）。 此时，该图的最大流就是需要求的答案。注意到，最大流等于最小割，考虑求解最小割。 显然，我们只会割去颜色边和零边。并且如果颜色边 $x$ 未被割去，则 $l(x)$ 前面的所有零边，$r(x)$ 后面的所有零边都需要被割去。因此，最小割方案必定为割去一段前缀零边，一段后缀零边，一部分颜色边。 枚举割走的 $L$ 中前缀零边，则对于每一段 $R$ 中的零后缀，割走这一段零边的代价是前缀长度、后缀长度、前后缀中均不存在的颜色数量的和。 不难推出，只需维护一个支持区间减一、全局最值的数据结构即可。 于是做完了，时间复杂度 $O(n\log n)$。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;using namespace std;#define FOR(i, a, b) for (int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)inline int read() &#123; int x = 0; char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; return x;&#125;#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define N 500010int n, a[N], m, Lm, Rm;int vis[N], pre[N], suf[N], ans;int Lw[N], Rw[N];int lim, cc;namespace DS&#123;#define lc t &lt;&lt; 1#define rc t &lt;&lt; 1 | 1#define ls lc, l, mid#define rs rc, mid + 1, rint mn[N &lt;&lt; 2], del[N &lt;&lt; 2];inline void Pu(int t)&#123; mn[t] = min(mn[lc], mn[rc]);&#125;inline void Pd(int t)&#123; if(del[t])&#123; const int d = del[t]; del[t] = 0; mn[lc] += d, mn[rc] += d; del[lc] += d, del[rc] += d; &#125;&#125;void Bld(int t, int l, int r)&#123; del[t] = 0; if(l == r) return mn[t] = l, void(); int mid = (l + r) &gt;&gt; 1; Bld(ls), Bld(rs); Pu(t);&#125;void Upd(int t, int l, int r, int L, int R)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) return --mn[t], --del[t], void(); int mid = (l + r) &gt;&gt; 1; Pd(t); if(L &lt;= mid) Upd(ls, L, R); if(R &gt; mid) Upd(rs, L, R); Pu(t);&#125;inline void Upd(int l, int r)&#123; if(l &gt; r) return; Upd(1, 0, lim, l, r);&#125;&#125;inline void work()&#123; n = read(), cc = 0; memset(vis, 0, sizeof(int) * (n + 1)); FOR(i, 1, n) vis[a[i] = read()] = 1; suf[n + 1] = 0; FOR(i, 1, n) if(vis[i]) ++cc; FOR(i, 1, n) pre[i] = pre[i - 1] + (!a[i]); ROF(i, n, 1) suf[i] = suf[i + 1] + (!a[i]); m = pre[n] &gt;&gt; 1, ans = min(m, cc); Lm = 0; FOR(i, 1, n) Lm += pre[i] &lt;= m; Rm = Lm + 1; FOR(i, 1, n) Lw[i] = 0, Rw[i] = n + 1; FOR(i, 1, Lm) Lw[a[i]] = i; ROF(i, n, Rm) Rw[a[i]] = i; lim = suf[Rm]; DS::Bld(1, 0, lim); FOR(i, 1, n) if(vis[i] &amp;&amp; !Lw[i])&#123; DS::Upd(suf[Rw[i]], lim); chkmin(ans, cc + DS::mn[1]); &#125; FOR(i, 1, Lm) if(Lw[a[i]] == i)&#123; DS::Upd(suf[Rw[a[i]]], lim); chkmin(ans, cc + DS::mn[1] + pre[i]); &#125; printf("%d\n", ans);&#125;int main() &#123; int T = read(); while(T--) work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>log数据结构</tag>
        <tag>模拟网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC015F」Kenus the Ancient Greek]]></title>
    <url>%2Fblog%2FAGC015F%2F</url>
    <content type="text"><![CDATA[题意简述给出下列代码： 1234567891011121314151617def F(x, y): if x &lt; y: return F(y, x) if y == 0: return 0 return F(y, x % y) + 1def G(x, y): m = 0 for i in range(1, x + 1): for j in range(1, y + 1): m = max(m, F(i, j)) return mdef W(x, y): m = G(x, y) n = 0 for i in range(1, x + 1): for j in range(1, y + 1): if F(i, j) == m: n += 1 return n % 1000000007 有 $Q$ 个询问，每个询问两个整数 $x, y$，求 $G(x, y), W(x, y)$。$Q\le 3\times 10^5, x, y\le 10^{18}$。 主要思路设斐波那契数列为 $f$，$f_0 = f_1 = 1$。 第一问简单，因为最小的 $(x, y)$ 满足 $F(x, y) = k$ 即为 $(f_k, f_{k+1})$。 设满足 $F(x, y) = G(x, y) = k$ 的二元组 $(x, y)$ 为 $k$ 阶高对子。显然 $k$ 阶高对子数量巨大多，无法直接统计。 但是不难发现许多高对子经过一次迭代就会变得一样，于是试图把这些高对子缩在一起，用一个最小的来表示，称为 $k$ 阶妙对子。显然，$(x, y)$ 是妙对子当且仅当 $(x, y)$ 是高对子且 $y\le 2x$。那么 $(x, y)$ 这个妙对子实际上就表示了 $(x, y + i\times x), i\in \mathbf{N}$。$k$ 阶妙对子的数量很少，是 $O(k)$ 个。 给出前面一些妙对子： 1234(1, 2)(2, 3), (3, 4)(3, 5), (4, 7), (5, 7)(5, 8), (7, 11), (7, 12), (8, 11) 仔细一看，$k$ 阶妙对子就是将所有 $k-1$ 阶妙对子 $(x, y)\to (y, x + y)$，再加一个 $(f_{k+1}, f_{k-1} + f_{k+1})$。 然后就可以 $O(\log^2 lim + Q\log lim)$ 了。 参考代码哦另外要注意的是 $(i, i)$ 均为 $1$ 阶高对子，要特判。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define FOR(i, a, b) for (int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)typedef long long i64;typedef pair&lt;i64, i64&gt; PLL;#define pb emplace_back#define X first#define Y second#define MP make_pair#define mod 10000'00007#define lim 100'0000'0000'0000'0000#define N 128i64 fib[N];vector&lt;PLL&gt; exc[N];int K;const bool __init__ = [ ]()&#123; fib[0] = fib[1] = 1; K = 0; while(fib[K] &lt;= lim) ++K, fib[K + 1] = fib[K] + fib[K - 1]; exc[1].pb(MP(1, 2)); FOR(i, 2, K)&#123; for(PLL t: exc[i - 1]) exc[i].pb(MP(t.Y, t.X + t.Y)); exc[i].pb(MP(fib[i + 1], fib[i - 1] + fib[i + 1])); &#125; return true;&#125;();int main() &#123; int Q; scanf("%d", &amp;Q); while(Q--)&#123; i64 x, y, z(0); scanf("%lld%lld", &amp;x, &amp;y); if(x &gt; y) swap(x, y); int k = 1; while(k &lt; K &amp;&amp; fib[k + 1] &lt;= x &amp;&amp; fib[k + 2] &lt;= y) ++k; for(PLL t: exc[k])&#123; if(t.X &lt;= x &amp;&amp; t.Y &lt;= y) z += (y - t.Y) / t.X + 1; if(t.Y &lt;= x) z += (x - t.Y) / t.X + 1; z %= mod; &#125; if(k == 1) (z += x) %= mod; printf("%d %lld\n", k, z); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>找规律</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC021E」Ball Eat Chameleons]]></title>
    <url>%2Fblog%2FAGC021E%2F</url>
    <content type="text"><![CDATA[题意简述AGC 021E 有 $n$ 条蛇，开始都是蓝色。你有 $k$ 个球，均为红色或蓝色，可以依次喂给蛇。一条蛇如果吃了一个球之后，吃的该颜色的球的总数恰好超过另一种颜色的球，则该蛇会变为该颜色。一个球的颜色序列合法仅当可以合理分配喂蛇顺序使得最后所有蛇都能变为红色。$n, k\le 5\times 10^5$。（由于「🐍️」的渲染效果无法预测，故用「蛇」。） 主要思路下面用B来表示蓝色球，R来表示红色球。 一个显然的事实是，如果给两条未喂过球的蛇都喂了一些B，显然没有将这些B都喂给其中一条优。考虑将这些蓝色的蛇喂回红色需要的R数量即可得到。那么，一个球的颜色序列最后能够得到的红蛇最多的方案应该为：有一条蛇（下称「大蛇」）吃了最后一个球，并且为唯一一条可能吃了超过 $2$ 个球的蛇；其他蛇的吃球序列仅可能为RB或R。（一个球的颜色序列最后能够得到的红蛇最多的方案即，开始假设有无数条蓝蛇，将这个球的颜色序列按顺序喂给蛇后使得最后所有喂过的蛇均为红色，并且红色的蛇的数量最多的一个方案。） 另一个显然的事实是，如果一个球的颜色序列最后能够得到的最多红蛇数量为 $m\ge n$，则其一定能够得到 $n$ 条红蛇。于是，我们考虑最后能够得到的最多红蛇数量为 $m$ 的球的颜色序列。 除了大蛇以外应该还有 $m-1$ 条蛇，注意到这些蛇都会且仅会吃 $1$ 个R，不妨枚举这些R的位置；并且注意到上述定义中吃了最后一个球的是大蛇（实质上是为了钦定大蛇的位置，否则类似RBRBRB的序列则不知哪个是大蛇），所以这些R的位置仅能是前 $k-1$ 个球。于是这里有 $\binom{k-1}{m-1}$ 种放置其他蛇的R的方案。 根据分析可得，每一种放置其他蛇的R的方案都与最后能够得到的最多红蛇数量为 $m$ 的球的颜色序列一一对应。于是答案即为 $\sum\limits_{m=n}^{k}\binom{k-1}{m-1}$。 等等，证明呢以下内容不保证严谨性。证明一个放置其他蛇的R的方案能够推出唯一一个最后能够得到的最多红蛇数量为 $m$ 的球的颜色序列：考虑现在已经放置了 $m-1$ 个其他蛇的R，现在我们做以下操作：从后到前依次考虑每个R的位置，在下一个空位放上一个B，构成一条吃球顺序为RB的蛇。若一个R没有下一个空位，表示该蛇的吃球顺序为R。 考虑剩下的位置（包括最后一个位置），假设有 $c$ 个。如果 $c$ 为奇数，则依次在前 $c-1\over 2$ 个空位填上B，其他填上R；否则依次在前 ${c\over 2}-1$ 个位置与最后一个位置填上B，其他空位填上R。 此时即可满足，得到的颜色序列最后能够得到的红蛇数量为 $m$ ，且其他蛇的R尽量后的方案中，其他蛇的R是开始选出的R。 以下是一个例子，用于感受上述过程： 1234k = 12, m = 5..R.R...RR...RBRB..RRBBBRBRBRRRRBR 证明一个最后能够得到的最多红蛇数量为 $m$ 的球的颜色序列能够推回唯一一个放置其他蛇的R的方案： 注意到在上述为每个其他蛇的R放置B后，整个序列中已经放置球的每个极长段，都有其中的R均与其中的B匹配（这里认为无B与其匹配的R不在极长段内）。并且，由于大蛇的吃球序列的特殊性（B...BR...R或B...BR...RB），放置大蛇吃掉的球后，前 $k-1$ 个球中不会有更长的极长段产生。 所以同理地，找出这些极长段（可以使用类似括号匹配的方式），剩余的序列即为大蛇的吃球序列和一些未匹配的R。显然这些未匹配的R只能是这个剩余的序列次长前缀的一个后缀，找出最长的这样的后缀即可；剩余的即为大蛇的吃球序列。如果这个剩余的序列本身都无法使大蛇变为红色，则该序列本身不合法。 以下是一个例子，用于感受上述过程： 123456k = 14)(()()())((()(BRRBRBRBBRRRBRB........RR..R +5B........R...R +1m = 6 综上，即可得每一种放置其他蛇的R的方案都与最后能够得到的最多红蛇数量为 $m$ 的球的颜色序列一一对应。 参考代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;#define FOR(i, a, b) for (int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;#define mod 998244353inline int ksm(int x, i64 y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = (i64)x * x % mod) if (y &amp; 1) res = (i64)res * x % mod; return res;&#125;inline void inc(int &amp;x, const int &amp;y)&#123; x += y; if(x &gt;= mod) x -= mod; &#125;#define N 500010int n, K;int fac[N], ifac[N];void init(int T) &#123; *fac = *ifac = 1; FOR(i, 1, T) fac[i] = (i64)i * fac[i - 1] % mod; ifac[T] = ksm(fac[T], mod - 2); ROF(i, T - 1, 1) ifac[i] = (i + 1ll) * ifac[i + 1] % mod;&#125;inline int CC(int n, int m) &#123; if (m &lt; 0 || n &lt; m) return 0; return (i64)fac[n] * ifac[m] % mod * ifac[n - m] % mod;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;K); init(K); int ans = 0; FOR(i, n, K) inc(ans, CC(K - 1, i - 1)); printf("%d\n", ans); return 0;&#125; 你蛇红了.jpg]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg 小记]]></title>
    <url>%2Fblog%2Fffmpeg-%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[被 myy 送退役了，于是这个 blog 以后可能大部分都是这些内容了。 安装首先安装。Linux 用户显然会自己搞。Windows 人得去下编译好的包，gyan.dev和BtbN不知道有什么区别。 然后ffmpeg --help就可以看到简短的帮助了。想看到完整的帮助可以ffmpeg -h full（长约 1MB 警告）。 简要介绍咕了。 使用例curl下载网课（分段.ts）并用ffmpeg合并我比较菜找不到.m3u8，然后恰好某网站的.ts又是顺序排列的，于是直接请求到返回404为止，再ffmpeg合并就好了。 颇具 oi 风格的码风，坏 12345678910111213141516171819#!/bin/bashS="https://example.com/"rm list.infor ((i=0;$i&lt;=9999;i+=1))do j=$((i+10000))"" j=$&#123;j:1:4&#125; # echo $j info=`curl -I $S$j.ts` code=`echo $info|grep "HTTP"|awk '&#123;print $2&#125;'` if [ "$code" == "200" ]; then curl -O $S$j.ts echo file \'$j.ts\' &gt;&gt; list.in fidoneffmpeg -f concat -i list.in demo.mp4]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2018」GOSICK]]></title>
    <url>%2Fblog%2FYnoi2018-GOSICK%2F</url>
    <content type="text"><![CDATA[不知道哪个阴间搬题人，陆续给模拟赛里整了第二分块、第七分块、第十四分块。 第二分块之前写的空间垃圾时间垃圾然后懒得搞了。 第七分块并没有看懂题解。 于是就只能写写这个了。 卡常卡不过别人的主要原因是懒（确信） Idea：lxl Solution：lxl Std：lxl Data：lxl “点缀光辉的第十四分块” （妈呀这名字好中二啊（谁叫我要用日本轻小说中的东西命名真是作死）） 这题是我研究区间逆序对之后，枚举了一些区间pair贡献的题里面的一个 对这题的评价：8/11 —— lxl 博客 Luogu 5398 CometOJ contest#3 F 题意简述给定长为 $n$ 的正整数序列 $\langle a\rangle$，$m$ 次询问给一个区间 $[l, r]$。 查询 $l\le i, j\le r$，且 $a_i$ 是 $a_j$ 的倍数的二元组 $(i, j)$ 的个数。 值域 $[1, W]$，$n, m, W\le 5\times 10^5$。 主要思路前置知识：莫队二次离线。 然后就只用考虑求 $S([1, i], [1, i])$ 和 $S([1, i], [l, r])$ 力。 下面将以 $n, m, W$ 同阶讨论。 那实际上就两个操作： $O(n)$ 次令当前维护区间从 $[1, i - 1]$ 变为 $[1, i]$。 求 $S([1, i], [l, r])$，个数为 $O(n)$ 且长度和为 $O(n\sqrt{n})$。 考虑维护 $c(v), b(v)$ 分别表示 $v$ 的倍数/约数的个数。则加入一个数 $x$，新增的贡献就是 $c(x) + b(x) + 1$。 并且对于每个约数 $y$，$c(y)$ 要加 $1$；每个倍数 $z$，$b(z)$ 要加 $1$。 枚举约数 $O(\sqrt{n})$ 没啥问题。 枚举倍数 $O({n\over x})$ 时间，当 $x$ 太小就退化为 $O(n)$ 了。 于是试图阈值法，设阈值 $D=\sqrt{n}$。 然后 $x&gt;D$ 的就直接枚举倍数，$O(\sqrt{n})$；否则不管。 但是新加一个数的贡献就出问题了。于是维护一个 $cnt(x)$ 记 $x$ 的个数，然后加入数 $x$ 的贡献就是 $1+c(x)+\sum\limits_{d|x}cnt(d)$。 那么考虑第二个操作。 长度和为 $O(n\sqrt{n})$，所以先枚举 $[l, r]$ 的每个元素，假设当前元素值为 $x$。 $x$ 的倍数个数即 $c(x)$，这个已经处理好了；$x$ 的大于 $D$ 的约数个数即 $b(x)$，这个也已经处理好了；现在剩下求 $x$ 的不大于 $D$ 的约数个数。 由于 $D=\sqrt{n}$，可以枚举所有不大于 $D$ 的数 $t$，求 $[l, r]$ 中 $t$ 的倍数的数量之和。容易发现这个和就是刚才没求的东西。 $[l, r]$ 中 $t$ 的倍数的数量和可以直接前缀和，维护 $pre(i, t)$ 表示前 $i$ 个数中 $t$ 的倍数的个数。预处理 $O(nD)$。 于是做完了，时间复杂度 $O(n\sqrt{n})$。 卡常枚举一个数的因数可以 $O(n\log n)$ 空间时间预处理出来扔vector里。 如果直接维护 $pre(i, t)$，空间是 $O(nD)$，意味着 $D$ 大约只能开到 $180$。 然后俺真就直接开了 $180$，然后发现实际上跑得很慢（指勉强过）。 看了看 mrsrz 的代码，发现只开了 $D=99$，一改，果然快了不少（指快了不到 3s）。 反正卡不过 mrsrz 的手写 vector 和「阈值再分块」（其代码做 11 次连续 9 个数作为因数的信息，据说可以卡进 cache）。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;#define pb push_back#define fr first#define sc second#define pq priority_queue#define MP make_pair#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define MMR (1 &lt;&lt; 24)struct INBUF&#123; char buf[MMR], *s, *t; inline INBUF()&#123; t = (s = buf) + fread(buf, 1, MMR, stdin); &#125; inline INBUF&amp; operator &gt;&gt;(int &amp;x)&#123; x = 0; while(*s &lt; 48) s++; while(*s &gt; 47) x = x * 10 + (*s++ ^ 48); return *this; &#125;&#125;fin;struct OUTBUF&#123; char buf[MMR], *s; inline OUTBUF()&#123; s = buf; &#125; inline OUTBUF&amp; operator &lt;&lt;(i64 x)&#123; // assert(x &gt;= 0); static char tmp[20]; char *top = tmp; do&#123; *++top = (x % 10) ^ 48, x /= 10; &#125;while(x &gt; 0); while(top != tmp) *s++ = *top--; *s++ = 10; return *this; &#125; inline ~OUTBUF()&#123; fwrite(buf, 1, s - buf, stdout); &#125;&#125;fout;#define N 500005#define WM 500000int n, m;int a[N];int bl[N];int BB;struct ASK&#123; int l, r, i; inline bool operator &lt;(const ASK &amp;x)const&#123; return bl[l] != bl[x.l] ? l &lt; x.l : (bl[l] &amp; 1 ? r &lt; x.r : r &gt; x.r); &#125;&#125;ask[N];vector&lt;int&gt; dvs[N];// #define BB 846#define VN 101#define VB 99int pre[N][VN];//pre[i][v]: 前 i 个数中，是 v 倍数（包括 v）的数的个数struct Node&#123; int l, r, i, v;&#125;;vector&lt;Node&gt; qL[N], qR[N];int cnt[N];int cc[N];//cc[v]: v 的倍数（包括 v）的个数int bc[N];//bc[v]: v 的大于 VB 的约数（包括 v）的个数i64 ansL[N], ansR[N];i64 ans[N];int main() &#123; fin &gt;&gt; n &gt;&gt; m; BB = n / (sqrt(m * 2 / 3) + 1) + 1; int mx = 0; FOR(i, 1, n)&#123; Rint x; fin &gt;&gt; x; a[i] = x; bl[i] = bl[i - 1] + (i % BB == 1); chkmax(mx, a[i]); // FOR(j, 1, VB)&#123; // pre[i][j] = pre[i - 1][j] + (x % j == 0); // &#125; &#125; FOR(i, 1, mx)&#123; for(int j = i; j &lt;= mx; j += i)&#123; dvs[j].pb(i); &#125; &#125; FOR(i, 1, m) fin &gt;&gt; ask[i].l &gt;&gt; ask[i].r, ask[i].i = i; sort(ask + 1, ask + m + 1); ask[0].l = 1; FOR(i, 1, m)&#123; if(ask[i].r &gt; ask[i - 1].r)&#123; qR[ask[i - 1].l - 1].pb((Node)&#123; ask[i - 1].r + 1, ask[i].r, i, -1 &#125;); &#125;else if(ask[i].r &lt; ask[i - 1].r)&#123; qR[ask[i - 1].l - 1].pb((Node)&#123; ask[i].r + 1, ask[i - 1].r, i, 1 &#125;); &#125; if(ask[i].l &lt; ask[i - 1].l)&#123; qL[ask[i].r + 1].pb((Node)&#123; ask[i].l, ask[i - 1].l - 1, i, -1 &#125;); &#125;else if(ask[i].l &gt; ask[i - 1].l)&#123; qL[ask[i].r + 1].pb((Node)&#123; ask[i - 1].l, ask[i].l - 1, i, 1 &#125;); &#125; &#125; FOR(i, 1, n)&#123; reg const int x = a[i]; ansL[i] = ansL[i - 1] + cc[x] + 1; for(Rint j: dvs[x]) ansL[i] += cnt[j], ++cc[j]; if(x &gt; VB)&#123; for(int j = x; j &lt;= mx; j += x) ++bc[j]; &#125; ++cnt[x]; for(reg Node o: qR[i])&#123; reg i64 res = 0; FOR(j, o.l, o.r)&#123; res += cc[a[j]]; res += bc[a[j]]; &#125; // FOR(j, 1, VB)&#123; // res += (i64)cnt[j] * (pre[o.r][j] - pre[o.l - 1][j]); // &#125; o.v &gt; 0 ? (ans[o.i] += res) : (ans[o.i] -= res); &#125; &#125; memset(cnt, 0, sizeof(int) * N); memset(cc, 0, sizeof(int) * N); memset(bc, 0, sizeof(int) * N); ROF(i, n, 1)&#123; reg const int x = a[i]; ansR[i] = ansR[i + 1] + cc[x] + 1; for(Rint j: dvs[x]) ansR[i] += cnt[j], ++cc[j]; if(x &gt; VB)&#123; for(int j = x; j &lt;= mx; j += x) ++bc[j]; &#125; ++cnt[x]; for(reg Node o: qL[i])&#123; reg i64 res = 0; FOR(j, o.l, o.r)&#123; res += cc[a[j]]; res += bc[a[j]]; &#125; // FOR(j, 1, VB)&#123; // res += (i64)cnt[j] * (pre[o.r][j] - pre[o.l - 1][j]); // &#125; o.v &gt; 0 ? (ans[o.i] += res) : (ans[o.i] -= res); &#125; &#125; &#123; const int vL = 1, vR = VB; int *c = (int*)malloc(sizeof(int) * VB); memset(c, 0, sizeof(int) * VB); FOR(i, 1, n) FOR(j, vL, vR)&#123; pre[i][j - vL] = pre[i - 1][j - vL] + (a[i] % j == 0); &#125; FOR(i, 1, n)&#123; const int x = a[i]; for(reg Node o: qL[i])&#123; reg i64 res = 0; FOR(j, vL, vR)&#123; res += (i64)(cnt[j] - c[j - vL]) * (pre[o.r][j - vL] - pre[o.l - 1][j - vL]); &#125; o.v &gt; 0 ? (ans[o.i] += res) : (ans[o.i] -= res); &#125; if(vL &lt;= x &amp;&amp; x &lt;= vR) ++c[x - vL]; for(reg Node o: qR[i])&#123; reg i64 res = 0; FOR(j, vL, vR)&#123; res += (i64)c[j - vL] * (pre[o.r][j - vL] - pre[o.l - 1][j - vL]); &#125; o.v &gt; 0 ? (ans[o.i] += res) : (ans[o.i] -= res); &#125; &#125; free(c); &#125; reg i64 *res = (i64*)malloc(sizeof(i64) * N); FOR(i, 1, m)&#123; ans[i] += ansL[ask[i].r] + ansR[ask[i].l] - ansL[ask[i - 1].r] - ansR[ask[i - 1].l]; res[ask[i].i] = ans[i] += ans[i - 1]; &#125; FOR(i, 1, m) fout &lt;&lt; res[i]; free(res); return 0;&#125; 感觉这题难度主要在莫队二次离线，后面的思路其实非常自然。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Ynoi</tag>
        <tag>莫队</tag>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF493E」Vasya and Polynomial]]></title>
    <url>%2Fblog%2FCF493E%2F</url>
    <content type="text"><![CDATA[题意简述CF493E 给三个正整数 $A, B, C$，求有多少个非负整数系数多项式 $f(x)$，满足 $f(A)=B,f(B)=C$。无穷个则输出-1。有限个，则求出次数最高，并且系数从高到低字典序最小的一个。$A, B, C\le 10^{18},T\le 100$。 主要思路这个是打某个神奇模拟赛的时候做到的，看起来比原题加强了一点（好像并没有）。 首先特判掉特殊情况，只考虑 $A&lt;B&lt;C$。记 $f(A)=B,f(B)=C$ 为「基本条件」。 发现非负整数系数不知道怎么弄，就先来个整数系数。 那么显然可以构造一次函数 $L(x) = t_1x + t_0$，其中 $t_1 = {C-B\over B-A}$。如果 $t_1$ 不是整数，则不可能有满足「基本条件」的整系数多项式，直接无解。 考虑另一个满足「基本条件」的整系数多项式 $F(x)$，以及 $F(x)-L(x)=G(x)$。不难发现有 $G(A)=0,G(B)=0$，故 $G(x)$ 必含有因式 $(x-A)(x-B)$。 于是一个满足「基本条件」的整系数多项式可以被写成 $F(x)=L(x)+(x-A)(x-B)P(x)$ 的形式，其中 $P(x)$ 也是整系数多项式。 我们希望在 $L(x)$ 的基础上将 $F(x)$ 修改为非负整系数多项式。考虑到次数 $lim\le{\ln C\over\ln B}$ 不大，直接暴力求出 $P(x)$ 的系数即可。具体来说就是对于次数 $i\le lim - 2$，假设 $F(x)$ 当前次数的系数 $a_i&lt;0$，可以直接给 $P(x)$ 加一个 $\lceil{-a_i \over AB}\rceil x^i$ 来让其系数非负。 最后如果 $a_{lim-1}&lt;0$ 就无解了，否则获得了一个唯一的解。 至于这个解为什么唯一，通过本做法比较难证明，建议阅读原题解。当然也可以通过感性理解，比如发现自己没法构造出一种超过两个解的情况，就认为没有多解。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;#define Templ(T) template &lt;typename T&gt;&#125; // namespace my_stdusing namespace my_std;#define MMR 70i64 A, B, C;i64 T1, T0;i64 K1, K0;i64 a[MMR];int a_l;#define dvc(x, y) (((x) - 1) / (y) + 1)void work()&#123; if(A == B)&#123; if(A == C)&#123; if(A == 1) return puts("-1"), void(); puts("2\n1 1 0"); return void(); &#125; return puts("0"), void(); &#125; if(B == C)&#123; printf("1\n0 %lld\n", B); return void(); &#125; if(A &gt; B || B &gt; C)&#123; return puts("0"), void(); &#125; if((C - B) % (B - A) != 0)&#123; return puts("0"), void(); &#125; T1 = (C - B) / (B - A); T0 = B - T1 * A; const int lim = log2(C) / log2(B); if(lim == 1)&#123; if(T0 &lt; 0) return puts("0"), void(); printf("1\n1 %lld %lld\n", T1, T0); return; &#125; K1 = (A + B), K0 = A * B; FOR(i, 0, lim) a[i] = 0; a[0] = T0, a[1] = T1; FOR(i, 0, lim - 2)&#123; if(a[i] &lt; 0)&#123; i64 W = dvc(-a[i], K0); a[i] += K0 * W; a[i + 1] -= K1 * W; a[i + 2] += W; &#125; &#125; if(a[lim - 1] &lt; 0)&#123; return puts("0"), void(); &#125; ROF(i, lim, 0) if(a[i] &gt; 0)&#123; a_l = i; break; &#125; printf("1\n%d ", a_l); ROF(i, a_l, 0) printf("%lld ", a[i]); puts("");&#125;int main() &#123; int esac; scanf("%d", &amp;esac); while(esac --)&#123; scanf("%lld%lld%lld", &amp;A, &amp;B, &amp;C); work(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>猜结论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[waifu-2x 初探]]></title>
    <url>%2Fblog%2Fwaifu-2x-%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[waifu2x 是一个用于 ACGN 风格图像的图像缩放和图像降噪程序，也支持处理普通照片。 很久以前我用了一下一个 demo application，但是它只支持放大不大于 1500x1500px 的图像，不是非常能用。 waifu2x-caffelltcggie/waifu2x-caffe waifu2x-caffe 是一个 waifu2x 实现，有 GUI 版和 CUI 版。 然后这个版本只支持用 CPU 或者 Nvidia 显卡的 cuDNN 和 CUDA。 但是我学校生产环境的显卡很烂，是Intel(R) UHD Graphics 630，于是没法用 cuDNN 和 CUDA，就只能 CPU 硬上。 然后 CUI 版参数啥的文档很详细，不讲了。 至于UpRGB,RGB,UpResNet10,CUnet之间有啥区别，我的两只瞎掉的眼睛并不能看出来区别。 如果有人知道这这四个模型分别有啥区别，请 comment。 waifu2x-ncnn-vulkannihui/waifu2x-ncnn-vulkan 然后俺找到了这个，可以跑在 Intel/AMD/Nvidia GPU 上。 于是快乐冲锋。 参数啥的文档一样很详细。 BB waifu2x 的核心是一个用于超分辨率成像的卷积神经网络(SRCNN)。它使用了 NVIDIA CUDA 技术，但也有使用 OpenCL 和 Vulkan 的替代实现。 所以 wikipedia 里面说的 Vulkan 实现大概就是上面那个？然后 OpenCL 实现大概有 marcan/cl-waifu2x 之类？ 参考资料waifu2x-caffe下载及使用教程——二次元动漫图片无损降噪放大软件 | 飞翔的小兽人 在自家电脑使用WAIFU2X无损放大插画 | ACFUN-AK]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1442E」Black, White and Grey Tree]]></title>
    <url>%2Fblog%2FCF1442E%2F</url>
    <content type="text"><![CDATA[题意简述给一棵树，树上每个节点都为灰色、白色或黑色。每次可以选择一个连通块中的一个节点集合，要求集合中不能同时存在黑色和白色的节点，然后删去集合中所有节点。问最少多少次可以把整棵树删完。 $n\le 200000$。 主要思路首先玩仅有黑色和白色。显然相同颜色的连通块可以缩成一个点，先钦定任意一条边两端颜色不同。不难发现答案为 $\lfloor{k\over 2}\rfloor+1$，其中 $k$ 为直径的长度（点的数量）。 那么有灰色的时候，就是要把每个灰色的点赋一种颜色，使得直径最短。不妨思考一下直径的求法：随便取一个点 $S_0$ 为根，dfs 找到树上深度最大的点 $S_1$；再以 $S_1$ 为根 dfs 找到深度最大的点 $S_2$；$S_1,S_2$ 即为直径的两个端点。 那么再次考虑仅有黑色和白色，不难发现直接套用上述算法，更改深度定义为「到根路径上极长颜色相同段个数」即可。 再考虑有灰色。如果 dfs 到一个灰色的点，我们钦定其为其最近的非灰色祖先的颜色。显然，（由于钦定了灰色点的颜色）产生贡献的地方仍然只有黑白间。但是在选深度最深点的时候，灰色点应该优先级低于黑白色的点的。就没了。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define FOR(i, a, b) for (int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)inline int read() &#123; int x = 0; char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; return x;&#125;#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define N 200010int n, a[N], ans, rt, col;std::vector&lt;int&gt; E[N];void dfs(int u, int fa, int now, int dis)&#123; if(!col || chkmax(ans, dis)) rt = u, col = now; for(int v: E[u]) if(v != fa)&#123; dfs(v, u, a[v] ? a[v] : now, dis + ((now ^ a[v]) == 3)); &#125;&#125;void work()&#123; n = read(); ans = -1, col = 0; FOR(i, 1, n) a[i] = read(), E[i].clear(); FOR(i, 1, n - 1)&#123; int u = read(), v = read(); E[u].emplace_back(v), E[v].emplace_back(u); &#125; dfs(1, 0, a[1], 0); dfs(rt, 0, col, 0); printf("%d\n", (ans + 3) &gt;&gt; 1);&#125;int main()&#123; FOR(o, 1, read()) work();&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>Codeforces</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeChef WALKBT」Walks on the binary tree]]></title>
    <url>%2Fblog%2FCC-WALKBT%2F</url>
    <content type="text"><![CDATA[题意简述CodeChef WALKBT 一棵高度为 $n$ 的满二叉树（节点数为 $2^{n+1}-1$），用一个 $[0,2^n)$ 的数 $X$ 表示一条根到叶子的路径（从最高位开始，为0则走左儿子，否则走右儿子）。 初始 $X = 0$，有两种操作共 $q$ 个： 将 $X$ 改为 $(X + 2^C) \bmod 2^n$，然后从根出发走到叶子。 询问当前有多少个节点至少被访问一次。 $n,q\le 10^5$。 主要思路考虑一次新增的节点数，不难发现是 $n$ 减去新的 $X$ 与之前所有数的 lcp 的最大值。不难发现这个最大值必然在新 $X$ 的前驱或后继中取得。 考虑加上 $2^C$ 的操作，实质上是把前面的一段1赋为0，把一个0赋为1。于是每个修改操作只会改变均摊 $O(1)$ 个位置。于是可以上棵可持久化线段树维护每个位的值。 那么如何比较大小？可以在可持久化线段树上二分第一个两数不同的位置，然后 $O(\log n)$ 比较。那么我们希望能够 $O(1)$ 比较两棵线段树上的一个区间是否完全相等。这个哈希一下就好了。 于是我们获得了一个 $O(\log n)$ 比较大小的方法，再套个set维护前驱后继就 $O(n\log^2n)$ 走了。 然后这题被出到模拟赛里有人被卡常了，所以是 CC 太快还是 CC 数据水啊（ 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;typedef const int CI;#define fr first#define sc second#define MP make_pair#define Templ(T) template &lt;typename T&gt;inline int read() &#123; Rint ans = 0; reg char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) ans = ans * 10 + c - '0'; return ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define m1 88888901#define m2 77777803&#125; // namespace my_stdusing namespace my_std;#define N 200010int pw1[N], pw2[N];const bool init = [&amp;]()&#123; *pw1 = *pw2 = 1; FOR(i, 1, N - 1)&#123; pw1[i] = (pw1[i - 1] &lt;&lt; 1) % m1; pw2[i] = (pw2[i - 1] &lt;&lt; 1) % m2; &#125; return true;&#125;();int n, q;int rt[N], lc[N &lt;&lt; 5], rc[N &lt;&lt; 5], s1[N &lt;&lt; 5], s2[N &lt;&lt; 5];int tt, cc;#define lt lc[t]#define rt rc[t]#define ls lc[s]#define rs rc[s]#define f1 s1[t]#define f2 s2[t]#define g1 s1[s]#define g2 s2[s]void upd(int &amp;t, CI &amp;s, CI &amp;l, CI &amp;r, CI &amp;p, CI &amp;v)&#123; t = ++cc; lt = ls, rt = rs; f1 = g1, f2 = g2; if(l == r) return f1 = f2 = v, void(); CI mid = (l + r) &gt;&gt; 1; if(p &lt;= mid) upd(lt, ls, l, mid, p, v); else upd(rt, rs, mid + 1, r, p, v); f1 = (s1[lt] + (i64)pw1[mid - l + 1] * s1[rt]) % m1; f2 = (s2[lt] + (i64)pw2[mid - l + 1] * s2[rt]) % m2;&#125;int is_1(CI &amp;t, CI &amp;l, CI &amp;r, CI &amp;p)&#123; if(!t) return 0; if(l == r) return s1[t]; CI mid = (l + r) &gt;&gt; 1; if(p &lt;= mid) return is_1(lt, l, mid, p); else return is_1(rt, mid + 1, r, p);&#125;pair&lt;bool, int&gt; cpr(CI &amp;t, CI &amp;s, CI &amp;l, CI &amp;r)&#123; if(l == r) return MP(f1 &lt;= g1, f1 == g1 ? -1 : l); CI mid = (l + r) &gt;&gt; 1; if(s1[rt] == s1[rs] &amp;&amp; s2[rt] == s2[rs]) return cpr(lt, ls, l, mid); else return cpr(rt, rs, mid + 1, r);&#125;#undef lt#undef rt#undef ls#undef rs#undef f1#undef f2#undef g1#undef g2#define upd(p, v) \ ++tt, upd(rt[tt], rt[tt - 1], 0, n - 1, p, v)#define cpr(t, s) \ cpr(t, s, 0, n - 1)struct cmp&#123; inline bool operator()(CI &amp;x, CI &amp;y)const&#123; return cpr(rt[x], rt[y]).fr; &#125;&#125;;typedef set&lt;int, cmp&gt; SCI;SCI st;i64 ans;inline void work()&#123; ans = 0, tt = 0, cc = 0; st.clear(); n = read(), q = read(); FOR(o, 1, q)&#123; char c = getchar(); while(c != '!' &amp;&amp; c != '?') c = getchar(); if(c == '?')&#123; printf("%lld\n", ans ? ans : 1); continue; &#125; int x = read(); while(x &lt; n &amp;&amp; is_1(rt[tt], 0, n - 1, x)) upd(x++, 0); if(x &lt; n) upd(x, 1); SCI::iterator i = st.insert(tt).fr, nxt = next(i), pre = prev(i); int res = n; if(i != st.begin()) chkmin(res, cpr(rt[*i], rt[*pre]).sc); if(nxt != st.end()) chkmin(res, cpr(rt[*i], rt[*nxt]).sc); ans += res + 1; // printf("%lld\n", ans); &#125;&#125;int main() &#123; int esac = read(); while(esac--) work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>log数据结构</tag>
        <tag>线段树</tag>
        <tag>CodeChef</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NEERC 2013 选做]]></title>
    <url>%2Fblog%2FGYM100307%2F</url>
    <content type="text"><![CDATA[2013-2014 ACM-ICPC Northeastern European Regional Contest (NEERC 13) A - ASCII Puzzle C - Cactus Automorphisms D - Dictionary E - Easy Geometry G - Green Energy H - Hack Protection I - Interactive Interception K - Kabaleo Lite C - Cactus Automorphisms题意简述给一棵仙人掌（$n\le 5\times 10^4$），求其自同构的数量。图的自同构是一个从 $V$ 到 $V$ 的一一映射 $m$，满足对于任意边 $\{u, v\}\in E$，均有 $\{m(u), m(v)\}\in E$。 主要思路考虑树怎么做：显然重心置换之后还是重心，所以令重心为根（有两个就新建一个虚根），然后树哈希。 如何推广到仙人掌？直接建圆方树，那么对原图置换之后相当于对圆方树进行置换。此时圆点不能变成方点，所以有两个重心的时候，只取一个为根。 由于方点的儿子是有序的，所以方点只支持 reverse 儿子序列；但如果方点是根那么就是循环移位加翻转，一共 $2\times cnt(cir)$ 种。 D - Dictionary题意简述给 $n$ 个单词 $a_i$，你需要构造一棵 Trie，使得每个单词都能表示为某个节点到其子树内某个节点的这段路径，并且 Trie 上的节点最少。$n\le 50$，单词长度都不超过 $10$。 主要思路首先至多要 $\sum|a_i|$ 个点。 考虑把一个单词 $a$ 的一个前缀接在另一个单词 $b$ 的一个子串上，那么就能节省这个前缀的长度。 于是就转化为在一个有向完全图上求一棵最大的树形图。这个树形图上的边全都可以省。 朱刘算法冲冲冲。 顺带一提这个题要方案于是写起来很垃圾。实际上因为数据很小，随便写都能过，感觉也还好。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;#define SZ(x) ((int)(x).size())#define pb push_back#define fr first#define sc second#define MP make_pair#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;const bool __file__ = [&amp;]()&#123; freopen("dictionary.in", "r", stdin); freopen("dictionary.out", "w", stdout); return true;&#125;();#define N 55#define NN 550inline bool is_sub(const string &amp;x, const string &amp;y)&#123; if(SZ(x) &gt; SZ(y)) return 0; FOR(i, 0, SZ(x) - 1) if(x[i] != y[i]) return 0; return 1;&#125;inline int get_wgh(const string &amp;x, const string &amp;y)&#123; int res = 0; FOR(i, 0, SZ(x) - 1) FOR(j, 1, SZ(x) - i)&#123; if(is_sub(x.substr(i, j), y)) chkmax(res, j); &#125; return res;&#125;struct Edge&#123; int from, wgh; inline Edge(): from(0), wgh(0)&#123;&#125; inline Edge(int _f, int _w): from(_f), wgh(_w)&#123;&#125;&#125;;struct Vertice&#123; vector&lt;Edge&gt; in; int pre, wgh; inline Vertice(): pre(-1)&#123;&#125;&#125;;void MDST(vector&lt;Vertice&gt; &amp;P)&#123; const int n = SZ(P) - 1; // printf(": %d\n", n); P[0].pre = -1; FOR(i, 1, n)&#123; P[i].pre = P[i].wgh = -0x3f3f3f3f; for(Edge e: P[i].in) if(chkmax(P[i].wgh, e.wgh))&#123; P[i].pre = e.from; &#125; &#125; // FOR(i, 1, n) printf("%d%c", P[i].pre, " \n"[i == ed_i]); // FOR(i, 1, n) printf("%d%c", P[i].wgh, " \n"[i == ed_i]); vector&lt;int&gt; vis(n + 1, 0); VI cir; FOR(i, 1, n) if(!vis[i])&#123; stack&lt;int&gt; sk; vis[i] = 2, sk.push(i); int x = P[i].pre; while(x != -1 &amp;&amp; !vis[x]) vis[x] = 2, sk.push(x), x = P[x].pre; // printf("-- %d %d\n", i, x); if(vis[x] == 2)&#123; FOR(j, 1, n) vis[j] = 0; int j; while((j = sk.top()) != x) cir.pb(j), vis[j] = 1, sk.pop(); cir.pb(j), vis[j] = 1; break; &#125; while(!sk.empty()) vis[sk.top()] = 1, sk.pop(); &#125; if(cir.empty())&#123; // puts("No Cir!"); return; &#125; // FOR(i, 1, n) printf("%d%c", vis[i], " \n"[i == ed_i]); VI id(n + 1); int sz = 0; id[0] = 0; FOR(i, 1, n) if(!vis[i]) id[i] = ++sz; ++sz; for(int i: cir) id[i] = sz; vector&lt;Vertice&gt; Q(sz + 1); FOR(i, 1, n) if(vis[i])&#123; for(Edge e: P[i].in) if(!vis[e.from]) Q[sz].in.pb(Edge(id[e.from], e.wgh - P[i].wgh)); &#125;else&#123; for(Edge e: P[i].in) Q[id[i]].in.pb(Edge(id[e.from], e.wgh)); &#125; MDST(Q); VI rd(sz + 1); rd[0] = 0; FOR(i, 1, n) if(!vis[i]) rd[id[i]] = i; FOR(i, 1, n) if(!vis[i])&#123; if(Q[id[i]].pre == sz)&#123; for(Edge e: P[i].in) if(vis[e.from] &amp;&amp; e.wgh == Q[id[i]].wgh)&#123; P[i].pre = e.from; P[i].wgh = e.wgh; break; &#125; &#125;else&#123; P[i].pre = rd[Q[id[i]].pre]; P[i].wgh = Q[id[i]].wgh; &#125; &#125; [&amp;]()&#123; for(int i: cir)&#123; for(Edge e: P[i].in) if(e.from == rd[Q[sz].pre] &amp;&amp; e.wgh == P[i].wgh + Q[sz].wgh)&#123; P[i].wgh = e.wgh; P[i].pre = e.from; return; &#125; &#125; &#125;(); // FOR(i, 1, n) printf("%d%c", P[i].pre, " \n"[i == ed_i]); // FOR(i, 1, n) printf("%d%c", P[i].wgh, " \n"[i == ed_i]); // puts("-----"); return;&#125;int n;string key[N];int e[N][N];int ans = 1;int vis[N];int G[NN][26];int hd[N], cc;char fc[NN];int fth[NN];int main() &#123; cin &gt;&gt; n; FOR(i, 1, n) cin &gt;&gt; key[i], ans += SZ(key[i]); vector&lt;Vertice&gt; P(n + 1); FOR(i, 1, n) FOR(j, 1, n) if(i != j)&#123; e[i][j] = get_wgh(key[i], key[j]); // printf("%d %d %d\n", i, j, e[i][j]); P[j].in.pb(Edge(i, e[i][j])); &#125; FOR(i, 1, n) P[i].in.pb(Edge(0, -0x3f3f3f)); MDST(P); // printf("%d\n", ans); FOR(i, 1, n) if(P[i].pre &gt; 0) ans -= P[i].wgh; printf("%d\n", ans); function&lt;void(int)&gt; dfs = [&amp;](const int &amp;u)&#123; const int fa = P[u].pre, len = P[u].wgh; if(!fa)&#123; int t = hd[u] = ++cc; for(char c: key[u]) t = (G[t][c - 'a'] = ++cc); return; &#125; if(!hd[fa]) dfs(fa); const string x = key[fa], y = key[u]; int t = hd[fa]; int s = len == 0 ? SZ(x) : [&amp;]()&#123; FOR(i, 0, SZ(x) - len) if(is_sub(x.substr(i, len), y))&#123; return i; &#125; return SZ(x); &#125;(); FOR(i, 0, s - 1) t = G[t][x[i] - 'a']; hd[u] = t; FOR(i, s, s + len - 1) t = G[t][x[i] - 'a']; assert(SZ(y) == len || G[t][y[len] - 'a'] == 0); FOR(i, len, SZ(y) - 1) t = G[t][y[i] - 'a'] = ++cc; &#125;; FOR(i, 1, n) if(!hd[i]) dfs(i); FOR(i, 1, cc)&#123; int j; FOR(c, 0, 25) if((j = G[i][c])) fc[j] = c + 'a', fth[j] = i; &#125; FOR(i, 1, cc)&#123; if(fth[i]) printf("%d %c\n", fth[i], fc[i]); else printf("0\n"); &#125; return 0;&#125; H - Hack Protection题意简述给个序列，求有多少个区间异或和等于按位与的值。$n\le 10^5,W&lt;2^{31}$。 主要思路从左到右枚举右端点，注意到右端点往左 AND 只有 $O(\log W)$ 种不同的值。再 XOR 前缀和一下。于是相当于求 $O(n\log W)$ 个区间中某个数的数量。随便 $O(n\log W\log n)$。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;typedef vector&lt;int&gt; VI;typedef pair&lt;int, int&gt; PII;#define MP(a, b) make_pair(a, b)#define pb push_back#define fr first#define sc second#define MMR (1 &lt;&lt; 22)struct INPUT&#123; FILE *F; char buf[MMR], *s, *t; INPUT(): F(fopen("hack.in", "r"))&#123; t = (s = buf) + fread(buf, 1, MMR, F); fclose(F); &#125; inline INPUT&amp; operator &gt;&gt;(int &amp;x)&#123; x = 0; reg char c(*s++); while(!isdigit(c)) c = *s++; while(isdigit(c)) x = x * 10 + c - 48, c = *s++; return *this; &#125;&#125;fin;#define N 100010int n;int a[N], s[N];VI ps[N];map&lt;int, int&gt; mp;inline int md(const int &amp;x)&#123; if(mp.count(x)) return mp[x]; return mp[x] = mp.size() + 1;&#125;inline int count(const int &amp;l, const int &amp;r, const int &amp;x)&#123; if(!mp[x]) return 0; VI &amp;f = ps[md(x)]; return lower_bound(f.begin(), f.end(), r) - lower_bound(f.begin(), f.end(), l);&#125;i64 ans;int main() &#123; fin &gt;&gt; n; ps[md(0)].pb(0); FOR(i, 1, n)&#123; fin &gt;&gt; a[i]; s[i] = a[i] ^ s[i - 1]; if(i != n) ps[md(s[i])].pb(i); &#125; // for(PII x: mp) ps[x.sc].pb(n + 1); // FOR(i, 0, n - 1) printf("%d%c", s[i], " \n"[i == ed_i]); vector&lt;PII&gt; B; FOR(i, 1, n)&#123; const int v = a[i]; vector&lt;PII&gt; C; for(PII x: B)&#123; if(C.empty() || (x.sc &amp; v) != C.back().sc) C.pb(MP(x.fr, x.sc &amp; v)); &#125; ++ans; int r = i; ROF(j, (int)C.size() - 1, 0)&#123; ans += count(C[j].fr - 1, r - 1, C[j].sc ^ s[i]); // printf("count(%d, %d, %d): %d\n", // C[j].fr - 1, r - 1, C[j].sc ^ s[i], // count(C[j].fr - 1, r - 1, C[j].sc ^ s[i])); r = C[j].fr; &#125; // for(PII x: C) // printf("%d %d\n", x.fr, x.sc); // puts("-----"); if(C.empty() || (a[i] != C.back().sc)) C.pb(MP(i, v)); B = C; &#125; FILE *fo(fopen("hack.out", "w")); fprintf(fo, "%lld\n", ans); fclose(fo); return 0;&#125; I - Interactive Interception题意简述交互题。有一辆小车，开始在 $[0, p]$ 中的一个整点，小车有一个向右的整数的速度 $q\in [0, v]$，当然你是不知道的。每次你可以问小车在不在 $[L, R]$ 里，问完小车会向右移动 $q$。请用至多 $100$ 次询问求出小车某一时刻的位置。$p,v\le 10^5$。 主要思路可能的情况在二维平面的矩形里，一次询问相当于用一条定斜率的直线去切它。由于座标范围比较小，可以直接存储每个横坐标对应哪些纵坐标还可能是答案，然后询问的时候二分询问点，使得把剩下的点切成尽可能均匀的两部分。 然后感觉挺宽的，跑不满。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define N 100inline bool query(const int &amp;l, const int &amp;r)&#123; printf("check %d %d\n", l, r), fflush(stdout); static char s[8]; scanf("%s", s); return *s == 'Y';&#125;int lp, rp, lv, rv;int l[N], r[N];int main() &#123; scanf("%d%d", &amp;rp, &amp;rv); int t = 0, dp; while(lp &lt; rp)&#123; dp = (lp + rp) &gt;&gt; 1; if(query(lp, dp)) rp = dp; else lp = dp + 1; FOR(i, 0, t - 1)&#123; chkmin(rv, (rp - l[i]) / (t - i)); chkmax(lv, (lp - r[i]) / (t - i)); &#125; l[t] = lp, r[t] = rp; lp += lv, rp += rv; ++t; &#125; printf("answer %d\n", lp); return 0;&#125; K - Kabaleo Lite题意简述桌上有 $n$ 堆筹码，堆顶颜色分别为 $b_i$；$p$ 个玩家，你是第一个，每人手上分别有一个颜色为 $l_i$ 的筹码。所有玩家依次将自己的筹码放到某堆的堆顶，最后统计占据最多筹码堆堆顶的颜色，称其为胜利颜色。你有一个目标颜色 $h$，并希望自己的目标颜色无论如何为胜利颜色。问你能够把自己手上的筹码放到哪些堆上，使得满足条件。颜色数 $c, n, p\le 10^6$。 主要思路显然最坏情况是所有人都来把覆盖你的颜色的筹码。于是就是个大讨论。 我感觉写得也非常不清真。总之过了就行。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define FORit(templ, arr, i, a, b) for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b) + 1; i != ed_##i; ++i)#define ROFit(templ, arr, i, a, b) for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b) - 1; i != ed_##i; --i)#define GO(x, p, e, i, v) for (register int i = p[x].head, v; i; i = e[i].link)#define MEM(x, v) memset(x, v, sizeof(x))typedef long long i64;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;#define pb push_back#define fr first#define sc second#define pq priority_queue#define MP make_pair#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define MMR (1 &lt;&lt; 24)struct INPUT&#123; FILE *F; char buf[MMR], *s, *t; INPUT(): F(fopen("kabaleo.in", "r"))&#123; t = (s = buf) + fread(buf, 1, MMR, F); fclose(F); &#125; Templ(_Tp) inline INPUT&amp; operator &gt;&gt;(_Tp &amp;x)&#123; x = 0; reg char c(*s++); while(!isdigit(c)) c = *s++; while(isdigit(c)) x = x * 10 + c - 48, c = *s++; return *this; &#125;&#125;fin;struct OUTPUT&#123; FILE *F; char buf[MMR], *s; OUTPUT(): F(fopen("kabaleo.out", "w"))&#123; s = buf; &#125; inline OUTPUT&amp; operator &lt;&lt;(int x)&#123; static int tmp[23]; Rint *top = tmp; if(x &lt; 0) x = -x, *s++ = '-'; do&#123; *++top = (x % 10) ^ 48, x /= 10; &#125;while(x); while(top != tmp) *s++ = *top--; *s++ = 10; return *this; &#125; ~OUTPUT()&#123; fwrite(buf, 1, s - buf, F); fclose(F); &#125;&#125;fout;#define N 1000010using I = int[N];int n, m, C, H;I a, c, f, q;inline int gg()&#123; return fout &lt;&lt; 0, 0;&#125;inline bool all_H()&#123; FOR(i, 1, n) if(a[i] != H) return 0; return 1;&#125;int main() &#123; fin &gt;&gt; n &gt;&gt; m &gt;&gt; C &gt;&gt; H; FOR(i, 1, n) fin &gt;&gt; a[i], ++f[a[i]]; FOR(i, 1, m) fin &gt;&gt; c[i]; if(n == 1)&#123; c[m] == H ? fout &lt;&lt; 1 &lt;&lt; 1 : fout &lt;&lt; 0; return 0; &#125; if(all_H())&#123; --f[H], ++f[c[1]]; FOR(i, 2, m)&#123; if(!f[H]) return gg(); --f[H], ++f[c[i]]; &#125; FOR(i, 1, C) if(i != H &amp;&amp; f[i] &gt;= f[H]) return gg(); fout &lt;&lt; n; FOR(i, 1, n) fout &lt;&lt; i; return 0; &#125; ++f[c[1]]; FOR(i, 2, m)&#123; if(!f[H]) return gg(); --f[H], ++f[c[i]]; &#125; int smF = -1, onH = 1; FOR(i, 1, C) if(i != H)&#123; if(f[i] == f[H])&#123; if(smF != -1) return gg(); smF = i; &#125; else if(f[i] &gt; f[H]) return gg(); else if(f[i] == f[H] - 1) onH = 0; &#125; if(smF == -1)&#123; FOR(i, 1, C)&#123; if(i != H || onH) q[i] = 1; &#125; &#125; else q[smF] = 1; Rint cnt = 0; FOR(i, 1, n) if(q[a[i]]) ++cnt; fout &lt;&lt; cnt; FOR(i, 1, n) if(q[a[i]]) fout &lt;&lt; i; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>GYM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NEERC 2016 选做]]></title>
    <url>%2Fblog%2FGYM101190%2F</url>
    <content type="text"><![CDATA[Q：弟啊你 NEERC 2015 咋还没做完呢A：咕了（指太菜看不懂题解） 2016-2017 ACM-ICPC Northeastern European Regional Contest (NEERC 16) B - Binary Code C - Cactus Construction D - Delight for a Cat G - Game on Graph I - Indiana Jones and the Uniform Cave K - Kids Designing Kids L - List of Primes M - Mole Tunnels C - Cactus Construction题意简述给定一棵仙人掌（$n\le 5\times 10^5$），你需要构造它。初始时，每个点颜色都为1，每个点都是仅有一个点的子图。你有三种操作： $join(u, v)$：把子图 $v$ 合并进子图 $u$。 $connect(u, a, b)$：把子图 $u$ 中颜色为 $a$ 的所有点与颜色为 $b$ 的所有点连边。注意若原本存在颜色 $a$ 的点与颜色 $b$ 的点之间有边，会连出重边，然而众所周知仙人掌是没有重边的，所以要避免这种情况。 $recolor(u, a, b)$：把子图 $u$ 中颜色为 $a$ 的所有点改为颜色 $b$。 假设你的操作数量是 $m$，操作间出现过的颜色数量是 $c$，那么你需要保证 $m\le 10^6, c\le 4$。 主要思路考虑树怎么做。从下往上合并，保证子树内只有根的颜色是 $2$，其他都是 $1$。合并一个儿子的时候把儿子改成颜色 $3$，合并连上后，再把颜色 $3$ 改成 $1$。考虑环怎么做。我们选定一个「根」，那么剩下的部分就是一条链。我们把链头染成颜色 $2$，在接入下一个点时选择一个链上当前未出现的颜色 $c$，把新接入的点染成该色，再把另一色的原本的链尾和新接入的点连边，再把原本的链尾改成颜色 $1$。整条链做完后，把链尾染成颜色 $2$，用类似合并儿子的方法接入「根」即可。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;#define SZ(x) ((int)x.size())#define pb emplace_back#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define MMR (1 &lt;&lt; 23)struct INPUT&#123; FILE *F; char buf[MMR], *s, *t; INPUT(): F(fopen("cactus.in", "r"))&#123; t = (s = buf) + fread(buf, 1, MMR, F); fclose(F); &#125; Templ(_Tp) inline INPUT&amp; operator &gt;&gt;(_Tp &amp;x)&#123; x = 0; reg char c(*s++); while(c &lt; 48) c = *s++; while(c &gt; 47) x = x * 10 + c - 48, c = *s++; return *this; &#125;&#125;fin;struct OUTPUT&#123; FILE *F; char buf[MMR], *s; OUTPUT(): F(fopen("cactus.out", "w"))&#123; s = buf; &#125; inline OUTPUT&amp; operator &lt;&lt;(int x)&#123; static int tmp[10]; Rint *top = tmp; do&#123; *++top = (x % 10) ^ 48, x /= 10; &#125;while(x); while(top != tmp) *s++ = *top--; return *this; &#125; inline OUTPUT&amp; operator &lt;&lt;(char x)&#123; *s++ = x; return *this; &#125; ~OUTPUT()&#123; fwrite(buf, 1, s - buf, F); fclose(F); &#125;&#125;fout;struct qry&#123; int t, a, b, c; inline qry(int _t, int _a, int _b, int _c) : t(_t), a(_a), b(_b), c(_c)&#123;&#125;&#125;;vector&lt;qry&gt; ans;#define join(a, b) ans.pb(qry(0, a, b, 0))#define recolor(a, b, c) ans.pb(qry(1, a, b, c))#define connect(a, b, c) ans.pb(qry(2, a, b, c))inline void print_ans()&#123; fout &lt;&lt; SZ(ans) &lt;&lt; '\n'; for(reg qry x: ans)&#123; if(!x.t) fout &lt;&lt; 'j' &lt;&lt; ' ' &lt;&lt; x.a &lt;&lt; ' ' &lt;&lt; x.b &lt;&lt; '\n'; else fout &lt;&lt; "rc"[x.t - 1] &lt;&lt; ' ' &lt;&lt; x.a &lt;&lt; ' ' &lt;&lt; x.b &lt;&lt; ' ' &lt;&lt; x.c &lt;&lt; '\n'; &#125;&#125;#define N 100010int n, m;VI E[N], T[N];namespace Tarjan&#123;int dfn[N], low[N], pc, cc;int sk[N], *st(sk);void dfs(const int &amp;u)&#123; dfn[u] = low[u] = ++ pc; *++st = u; for(Rint v: E[u])&#123; if(!dfn[v])&#123; dfs(v), chkmin(low[u], low[v]); if(low[v] &gt;= dfn[u])&#123; ++cc, T[u].pb(cc); do&#123; T[cc].pb(*st); &#125;while(*st-- != v); &#125; &#125;else&#123; chkmin(low[u], dfn[v]); &#125; &#125;&#125;int main()&#123; cc = n; dfs(1); return 0;&#125;&#125;int id[N];void dfs(const int &amp;u)&#123; if(u &lt;= n)&#123; id[u] = u; recolor(u, 1, 2); for(Rint v: T[u])&#123; dfs(v); recolor(id[v], 2, 3); join(id[u], id[v]); connect(id[u], 2, 3); recolor(id[u], 3, 1); &#125; &#125;else&#123; if(SZ(T[u]) == 1)&#123; Rint v = T[u][0]; dfs(v), id[u] = id[v]; return; &#125; dfs(T[u][0]), id[u] = id[T[u][0]]; dfs(T[u][1]); recolor(id[T[u][1]], 2, 4); join(id[u], id[T[u][1]]); connect(id[u], 2, 4); Rint tl = 4, nc = 3; //tail color, next color for(Rint v: T[u]) if(!id[v])&#123; dfs(v); recolor(id[v], 2, nc); join(id[u], id[v]); connect(id[v], 3, 4); recolor(id[u], tl, 1); swap(tl, nc); &#125; recolor(id[u], tl, 2); &#125;&#125;int main() &#123; fin &gt;&gt; n &gt;&gt; m; FOR(i, 1, m)&#123; Rint k, u, v; fin &gt;&gt; k &gt;&gt; u; FOR(i, 1, k - 1)&#123; fin &gt;&gt; v; E[u].pb(v), E[v].pb(u); u = v; &#125; &#125; Tarjan::main(); dfs(1); print_ans(); return 0;&#125; G - Game on Graph题意简述一张有向图，两人0,1在玩游戏。游戏规则非常简单：图上有一棋子，两人轮流操作，每人每次将棋子沿当前位置的某条出边移动，不能动的人就输了。但是由于一些特殊原因，0最希望游戏永远不要停止；若无法达到，其也会尽可能追求赢。1最不希望游戏永远不停止；若可以使游戏停止，其宁愿输。现在请对于每个点作为棋子的开始点，每个人作为先手，求最后的状态是什么（赢/输/无法结束）。$n\le 10^5, m\le 2\times 10^5$。 主要思路设一个游戏状态为一个二元组 $(x, c)$ 表示当前棋子在点 $x$，此时操作的是 $c$。0若1无论如何操作都可以使游戏无法结束，他就会令游戏无法结束；否则1会阻止游戏无法结束。1若0无论如何操作都可以自己赢，那他会使自己赢；否则0会阻止1赢。而其余的情况，0会赢。 考虑清楚这一点之后，就可以设 $ending(x, c), winning(x, c)$ 分别表示 $(x, c)$ 状态能否结束、1能否赢。 考虑用反向 bfs 来求 $ending$。首先，显然对于所有没有出度的状态 $(x, c)$，它们均能结束。把这些状态全扔队列里。考虑 $(x, 1)$ 如何能够结束：只要它的下一个可能状态中有一个可以结束，它就能结束；而 $(x, 0)$ 要结束，必须要它的每一个下一个可能状态都可以结束。 同样用反向 bfs 来求 $winning$，可以发现转移方式完全一致。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;#define pb emplace_back#define fr first#define sc second#define MP make_pair#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define MMR (1 &lt;&lt; 23)struct INPUT&#123; FILE *F; char buf[MMR], *s, *t; INPUT(): F(fopen("game.in", "r"))&#123; t = (s = buf) + fread(buf, 1, MMR, F); fclose(F); &#125; Templ(_Tp) inline INPUT&amp; operator &gt;&gt;(_Tp &amp;x)&#123; x = 0; reg char c(*s++); while(c &lt; 48) c = *s++; while(c &gt; 47) x = x * 10 + c - 48, c = *s++; return *this; &#125;&#125;fin;struct OUTPUT&#123; FILE *F; char buf[MMR], *s; OUTPUT(): F(fopen("game.out", "w"))&#123; s = buf; &#125; inline OUTPUT&amp; operator &lt;&lt;(int x)&#123; static int tmp[10]; Rint *top = tmp; do&#123; *++top = (x % 10) ^ 48, x /= 10; &#125;while(x); while(top != tmp) *s++ = *top--; *s++ = 32; return *this; &#125; inline OUTPUT&amp; operator &lt;&lt;(char x)&#123; *s++ = x; return *this; &#125; ~OUTPUT()&#123; fwrite(buf, 1, s - buf, F); fclose(F); &#125;&#125;fout;//0: D - W - L//1: W - L - D#define N 100010int n, m;VI to[N], fm[N];//正向边 / 反向边int oud[N];inline void init()&#123; fin &gt;&gt; n &gt;&gt; m; Rint u, v; FOR(i, 1, m)&#123; fin &gt;&gt; u &gt;&gt; v; to[u].pb(v); fm[v].pb(u); &#125;&#125;queue&lt;PII&gt; Q;inline void work(bool (*f)[2])&#123; FOR(i, 1, n) oud[i] = to[i].size(); FOR(i, 1, n) FOR(c, 0, 1) if(f[i][c]) Q.push(MP(i, c)); while(!Q.empty())&#123; PII now = Q.front(); Q.pop(); Rint u = now.fr; if(now.sc)&#123; for(int v: fm[u]) if(!f[v][0] &amp;&amp; !--oud[v])&#123; f[v][0] = 1; Q.push(MP(v, 0)); &#125; &#125;else&#123; for(int v: fm[u]) if(!f[v][1])&#123; f[v][1] = 1; Q.push(MP(v, 1)); &#125; &#125; &#125;&#125;bool endable[N][2], winning[N][2];//endable[u][c]: 从 u 开始、c 先手时，1 是否能令其结束//winning[u][c]: 从 u 开始、c 先手时，1 能否胜出int main() &#123; init(); FOR(i, 1, n) if(to[i].empty()) endable[i][0] = endable[i][1] = winning[i][0] = 1; work(endable); work(winning); FOR(i, 1, n)&#123; if(!endable[i][0]) fout &lt;&lt; 'D'; else if(winning[i][0]) fout &lt;&lt; 'L'; else fout &lt;&lt; 'W'; &#125; fout &lt;&lt; '\n'; FOR(i, 1, n)&#123; if(winning[i][1]) fout &lt;&lt; 'W'; else if(endable[i][1]) fout &lt;&lt; 'L'; else fout &lt;&lt; 'D'; &#125; return 0;&#125; K - Kids Designing Kids题意简述给你三个01矩阵 $A, B, C$。问是否能够通过平移 $B$ 并与 $A$ 异或（并删去全为0的部分行列）获得 $C$。若是顺便输出 $B$ 的平移方法。$w, h\le 10^3$。 主要思路完全没思路，看了一眼题解。 Find the top-left freckle in each of three given pictures.We’ll prove that after moving the figures, some two of these three freckles must be in the same point. 大概就是说：三个最左上的1有两个移动后在同一位置。于是检验三种就可以了。被打傻了.jpg 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define N 2020const bool __file__ = [&amp;]()&#123; freopen("kids.in", "r", stdin); freopen("kids.out", "w", stdout); return true;&#125;();char buf[N];bool dt[N][N];#define T 1000struct G&#123; int X, Y; bool a[N][N]; inline G(const bool &amp;__empty__)&#123; if(__empty__)&#123; memset(a, 0, sizeof(a)); X = Y = 0; &#125; &#125; inline G()&#123; int n, m; scanf("%d%d", &amp;n, &amp;m); FOR(i, 1, n)&#123; scanf("%s", buf + 1); FOR(j, 1, m) if(buf[j] == '*')&#123; if(!X) X = -i, Y = -j; a[i + X + T][j + Y + T] = 1; &#125; &#125; &#125; inline void mv(int x, int y)&#123; X += x, Y += y; memcpy(dt, a, sizeof(dt)); FOR(i, 0, T * 2) FOR(j, 0, T * 2)&#123; if(i - x &lt; 0 || i - x &gt; T * 2 || j - y &lt; 0 || j - y &gt; T * 2) a[i][j] = 0; else a[i][j] = dt[i - x][j - y]; &#125; &#125;&#125;A, B, C;inline bool chk(const G &amp;a, const G &amp;b, G &amp;c)&#123; G t(true); int X = 0xffff, Y = 0xffff; FOR(i, 0, T * 2) FOR(j, 0, T * 2)&#123; t.a[i][j] = a.a[i][j] ^ b.a[i][j]; if(X == 0xffff &amp;&amp; t.a[i][j]) X = T - i, Y = T - j; &#125; if(X == 0xffff) X = Y = 0; t.mv(X, Y); FOR(i, 0, T * 2) FOR(j, 0, T * 2)&#123; if(t.a[i][j] != c.a[i][j]) return false; &#125; c.X -= X, c.Y -= Y; return true;&#125;const bool __main__ = [&amp;]()&#123; if(chk(A, B, C) || chk(B, C, A) || chk(C, A, B)) printf("YES\n%d %d\n", B.Y - A.Y, B.X - A.X); else puts("NO"); return true;&#125;();int main() &#123; return 0;&#125; L - List of Primes题意简述现在有无穷个（不可重）集合，每个集合中全都是质数。把它们先按照元素总和、再按照字典序排序。每个集合输出，集合开始先输出[，集合结束输出]，无论两个元素还是两个集合之间都要用,连接。则会形成一个无限长的字符串，下列为前70个字符。 1[2], [3], [2, 3], [5], [2, 5], [7], [3, 5], [2, 7], [2, 3, 5], [3, 7], 求第 $l$ 到第 $r$ 个字符，$l,r\le 10^{18}, r - l\le 10^5$。 主要思路猜想集合的和不会太大（事实证明是2099）。于是直接类似背包地 dp 一下即可。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;typedef long long i64;#define FORit(i, a, b) for (auto *i = (a), *ed_##i = (b); i != ed_##i; ++i)&#125; // namespace my_stdusing namespace my_std;#define MMR (1 &lt;&lt; 18)struct OUTPUT&#123; FILE *F; char buf[MMR], *s; OUTPUT(): F(fopen("list.out", "w")), s(buf)&#123;&#125; inline OUTPUT&amp; operator &lt;&lt;(const char &amp;x)&#123; *s++ = x; return *this; &#125; ~OUTPUT()&#123; fwrite(buf, 1, s - buf, F), fclose(F); &#125;&#125;fo;#define N 330#define M 2100int pr[N], pc;int len[N];int m0[10];inline void init_p()&#123; static bool b[M + 20]; FOR(i, 2, M)&#123; if(!b[i]) pr[++pc] = i; for(Rint j(1); i * pr[j] &lt;= M &amp;&amp; j &lt;= pc; ++j)&#123; b[i * pr[j]] = 1; &#125; &#125; m0[0] = 1; FOR(i, 1, 9) m0[i] = m0[i - 1] * 10; FOR(i, 1, pc)&#123; len[i] = 2; FOR(o, 0, 5) len[i] += m0[o] &lt;= pr[i]; &#125; // FOR(i, 1, pc) fo &lt;&lt; pr[i] &lt;&lt; " " &lt;&lt; i &lt;&lt; "\n";&#125;i64 cnt[N][M + 10], sum[N][M + 10];//(i, S): 目前集合中不小于 pr[i] 的数和为 Sinline void init_f()&#123; ROF(i, pc, 1)&#123; const int P = pr[i]; cnt[i][0] = 1, sum[i][0] = 2; // FOR(j, 1, P - 1)&#123; // cnt[i][j] = cnt[i + 1][j]; // sum[i][j] = sum[i + 1][j]; // &#125; FOR(j, P, M)&#123; cnt[i][j] = cnt[i + 1][j - P] + cnt[i + 1][j]; sum[i][j] = sum[i + 1][j - P] + sum[i + 1][j] + cnt[i + 1][j - P] * len[i]; &#125; &#125;&#125;i64 L, R, T;int sk[N], st, slen;#define pcr(x) \ ++T, L &lt;= T &amp;&amp; T &lt;= R &amp;&amp; \ (fo &lt;&lt; char(x), 1)// inline void pcr(char x)&#123;// ++T, L &lt;= T &amp;&amp; T &lt;= R &amp;&amp;// (fo &lt;&lt; x, 1);// &#125;inline void write(int x)&#123; static int tmp[20]; Rint *top = tmp; do&#123; *++top = (x % 10) ^ 48, x /= 10; &#125;while(x); while(top != tmp) pcr(*top), --top;&#125;void work(const int &amp;K, const int &amp;S)&#123; const int P = pr[K]; // printf("work(%d, %d): %d\n", K, S, T); if(S &lt; 0 || T &gt; R) return; if(S == 0)&#123; pcr('['); FOR(i, 1, st - 1)&#123; write(sk[i]); pcr(','), pcr(' '); &#125; if(st &gt; 0)&#123; write(sk[st]); pcr(']'), pcr(','), pcr(' '); &#125; return; &#125; if(S &lt; P) return; reg i64 res; sk[++st] = P; slen += len[K]; res = slen * cnt[K + 1][S - P] + sum[K + 1][S - P]; // printf("res: %lld\n", res); if(T + res &lt; L) T += res; else work(K + 1, S - P); sk[st--] = 0; slen -= len[K]; res = slen * cnt[K + 1][S] + sum[K + 1][S]; if(T + res &lt; L) T += res; else work(K + 1, S);&#125;int main() &#123; FILE *fi = fopen("list.in", "r"); fscanf(fi, "%lld%lld", &amp;L, &amp;R); fclose(fi); init_p(); init_f(); FOR(S, 2, M)&#123; if(T &gt; R) break; i64 res = sum[1][S]; if(T + res &lt; L) T += res; else work(1, S); if(T &gt; R) break; &#125; return 0;&#125; M - Mole Tunnels题意简述有一棵 $1$ 为根 $n$ 个点边全为 $(i, \lfloor\frac{i}{2}\rfloor)$ 的树。树上每个点有食物 $c_i$。有 $m$ 只鼹鼠，分别在点 $p_i$。对于每个 $k\le m$ 求：若前 $k$ 只鼹鼠都去找一个食物（即点 $x$ 不能有超过 $c_x$ 只鼹鼠），鼹鼠的总路程最小是多少。$n, m\le 10^5$，保证食物够。 主要思路 某人表示：这不是经典题吗我一看，Luogu 6122怎么做啊，自闭了。 首先有个简单的费用流思路： 总路径长度：所有树边流量为正无穷，费用为 $1$。 鼹鼠的终点要有食物：相当于 $i$ 向汇点连一条流量为 $c_i$ 费用为 $0$ 的边。 进入一只鼹鼠：相当于源点向 $p_i$ 连一条流量为 $1$ 费用为 $0$ 的边。 考虑费用流的过程。新加入一只鼹鼠时，设其出发点为 $u$，到达的点为 $v$，则我们会在 $u$ 到 $v$ 的路径经过的每条边上建一条费用为 $-1$ 流量为 $1$ 的反向边。而对 $v$ 的选择，其实就是选使得 $u\to v$ 路径上总费用最小（且 $v$ 到汇点的边未流满）的点 $v$。 注意到二叉树的树高为 $O(\log n)$，所以可以暴力枚举 $u$ 的所有祖先 $a$。对每个节点 $a$，维护 $a$ 子树内使得 $a\to v$ 路径上总费用最小（且 $v$ 到汇点的边未流满）的点 $v$，记为 $pos(a) = v$。对于所有祖先 $a$，取 $pos(a)$ 中最优的一个，作为真实的 $v$。然后在 $u\to v$ 的路径上添加反向边，并更新 $u, v$ 及其所有祖先的 $pos$ 即可。 $O(n\log n)$。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;#define pb push_back#define fr first#define sc second#define pq priority_queue#define MP make_pair#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define MMR (1 &lt;&lt; 23)struct INPUT&#123; FILE *F; char buf[MMR], *s, *t; INPUT(): F(fopen("mole.in", "r"))&#123; t = (s = buf) + fread(buf, 1, MMR, F); fclose(F); &#125; Templ(_Tp) inline INPUT&amp; operator &gt;&gt;(_Tp &amp;x)&#123; x = 0; reg char c(*s++); while(c &lt; 48) c = *s++; while(c &gt; 47) x = x * 10 + c - 48, c = *s++; return *this; &#125;&#125;fin;struct OUTPUT&#123; FILE *F; char buf[MMR], *s; OUTPUT(): F(fopen("mole.out", "w"))&#123; s = buf; &#125; inline OUTPUT&amp; operator &lt;&lt;(int x)&#123; static int tmp[10]; Rint *top = tmp; do&#123; *++top = (x % 10) ^ 48, x /= 10; &#125;while(x); while(top != tmp) *s++ = *top--; *s++ = 32; return *this; &#125; ~OUTPUT()&#123; fwrite(buf, 1, s - buf, F); fclose(F); &#125;&#125;fout;#define inf 0777777#define N 100010int n, m;int c[N];int f[N], p[N];int up[N], dn[N];#define lc ((t) &lt;&lt; 1)#define rc ((t) &lt;&lt; 1 | 1)#define fa ((t) &gt;&gt; 1)int ans;inline void upd(const int &amp;t)&#123; f[t] = inf; if(lc &lt;= n &amp;&amp; chkmin(f[t], f[lc] + (dn[lc] ? -1 : 1))) p[t] = p[lc]; if(rc &lt;= n &amp;&amp; chkmin(f[t], f[rc] + (dn[rc] ? -1 : 1))) p[t] = p[rc];&#125;inline void work(const int &amp;u)&#123; Rint res = inf, w = 0, v = 0; for(Rint t = u, k = 0; t; t = fa)&#123; if(chkmin(res, f[t] + k)) w = t, v = p[t]; if(fa) k += up[t] ? -1 : 1; &#125; --c[v]; fout &lt;&lt; (ans += res); for(Rint t = u; t != w; t = fa)&#123; if(up[t]) --up[t]; else ++dn[t]; if(c[t]) f[t] = 0, p[t] = t; else upd(t); &#125; for(Rint t = v; t != w; t = fa)&#123; if(dn[t]) --dn[t]; else ++up[t]; if(c[t]) f[t] = 0, p[t] = t; else upd(t); &#125; for(Rint t = w; t; t = fa)&#123; if(c[t]) f[t] = 0, p[t] = t; else upd(t); &#125;&#125;int main() &#123; fin &gt;&gt; n &gt;&gt; m; FOR(i, 1, n) fin &gt;&gt; c[i]; FOR(i, 1, n) f[i] = inf; ROF(t, n, 1)&#123; if(c[t]) f[t] = 0, p[t] = t; if(fa &amp;&amp; chkmin(f[fa], f[t] + 1)) p[fa] = p[t]; &#125; Rint x; FOR(i, 1, m) work((fin &gt;&gt; x, x)); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>GYM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NEERC 2015 选做]]></title>
    <url>%2Fblog%2FGYM100851%2F</url>
    <content type="text"><![CDATA[集训队作业开冲。2015-2016 ACM-ICPC Northeastern European Regional Contest (NEERC 15) B - Binary vs Decimal C - Cactus Jubilee D - Distance on Triangulation H - Hypercube I - Iceberg Orders J - Jump K - King’s Inspection L - Landscape Improved B - Binary vs Decimal题意简述求第 $n$ 小的正整数 $A$ 满足： $A$ 中仅含0,1。 设 $A$ 的二进制表示为 $B$，则 $A$ 为 $B$ 的后缀。 $n\le 10000$。 主要思路我会暴力判断！ 123456789101112131415161718192021222324252627282930def check(i): x = int(bin(i)[2:]) xbs = str(bin(x)[2:]) x = str(x) y = xbs[-len(x):] if x == y: return True return Falsefin = open("binary.in", "r")rd = int(fin.read())fin.close()Q = [0, 1]lim = 1while len(Q) &lt;= rd: lim *= 2 P = [] for x in Q: y = x + lim if check(y): P.append(y) Q += P# for x in Q:# print(x, end = ', ')fout = open("binary.out", "w")fout.write(bin(Q[rd])[2:])fout.close() 然而显然这样是过不去的。打了个表，好像也没啥性质。 后来发现如果 $A$ 合法，则 $A$ 的任意一个后缀都合法。于是写个高精 bfs 就好了。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;typedef unsigned long long u64;typedef unsigned int u32;#define BM 4struct BigNum&#123; u64 a[BM]; inline void reset()&#123; FOR(i, 0, BM - 1) a[i] = 0; &#125; inline void set()&#123; FOR(i, 0, BM - 1) a[i] = ~0ull; &#125; inline BigNum()&#123; reset(); &#125; inline void reset(const int &amp;x)&#123; a[x &gt;&gt; 6] &amp;= ~(1ull &lt;&lt; (x &amp; 63)); &#125; inline void set(const int &amp;x)&#123; a[x &gt;&gt; 6] |= 1ull &lt;&lt; (x &amp; 63); &#125; inline bool test(const int &amp;x)const&#123; return (a[x &gt;&gt; 6] &gt;&gt; (x &amp; 63)) &amp; 1; &#125; inline BigNum operator &lt;&lt;(const int &amp;x)const&#123;//x must be in [0, 64) reg BigNum res; reg u64 t = 0; FOR(i, 0, BM - 1)&#123; res.a[i] = (a[i] &lt;&lt; x) | t; t = a[i] &gt;&gt; (64 - x); &#125; return res; &#125; inline BigNum operator +(const BigNum &amp;rhs)const&#123; reg BigNum res; reg bool t = 0; FOR(i, 0, BM - 1)&#123; if(t)&#123; res.a[i] = a[i] + rhs.a[i] + 1; if(a[i] &lt; ~0ull - rhs.a[i]) t = 0; else t = 1; &#125;else&#123; res.a[i] = a[i] + rhs.a[i]; if(a[i] &lt;= ~0ull - rhs.a[i]) t = 0; else t = 1; &#125; &#125; return res; &#125;&#125;m10[256], Q[16384], P[16384];int qt = 1;inline void print(const BigNum &amp;x)&#123; Rint t = 255; for(; !x.test(t); --t); for(; ~t; --t) putchar(int(x.test(t)) ^ 48); putchar(10);&#125;inline bool check(const BigNum &amp;x, const BigNum &amp;y)&#123; Rint t = 255; for(; !x.test(t); --t); for(; ~t; --t) if(x.test(t) ^ y.test(t)) return 0; return 1;&#125;int main() &#123; freopen("binary.in", "r", stdin); freopen("binary.out", "w", stdout); m10[0].set(0); FOR(i, 1, 255) m10[i] = (m10[i - 1] &lt;&lt; 3) + (m10[i - 1] &lt;&lt; 1); int n; scanf("%d", &amp;n); Q[1].set(0); P[1].set(0); Rint lim = 0; while(qt &lt;= n)&#123; ++lim; FOR(i, 0, qt)&#123; reg BigNum x = Q[i], y = P[i]; x.set(lim); y = y + m10[lim]; if(check(x, y))&#123; Q[++qt] = x; P[qt] = y; &#125; &#125; &#125; print(Q[n]); // FOR(i, 1, n) print(Q[i]); return 0;&#125; H - Hypercube题意简述给三位空间上 $8$ 个单位正方体，判断它们能否折叠成一个四维超立方体。 主要思路被教育了一个非常 nb 的做法。四维无法想象，故先考虑把 $6$ 个小正方体折成三维立方体。 那么折成的小立方体，从某一面开始，无论沿着哪个方向走 $2$ 步就能走到其对面，再走 $2$ 步就能走回来。考虑到实际上只有两个方向，那么不妨考虑一个面 $c$（其对面记为 $-c$）与两个映射 $f_{x, y}$，$f_i(c)$ 意为在方向 $i$ 上走一步走到的面。那么我们有 $f_x^2(c) = f_y^2(c) = -c$。考虑在平面上也只有两个方向，故对于两个面 $c, d$，钦定 $c$ 是折起来后的哪一面，按照 $c\to d$ 经过的路径不断映射就能得到 $d$ 是哪一面。对于所有 $(c, d)$ 计算出 $d$ 是哪一面，当有一组 $(c, d)$ 对应的面相同，则可充分说明无解。其必要性不难证明。 那么关于这两个映射如何设。可以构造如下的映射，其中元组的前两维代表到该面的方向，最后一维代表是在哪一面。即两个元素相等只需最后一维相等即可。 $$f_x(A, B, C) = (-C, B, A)\\f_y(A, B, C) = (A, -C, B)$$ 那么回到四维的情况，就类似地需要有三个方向的映射。 $$f_x(A, B, C, D) = (-D, B, C, A)\\f_y(A, B, C, D) = (A, -D, C, B)\\f_z(A, B, C, D) = (A, B, -D, C)$$ 即可。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef int I;&#125; // namespace my_stdusing namespace my_std;#define N 10FILE *fo;I n, m, k;char s[N][N][N];inline void init()&#123; freopen("hypercube.in", "r", stdin); fo = fopen("hypercube.out", "w"); scanf("%d%d%d", &amp;n, &amp;m, &amp;k); FOR(i, 1, k) FOR(j, 1, m)&#123; scanf("%s", s[i][j] + 1); &#125;&#125;map&lt;I, bool&gt; vis;void dfs(I x, I y, I z, I A, I B, I C, I D)&#123; s[x][y][z] = 32; if(!vis.count(D)) vis[D] = 1; if(s[x + 1][y][z] == 0x78) dfs(x + 1, y, z, -D, B, C, A); if(s[x - 1][y][z] == 0x78) dfs(x - 1, y, z, D, B, C, -A); if(s[x][y + 1][z] == 0x78) dfs(x, y + 1, z, A, -D, C, B); if(s[x][y - 1][z] == 0x78) dfs(x, y - 1, z, A, D, C, -B); if(s[x][y][z + 1] == 0x78) dfs(x, y, z + 1, A, B, -D, C); if(s[x][y][z - 1] == 0x78) dfs(x, y, z - 1, A, B, D, -C);&#125;I main() &#123; init(); FOR(i, 1, k) FOR(j, 1, m) FOR(o, 1, n) if(s[i][j][o] == 0x78) dfs(i, j, o, 1, 2, 3, 4); return fputs((int)vis.size() == 8 ? "Yes" : "No", fo), fclose(fo), 0;&#125; 顺带一提，这个 sb 开始写了个极为复杂的实现，然后又被教育了，，， J - Jump题意简述交互题，猜01串 $S$，$|S| = n$ 为偶数。每次可以猜一个串 $T$，若 $S,T$ 的 $n$ 位全都相等则结束。否则，若两串恰好有 $n/2$ 位相等，返回 $n/2$；否则返回 $0$。请在 $n + 500$ 次内猜出 $S$，$n\le 1000$。 主要思路随机一个串使得恰有 $n/2$ 位相等，据说大概 $\sqrt{n}$ 次左右就能得到一个。然后对于相邻两位 $i, i + 1$，将他们均取反，查一次，可以知道 $s_i\omega s_{i+1}$。于是再来两次查询第一个位的值即可。 参考代码 12345678910111213141516171819202122232425262728import randomn = int(input())def check(s): print(*s, sep = '') x = int(input()) if x == n: exit() else: return x == n//2while True: s = random.choices([0, 1], k = n) if check(s): breakd = []s[0] ^= 1for i in range(1, n): s[i] ^= 1 d.append(check(s) ^ s[i] ^ s[0]) s[i] ^= 1s[0] ^= 1s = [0]for i in d: s.append(i)check(s)check([i ^ 1 for i in s]) K - King’s Inspection题意简述有向图保证 $m\le n + 20, n\le 10^5$，求一条哈密顿回路，需判断无解。 主要思路首先对于一些只有一条入边 $(v, u)$ 的点 $u$，很明显我们可以知道回路中只能 $v\to u$。那么最后就可以压成 $O(m - n)$ 条链，这些链必须从链头走向链尾。那么枚举一下这些链之间的顺序就好了。复杂度是多少啊（/yun） 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;typedef vector&lt;int&gt; VI;#define pb emplace_back&#125; // namespace my_stdusing namespace my_std;#define MMR (1 &lt;&lt; 23)struct INPUT&#123; FILE *F; char buf[MMR], *s, *t; INPUT(): F(fopen("king.in", "r"))&#123; t = (s = buf) + fread(buf, 1, MMR, F); fclose(F); &#125; Templ(_Tp) inline INPUT&amp; operator &gt;&gt;(_Tp &amp;x)&#123; x = 0; reg char c(*s++); while(c &lt; 48) c = *s++; while(c &gt; 47) x = x * 10 + c - 48, c = *s++; return *this; &#125;&#125;fin;FILE *fout(fopen("king.out", "w"));#define EX() fclose(fout), exit(0);#define N 100010int n, m;int suf[N], pre[N], vis[N];int col[N], cc;VI fr[N];inline bool fail()&#123; fputs("There is no route, Karl!", fout); EX(); return 1;&#125;inline void travel()&#123; Rint u = 1; do&#123; fprintf(fout, "%d ", u); u = suf[u]; &#125;while(u != 1); fprintf(fout, "%d\n", u); EX();&#125;//small graphnamespace SG&#123;int hd[N], tl[N];#define M 30int suf[M], pre[M];int vis[M];VI e[M];inline void check()&#123; memset(vis, 0, sizeof(int) * M); Rint u = 1; for(; !vis[u]; u = suf[u]) vis[u] = 1; FOR(i, 1, cc) if(!vis[i]) return; FOR(i, 1, cc)&#123; ::suf[tl[i]] = hd[suf[i]]; &#125; travel();&#125;void dfs(const int &amp;u)&#123; if(u &gt; cc) return check(); for(Rint v: e[u]) if(!pre[v])&#123; suf[u] = v, pre[v] = u; dfs(u + 1); suf[u] = 0, pre[v] = 0; &#125;&#125;void solve()&#123; FOR(u, 1, n) if(!::pre[u])&#123; for(Rint v: fr[u]) if(!::suf[v])&#123; e[col[v]].pb(col[u]); &#125; &#125; dfs(1);&#125;#undef M&#125;void dfs(const int &amp;u)&#123; col[u] = cc; vis[u] = 1; if(suf[u] &amp;&amp; !vis[suf[u]]) dfs(suf[u]); else SG::tl[cc] = u;&#125;int main() &#123; fin &gt;&gt; n &gt;&gt; m; Rint u, v; FOR(i, 1, m)&#123; fin &gt;&gt; u &gt;&gt; v; fr[v].pb(u); &#125; FOR(u, 1, n)&#123; if(fr[u].size() == 1)&#123; Rint v = fr[u][0]; suf[v] &amp;&amp; fail(); suf[v] = u; pre[u] = v; &#125;else fr[u].empty() &amp;&amp; fail(); &#125; FOR(u, 1, n) if(!pre[u])&#123; SG::hd[++cc] = u; dfs(u); &#125; if(!vis[1])&#123; ++cc; dfs(1); FOR(i, 1, n) col[i] != cc &amp;&amp; fail(); travel(); &#125; FOR(u, 2, n) !vis[u] &amp;&amp; fail(); SG::solve(); fail(); return 0;&#125; L - Landscape Improved题意简述二维搭积木，第 $i$ 列上已经搭了 $h_i$ 块。共 $n$ 个位置。现在你手上有 $W$ 块积木，手上的积木能搭在某个位置当且仅当该位置左下、正下、右下三个位置都已经有积木。求最高的一列能搭多高。$n\le 10^5, h_i\le 10^9, W\le 10^{18}$。 12345 . # ..### ##.#### ############ 以上是一个 $n=8,W=4$ 的样例，其中以#表示原先有的积木，.表示后来放上去的积木。 主要思路枚举一下第 $p$ 列最高，然后二分一下高度 $lim$。 那么大概就是什么找到最大的 $i&lt;p$ 使得 $h_i + p - i \ge lim$，然后求一下区间 $(i, p)$ 的和。对于左边也类似。这个显然可以转成什么 $O(n)$ 次区间加减一。求那个东西就把 $log n$ 个线段树上的区间捞下来，然后找到第一个最大值不小于 $lim$ 的区间，再套个线段树上二分啥的就好了。 参考代码写完之后发现不优美，实际上有许多更优美的做法（例如直接来个 ST表和树状数组）。虽然复杂度都是 $O(n\log^2 n)$ 啦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;typedef long long i64;&#125; // namespace my_stdusing namespace my_std;#define MMR (1 &lt;&lt; 23)struct INPUT&#123; FILE *F; char buf[MMR], *s, *t; INPUT(): F(fopen("landscape.in", "r"))&#123; t = (s = buf) + fread(buf, 1, MMR, F); fclose(F); &#125; Templ(_Tp) inline INPUT&amp; operator &gt;&gt;(_Tp &amp;x)&#123; x = 0; reg char c(*s++); while(c &lt; 48) c = *s++; while(c &gt; 47) x = x * 10 + c - 48, c = *s++; return *this; &#125;&#125;fin;struct OUTPUT&#123; FILE *F; char buf[MMR], *s; OUTPUT(): F(fopen("landscape.out", "w"))&#123; s = buf; &#125; inline OUTPUT&amp; operator &lt;&lt;(int x)&#123; static int tmp[10]; Rint *top = tmp; do&#123; *++top = (x % 10) ^ 48, x /= 10; &#125;while(x); while(top != tmp) *s++ = *top--; *s++ = 10; return *this; &#125; ~OUTPUT()&#123; fwrite(buf, 1, s - buf, F); fclose(F); &#125;&#125;fout;#define N 100010int n, a[N];i64 K;namespace DS&#123;#define lc ((t) &lt;&lt; 1)#define rc ((t) &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)typedef const int CI;typedef const i64 CI64;int m[N &lt;&lt; 2], d[N &lt;&lt; 2];int L[N &lt;&lt; 2], R[N &lt;&lt; 2];i64 s[N &lt;&lt; 2];inline void push_up(CI &amp;t)&#123; s[t] = s[lc] + s[rc]; m[t] = max(m[lc], m[rc]);&#125;inline void push_down(CI &amp;t, CI &amp;len)&#123; if(d[t] != 0)&#123; CI tag = d[t]; d[t] = 0; s[lc] += ((len + 1ll) &gt;&gt; 1) * tag; s[rc] += ((i64)len &gt;&gt; 1) * tag; m[lc] += tag; m[rc] += tag; d[lc] += tag; d[rc] += tag; &#125;&#125;void build(CI &amp;t, CI &amp;l, CI &amp;r)&#123; L[t] = l, R[t] = r; if(l == r)&#123; s[t] = a[l] + l - 1; m[t] = a[l] + l - 1; d[t] = 0; return; &#125; build(lc, l, mid), build(rc, mid + 1, r); push_up(t);&#125;void update(CI &amp;t, CI &amp;L, CI &amp;R, CI &amp;v)&#123; CI l = DS::L[t], r = DS::R[t]; if(L &lt;= l &amp;&amp; r &lt;= R)&#123; s[t] += (i64)(r - l + 1) * v; m[t] += v; d[t] += v; return; &#125; push_down(t, r - l + 1); if(L &lt;= mid) update(lc, L, R, v); if(R &gt; mid) update(rc, L, R, v); push_up(t);&#125;int sk[64], *st;void get_L(CI &amp;t, CI &amp;x)&#123; CI l = DS::L[t], r = DS::R[t]; if(r &lt; x)&#123; *++st = t; return; &#125; if(l == r) return; push_down(t, r - l + 1); get_L(lc, x); if(mid + 1 &lt; x) get_L(rc, x);&#125;void get_R(CI &amp;t, CI &amp;x)&#123; CI l = DS::L[t], r = DS::R[t]; if(l &gt; x)&#123; *++st = t; return; &#125; push_down(t, r - l + 1); get_R(rc, x); if(mid &gt; x) get_R(lc, x);&#125;i64 qry_L(CI &amp;t, CI &amp;v)&#123; CI l = DS::L[t], r = DS::R[t]; if(m[t] &lt; v) return (i64)(r - l + 1) * v - s[t]; if(l == r) return 0; push_down(t, r - l + 1); if(m[lc] &gt;= v) return qry_L(lc, v); return (i64)((r - l + 2) &gt;&gt; 1) * v - s[lc] + qry_L(rc, v);&#125;i64 qry_R(CI &amp;t, CI &amp;v)&#123; CI l = DS::L[t], r = DS::R[t]; if(m[t] &lt; v) return (i64)(r - l + 1) * v - s[t]; if(l == r) return 0; push_down(t, r - l + 1); if(m[rc] &gt;= v) return qry_R(rc, v); return qry_R(lc, v) + (i64)((r - l + 1) &gt;&gt; 1) * v - s[rc];&#125;inline i64 query(CI &amp;x, CI &amp;v)&#123; reg i64 res = v - a[x]; &#123; st = sk; get_L(1, x); bool f = 0; for(Rint *i(st); i != sk; --i)&#123; if(m[*i] &gt;= v)&#123; res += qry_R(*i, v); f = 1; break; &#125; else res += (R[*i] - L[*i] + 1ll) * v - s[*i]; &#125; if(!f) return -1; &#125; &#123; st = sk; get_R(1, x); bool f = 0; for(Rint *i(st); i != sk; --i)&#123; if(m[*i] &gt;= v)&#123; res += qry_L(*i, v); f = 1; break; &#125; else res += (R[*i] - L[*i] + 1ll) * v - s[*i]; &#125; if(!f) return -1; &#125; return res;&#125;#undef lc#undef rc#undef mid&#125;#define inf 0x3f3f3f3fint main() &#123; fin &gt;&gt; n &gt;&gt; K; FOR(i, 1, n) fin &gt;&gt; a[i]; DS::build(1, 1, n); Rint ans = max(a[1], a[n]); FOR(i, 2, n - 1)&#123; chkmax(ans, a[i]); DS::update(1, 1, i - 1, 1); DS::update(1, i, n, -1); Rint l = a[i], r = inf, mid; reg i64 tmp; while(l &lt; r)&#123; mid = (l + r + 1) &gt;&gt; 1; tmp = DS::query(i, mid); if(tmp == -1 || tmp &gt; K) r = mid - 1; else l = mid; &#125; chkmax(ans, l); &#125; fout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>GYM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1423M」Milutin's Plums]]></title>
    <url>%2Fblog%2FCF1423M%2F</url>
    <content type="text"><![CDATA[题意简述交互题。矩阵 $n\times m$，有性质：对于任意子矩阵（即任意行的子集和列的子集的交），设子矩阵中第 $i$ 行最小值最先出现的位置是 $L(i)$，则 $L(i)$ 单调不降。 通过不超过 $4(n + m)$ 次单点询问确定该矩阵的最小值。 主要思路转化问题为对每行 $i$ 求 $ans_i$ 使得 $(i, ans_i)$ 为该行最小最前的位置。 那么根据给定的性质，一个自然的想法是： 假如现在需要求答案的行集合为 $S$（按大小排序），已求出 $T = \{S_{2i}\}$ 的答案。则此时 $S$ 中未被求出答案的所有元素 $x$ 的答案都被限定在上下两元素的答案范围内，可以暴力询问求解。边界情况显然为 $|S| = 1$，此时使用 $m$ 次询问暴力求出答案即可。 那么对于集合 $S$，记其最多需要的询问次数为 $f(|S|) = f(\frac{|S|}{2}) + |S| + m$。则总共需要 $2n + m\log n$ 次。 尽管 $n$ 的系数足够小，但 $m$ 的系数太大。 设可能的列的集合为 $T$，如果 $|T|&gt;|S|$，我们尝试将先减小 $T$ 的大小。 考虑两个元素 $a(x, l), a(x, r)$。如果 $a(x, l)\le a(x, r)$，则显然对于任意 $i\le x$，$L(i)\ne r$；如果 $a(x, l)&gt; a(x, r)$，则同理对于任意 $i\ge x$，$L(i)\ne l$。 由此我们可以在 $|S| + |T|$ 步内将 $T$ 的大小缩小为 $|S|$。 此时对于集合 $S$，最多需要的询问次数即为 $f(|S|) = f(\frac{|S|}{2}) + 2|S| + 2|T|$，即最多需要 $4(n + m)$ 次。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;bits/stdc++.h&gt;using namespace std;#define FOR(i, a, b) for (int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define MP make_pair#define pb push_backtypedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;#define SZ(x) ((int)(x).size())#define Templ(T) template &lt;typename T&gt;inline int read() &#123; int ans = 0; char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) ans = ans * 10 + c - '0'; return ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#ifdef LOCAL#define N 1010int qry[N][N];int qry_cnt;#endifmap&lt;PII, int&gt; mem;inline int ask(int x, int y)&#123; if(mem.count(MP(x, y))) return mem[MP(x, y)]; printf("? %d %d\n", x, y), fflush(stdout); #ifdef LOCAL return ++qry_cnt, qry[x][y]; #endif return mem[MP(x, y)] = read();&#125;//由于列太多，需要去除一些不可能在 ans 里的列inline VI Reduce(VI rows, VI cols)&#123; VI ans; const int n = SZ(rows); int i = 0, r; for(int c: cols)&#123; if(ans.empty())&#123; ans.pb(c); continue; &#125; r = rows[i]; int y = ans.back(); while(ask(r, y) &gt; ask(r, c))&#123; ans.pop_back(); --i; if(ans.empty()) break; r = rows[i]; y = ans.back(); &#125; if(SZ(ans) == n) continue; else&#123; ans.pb(c); ++i; &#125; &#125; //注意这里仅仅是简单地去掉了一些多余的列 //并不具有正确性 return ans;&#125;//(rows[i], ans[i]) 为该行最小且最前的VI Solve(VI rows, VI cols)&#123; if(SZ(rows) &lt; SZ(cols))&#123; cols = Reduce(rows, cols); &#125; const int n = SZ(rows), m = SZ(cols); VI nrows; for(int i = 1; i &lt; n; i += 2)&#123; nrows.pb(rows[i]); &#125; VI nans; if(!nrows.empty())&#123; nans = Solve(nrows, cols); &#125; //先做奇数行 VI ans; int lc = 0, rc; int x, y; FOR(i, 0, n - 1)&#123; if(i &amp; 1)&#123; //对于奇数行，已经做过了 ans.pb(nans[i &gt;&gt; 1]); continue; &#125; rc = m - 1; if(i + 1 &lt; n)&#123; rc = lc; while(cols[rc] &lt; nans[i &gt;&gt; 1])&#123; ++rc; &#125; &#125;else&#123; rc = m - 1; &#125; //根据题目性质，偶数行的答案应该在上下两行之间 x = rows[i]; y = cols[lc]; // printf(": %d %d\n", x, y); int mn = ask(x, y); FOR(j, lc, rc)&#123; // printf(": %d %d\n", x, cols[j]); if(chkmin(mn, ask(x, cols[j])))&#123; y = cols[j]; &#125; &#125; //暴力找出来即可 ans.pb(y); lc = rc; &#125; return ans;&#125;int main() &#123; int n = read(), m = read(); #ifdef LOCAL FOR(i, 1, n) FOR(j, 1, m) qry[i][j] = read(); #endif VI rows, cols; FOR(i, 1, n) rows.pb(i); FOR(i, 1, m) cols.pb(i); VI ans = Solve(rows, cols); int mn = 0x3f3f3f3f; FOR(i, 0, n - 1)&#123; chkmin(mn, ask(rows[i], ans[i])); &#125; printf("! %d\n", mn), fflush(stdout); #ifdef LOCAL printf("ask times: %d\n", qry_cnt); int rmn = 0x3f3f3f3f; FOR(i, 1, n) FOR(j, 1, m) chkmin(rmn, qry[i][j]); printf("real min: %d\n", rmn); puts(mn == rmn ? (qry_cnt &lt;= 4 * (n + m) ? "AC" : "AC but too many times") : "WA"); #endif return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>交互题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ2328」「清华集训 2017」避难所]]></title>
    <url>%2Fblog%2FLOJ2328%2F</url>
    <content type="text"><![CDATA[题意简述LOJ 2328 设 $F(n,b)$ 表示 $n$ 在 $b$ 进制下各个位上数字的乘积。如果想求一个最小的 $n$，使得 $p=F(n,b)$，那么一种贪心的方法是从 $b-1$ 开始往下试，如果是 $n$ 的约数就把它放在此时最低的位上。显然贪心是错的。例如 $b=9,p=216$，那么贪心会给出 $n=(3338)_9$，但正确答案是 $n=(666)_9$。给定 $b$，你需要给出一个 hack 数据 $p$ 以及它的最优解，或说明不存在。要求 $p\le 10^{18}$。$t$ 组数据，$t\le 200, 1\le b\le 100000$。 主要思路打表发现 $b&gt; 127$ 都有解。一种构造方法是令 $p = x^3y^3$，其中 $xy &lt; x^3 &lt; b, y^2 \ge b$。此时贪心就会翻车。枚举 $xy$，复杂度 $O(b)$。 不小于 $127$ 的，同样暴力打表，发现答案形式均可以是 $p = xy^2$ 的形式。于是可以 $O(b^2)$ 出解。 有意思的一点是 $b \le 12$ 时仅有 $b = 9$ 有解。 参考代码12345678910111213141516171819202122232425262728293031def check( x, n ): res = 0 i = n - 1 while i &gt;= 2: while x % i == 0: x /= i res += 1 i = min(x, i - 1) if res &gt; 3: return True else: return Falsedef solve(): n = int(input()) if n &lt;= 127: for i in range(n - 1, 0, -1): for j in range(n - 1, 0, -1): if check(i * j * j, n): print (3, i, j, j) return else: for i in range(n - 1, 0, -1): if check(i * i * i, n): print (3, i, i, i) return print (-1) returncase = int(input())while case &gt; 0: solve() case -= 1]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC047E」Product Simulation]]></title>
    <url>%2Fblog%2FAGC047E%2F</url>
    <content type="text"><![CDATA[最近感觉所有要做的题都是在 CF 上的。然而今天 CF 挂了。随便点开最近的 AGC。一看，怎么是造计算机题啊。 题意简述AGC 047E 给一个大小为 $N=2\times 10^5$ 的内存池 $a_i$，有两种操作： + i j k，$a_k\gets a_i + a_j$。 &lt; i j k，$a_k\gets [a_i &lt; a_j]$。 注意操作时不需要满足i, j, k互不相同。 输出一个操作序列使得按序列操作后 $a_2 = a_0\times a_1$。除了 $a_0, a_1$ 外其他元素初始均为 $0$。记你的操作序列长度为 $Q$，则应保证 $Q\le 2\times 10^5$。保证非负整数 $a_0,a_1\le 10^9$，所有元素在使用时应保证不大于 $10^{19}$。 主要思路首先我们会把一个位置 $i$ 设为 $0$：将 $i$ 和某个未使用的位置比较。其次我们也会把一个位置 $i$ 设为 $1$：将某个未使用的位置和 $a_0 + a_1$ 作比较。 注意到若 $a_0 = a_1 = 0$ 造不出 $1$，但是此时显然无论怎么操作都是 $0$，所以答案也是对的。 其次我们会把一个数左移 $k$ 位：自己加自己 $k$ 次就好了。 那么考虑如何取出一个数 $x$ 的所有二进制位。 先造出所有 $2^k$。然后从高到低确定每一位即可： 设已经确定的位置的和为 $C$，现在在确定第 $k$ 位。那么将 $C + 2^k$ 与 $x + 1$ 比较得到 $tmp$ 就是这位是否是 $1$。最后把 $C\gets C + tmp\times 2^k$ 即可。 于是把 $a_0, a_1$ 的二进制位都取出来，模拟二进制乘法即可。 最终取得了3903次的答案。感觉还没卡到最优但懒得卡了（ 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;#define FOR(i, a, b) for (int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;struct ASK&#123; int O, I, J, K; inline ASK(): O(0), I(0), J(0), K(0)&#123;&#125; inline ASK(int _O, int _I, int _J, int _K): O(_O), I(_I), J(_J), K(_K)&#123;&#125;&#125;;vector&lt;ASK&gt; ans;#define ask(o, i, j, k) ans.push_back(ASK(o, i, j, k))inline void write()&#123; printf("%d\n", (int)ans.size()); for(ASK q: ans) printf("%c %d %d %d\n", "+&lt;"[q.O], q.I, q.J, q.K);&#125;//`+ i j k`: a[k] = a[i] + a[j]//`&lt; i j k`: a[k] = bool(a[i] &lt; a[j])#define N 300//a[N] = 0//a[N - 1] = a[0] + a[1]//a[N - 2] = 1, a[N - 2 - i] = 1 &lt;&lt; iinline void Reset(const int &amp;x)&#123; ask(1, x, N, x);&#125;inline void Set(const int &amp;x)&#123; ask(1, N, N - 1, x);&#125;inline void Set(const int &amp;x, const int &amp;y)&#123; ask(0, N, y, x);&#125;inline void Double(const int &amp;x)&#123; ask(0, x, x, x);&#125;inline void Shift(const int &amp;x, const int &amp;t)&#123; FOR(i, 1, t) Double(x);&#125;// inline void Make(const int &amp;x, const i64 &amp;v)&#123;// int m = 64 - __builtin_clzll(v);// while(m--)&#123;// if((v &gt;&gt; m) &amp; 1) ask(0, x, N - 2, x);// if(m) Double(x);// &#125;// &#125;// //use: 190001// inline void Add(const int &amp;x, const i64 &amp;v)&#123;// #define tmp 190001// if(!v) return;// int m = 64 - __builtin_clzll(v);// if(1ll &lt;&lt; (m - 1) == v)&#123;// ask(0, x, N - 1 - m, x);// return;// &#125;// Reset(tmp), Make(tmp, v);// ask(0, x, tmp, x);// #undef tmp// &#125;//use: [200, 202)inline void Split(const int &amp;x, int t)&#123; #define P 200 #define C 201 #define tmp 202 ask(0, x, N - 2, P); Reset(C); ROF(z, 29, 0)&#123; ask(0, C, N - 2 - z, tmp); ask(1, tmp, P, tmp); Set(t + z, tmp); Shift(tmp, z); ask(0, C, tmp, C); &#125; // return t + 30; #undef P #undef C #undef tmp&#125;//use: [100, 200)inline void Mul(const int &amp;x, const int &amp;a, const int &amp;b)&#123; #define A 100 #define B 150 #define tmp 199 Split(a, A), Split(b, B); ROF(k, 58, 0)&#123; int i, j; for(i = 0; i &lt;= k; ++i)&#123; j = k - i; if(i &lt;= 29 &amp;&amp; j &lt;= 29)&#123; ask(0, A + i, B + j, tmp); ask(1, N - 2, tmp, tmp); ask(0, x, tmp, x); &#125; &#125; if(k) Double(x); &#125; #undef A #undef B #undef tmp&#125;inline void init()&#123; ask(0, 0, 1, N - 1); Set(N - 2); FOR(i, 1, 29) ask(0, N - 1 - i, N - 1 - i, N - 2 - i);&#125;int main() &#123; init(); Mul(2, 0, 1); write(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《アオイトリ》共通]]></title>
    <url>%2Fblog%2F20201004%2F</url>
    <content type="text"><![CDATA[假期尽量冲完 aoi tori 一条线。 ——20200930日记事与愿违，这人咕了。所以只看完了共通线。 知道紫社感觉很久了，毕竟我已经记不清了。想起这个是因为有一天有人给我推荐了《アオイトリ》。然后我「哦，这个社我感兴趣，但是没玩过」。当时我的网盘不限速手段恰好坏了，所以就咕了。 之后过了挺久，NEUTRINO出来了，nico扔给了我一首《ブルーバード》。鉴于我没有看过火影，脑海里浮现的是「我咕掉的作品好像也有一部叫《青鸟》……」。 结果不知道啥时候我在水的时候，看见一个神必人说《アマツツミ》汉化出了，立即到他给的链接里去下了下来。结果一看，体验版。当然后来抱着弃之可惜的心态玩了一小会。这个时候我就又想起了这部。 于是又咕了很久，直到开学第一周回来，我把它整到硬盘里了。有修改日期为证，2020/9/6 1:33解压完毕。然后我就把门锁好，开始推我「真正」推的第一部紫社作品。 以下剧透警告。 不到三分钟，我就庆幸刚刚把门锁好了。他妈的怎么一上来就 HS 啊！然而即使 HS 也阻挡不了我的睡意。于是在明理的第一个 HS 还没完，我就睡大觉去了。 律出门散步，顺便补充了一下刚才没说完的世界观。遇见反派，抛出来一个大主题，这段的展开感觉挺正常。回教堂，律遇到了不速之客——吸血鬼玛丽·哈克。百年前教堂的主人，变成吸血鬼后被迫离家漂泊直至如今，如今再次回到故里；家务全能多才多艺，不谙世事……这人设怎么感觉挺常见的。顺带一提「メアリー」的读法感觉挺洗脑的。 结果第二天（也就是「最初的三天 2/3」）继续听玛丽故事。 玛丽 「当然，这一百年来，我也有过要是那时候真的死掉就好了的想法」玛丽 「想过千百回」玛丽 「但是，能让我觉得那时候没死真的是太好了的理由毫无疑问，还要更多更多」玛丽 「想过千万回」玛丽 「但之所以能够有这些想法，也都是因为，我当时活了下来不是吗」玛丽 「也就是说，生者即为胜者」玛丽 「耶—咿♪」 不对劲啊。这孩子……怕不是回来寻死的吧。到这里的时候我突然有这种感觉。不知道是否和那一周恰好推到这往后一点点有关系。 第三天凌晨。律刚从电话恶魔的话里推出的自己的能力与玛丽撕心裂肺的叫喊（那张立绘应该是在这里第一次出现吧？）让我更加笃信了。然后确实也猜对了。ああ…… 嘛，知道她想死，而律又不想让她死，这一天的事情也就比较普通了。当然嘴炮是没用的。最后还是喝了律的血然后被拽出去，发现可以感受阳光的温暖了。 于是序章就这样结束了。 共通线五天，就来了三个主要角色。 第一天是海野明理。给人的气质，还有关于「悬崖下面」的谈话，一时让我说不上来感觉。「像是会招律喜欢的女孩子。反正律喜欢那种文静乖巧的女孩对吧」——小夜嘛，其实感觉不止是这样。 明理 「但是，前辈」在玛丽走过来的途中，她似乎有话和我说。明理 「如果出现对悬崖下面感兴趣的孩子，霍尔顿该怎么办呢」明理 「那个孩子特别特别地好奇悬崖下面是什么样子」明理 「掉下去会遇到什么，纯粹的孩子只是好奇地想知道这个，一点也不感到畏惧」明理 「如果，霍尔顿抓住了奔向悬崖孩子的手臂，就相当于否定了他想守护的纯粹——」明理 「他就会变成，他所否定的令人讨厌的成年人」明理 「但是，如果不制止的话，孩子肯定就会摔下去的吧」明理 「……霍尔顿会怎么办呢？」她又重复了一遍，随后停止了话语。『如果是你的话，会怎么做？』我想，她是在知道答案的情况下故意问我这个问题的。玛丽已经走过来了，我无法开口作答。恐怕——是明理特意挑了这个时机问我的。至于答案，我只能想到一个。『那就一起掉下去』。 个人线的展开大概会挺有意思的。 另外，妹抖服很可爱哦，あかり酱。 结果当晚律欲求不满和美果子来了一场。这里非常需要吐槽一点。尽管 CG 画得非常好，但也不知道是不是每次玩都是睡前，所以对 HS 完全没有感觉。又不是特别想C过去，但是看着又没啥事做，就只能喝水。就这样，这几天用水量倍增。 第二天，黑崎小夜。感觉，应该是真双胞胎吧？一点悲观，一点厌世，封存的套壳的少女心。猜测这里后面会有和母亲有关的展开？ 所以为什么又有 HS 我喝水喝得想吐哦。而且怎么这个这么长啊（恼） 第四天，赤锖理沙，律的第一次。目前对老师完全无感，不评价了。之后如果咕的话一定是先咕这条线。 然后（我猜测）一个很重要的剧情终于出现了——玛丽的剧本。我猜无论哪条线关于演这舞台剧的展开应该都会占有不少部分。 最后共通线就结束在「遵吾之圣名」的樱花树下（喂你莫非每次到温室的树下都要用这个 bgm 么）选妃。而且只要选就完事了（别告诉我个人线里什么选项都没有）。 好，总之先选了玛丽线。毕竟序章过后两人的缘分已经是同生死，最顺理成章的就是选玛丽做主角。 那么顺便奶一口最后玛丽肯定要变回人吧。 事后（指写完这篇 blog 几天）发现语言支离破碎。应该和初次写这种东西，写的时候想睡觉（和推 gal 同一时段（睡前）），还有没推完任何线（就是说啊我觉得除了序章真没啥能写的）不无关系。不过第一次写这种东西失败也无可厚非……大概吧。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「GYM101741H」Compressed Spanning Subtrees]]></title>
    <url>%2Fblog%2FGYM101741H%2F</url>
    <content type="text"><![CDATA[题意简述GYM101741H 交互题。有一棵 $n$ 个点的无根树，你至多询问 $2550$ 次点集 $X$，交互器会告诉你 $X$ 的虚树大小。求这棵树。$n\le 100$，虚树是也是无根的，没有二度点。 主要思路询问 $\{[n]\backslash x\}$ 可以知道 $x$ 是不是叶子。 然后随便取一个叶子为根 $rt$。对每个非叶子 $i$ 和叶子 $j$ 询问 $\{rt, i, j\}$ 可以知道 $i$ 是否是 $j$ 的祖先。不妨设 $S(x)$ 为点 $x$ 子树内的叶子集合。 注意到树上没有二度点，所以对于点 $x$ 与其父亲 $f$ 有 $S(x)\varsubsetneq S(f)$（$x,f \neq rt$）。所以我们可以对于每个任意两点之间找出他们是否有祖先关系了。 然后对于点 $x$，求一个祖先 $p$ 使得 $\operatorname{siz}(p)$ 最小，就是其父亲。 参考代码这 cf 怎么不支持__uint128_t啊（半恼） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;inline int read() &#123; Rint ans = 0; reg char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) ans = ans * 10 + c - '0'; return ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;typedef vector&lt;int&gt; V;typedef unsigned long long u64;struct u128&#123; u64 a[2]; inline u128()&#123; a[0] = a[1] = 0; &#125; inline u128(const u64 b_0, const u64 b_1)&#123; a[0] = b_0, a[1] = b_1; &#125; inline popcount()&#123; return __builtin_popcountll(a[0]) + __builtin_popcountll(a[1]); &#125; inline void set(const int &amp;x)&#123; a[x &gt;&gt; 6] |= 1ull &lt;&lt; (x &amp; 63); &#125; inline bool test(const int &amp;x)&#123; return (a[x &gt;&gt; 6] &gt;&gt; (x &amp; 63)) &amp; 1; &#125; inline u128 operator &amp;(const u128 &amp;x)const&#123; return u128(a[0] &amp; x.a[0], a[1] &amp; x.a[1]); &#125; inline bool operator ==(const u128 &amp;x)const&#123; return a[0] == x.a[0] &amp;&amp; a[1] == x.a[1]; &#125;&#125;;#define pb push_back#define N 128inline int query(const V &amp;a)&#123; printf("? %d ", (int)a.size()); for(Rint v: a) printf("%d ", v); puts(""); fflush(stdout); return read();&#125;int n;int root;int siz[N], fth[N];bool leaf[N];u128 s[N], pr[N];V e[N];void dfs(const int &amp;u, const int &amp;f)&#123; fth[u] = f; for(Rint v: e[u]) if(v != f) dfs(v, u);&#125;int main() &#123; n = read(); FOR(i, 1, n)&#123; V a; FOR(j, 1, i - 1) a.pb(j); FOR(j, i + 1, n) a.pb(j); (leaf[i] = query(a) == n - 1) &amp;&amp; (root = i); &#125; FOR(i, 1, n)&#123; if(leaf[i])&#123; s[i].set(i); s[root].set(i); &#125;else&#123; FOR(j, 1, n) if(leaf[j] &amp;&amp; j != root)&#123; V a; a.pb(root), a.pb(i), a.pb(j); query(a) == 3 &amp;&amp; (s[i].set(j), 1); &#125; &#125; &#125; FOR(i, 1, n) FOR(j, 1, n)&#123; (s[i] &amp; s[j]) == s[j] &amp;&amp; (pr[i].set(j), ++siz[i]); &#125; // FOR(i, 1, n) siz[i] = pr[i].popcount(); *siz = 128; FOR(i, 1, n)&#123; Rint x(0); FOR(j, 1, n) if(i != j &amp;&amp; pr[j].test(i)) siz[j] &lt; siz[x] &amp;&amp; (x = j); if(x) e[i].pb(x), e[x].pb(i); &#125; dfs(1, 0); printf("! "); FOR(i, 2, n) printf("%d ", fth[i]); puts(""); fflush(stdout); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>交互题</tag>
        <tag>GYM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「GYM102391B」Bigger Sokoban 40k]]></title>
    <url>%2Fblog%2FGYM102391B%2F</url>
    <content type="text"><![CDATA[题意简述GYM102391B 这有个游戏。有一个 $n\times m$ 的网格图，每个格子可能是空地（.）或障碍物（#）。还有一个放在空地里的 $2\times 2$ 的箱子（B），一个 $2\times 2$ 的目的地（S），和一个 $1\times 1$ 的玩家（P）。每一步玩家可以上下左右移动，但是不能走到障碍上、箱子上或走出网格图。如果玩家移动的方向上下一格是箱子，那么箱子会沿着相同的方向被推动。箱子不能被拉动。箱子不能被推到障碍上或出网格图。当箱子到达目的地时就赢了。现在请你构造一个 $n + m\le 100$ 的满足条件的网格图，使得有解且最小操作次数不小于 $40000$。 主要思路八仙过海，各显神通。 首先我想让箱子每动几步都要让这个人绕很远到另一个方向来推。于是得到了下面的答案。可以获得48213步的好成绩。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474847 53SS...................................................SS...................................................##.###############################################...#BB##...##########################################..#PBB.....#....##########...#....##########...#....#...........#.................#.................#............#...#.................#.................#........#####..###..##...######...##..##...######...##..##......##..###..######...##..###..######...##..###..#####........#...#....#........#...#....#........#...#............#........#........#........#........#...........#....#........#...#....#........#...#....#........#..######...##..###..######...##..###..######...##..##..##...######..###..##...######..###..##...######..#........#....#...#........#....#...#........#....#...........#........#........#........#........#............#...#........#....#...#........#....#...#........#####..###..##...######..###..##...######..###..##......##..###..######...##..###..######...##..###..#####........#...#....#........#...#....#........#...#............#........#........#........#........#...........#....#........#...#....#........#...#....#........#..######...##..###..######...##..###..######...##..##..##...######..###..##...######..###..##...######..#........#....#...#........#....#...#........#....#...........#........#........#........#........#............#...#........#....#...#........#....#...#........#####..###..##...######..###..##...######..###..##......##..###..######...##..###..######...##..###..#####........#...#....#........#...#....#........#...#............#........#........#........#........#...........#....#........#...#....#........#...#....#........#..######...##..###..######...##..###..######...##..##..##...######..###..##...######..###..##...######..#........#....#...#........#....#...#........#....#...........#........#........#........#........#............#...#........#....#...#........#....#...#........#####..###..##...######..###..##...######..###..##......##..###..######...##..###..######...##..###..#####........#...#....#........#...#....#........#...#............#........#........#........#........#...........#....#........#...#....#........#...#....#........#..######...##..###..######...##..###..######...##..##..##...######...##..##...######...##..##...######....................#.................#..................................#.................#.....................##########...#....##########...#....##########... 后来我想了想，其实应该可以做一些 12345.########.#...#....#.#.#.#..#.#.#.#....#...#. 之类的结构来更多地消耗步数。 然后借了一个 coach 号，看到了这个答案。可以获得63829步的好成绩。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495049 51...............SS.................................P.#############.SS##################################.#...#...#...#...#..#....#..#....#..#....#..#....##.#.#.#.#.#.#.#...#.......#.......#.......#.......##.#.#.#.#.#.#.#...#......##.......#......##......###.#.#.#.#.#.#.#...#...#...#...#...#...#...#...#......#.#.#.#.#.#.#......##......##......##......##......#.#.#.#.#.#.#.......#.......#.......#.......#......#.#.#.#.#.#.#..#....#..#....#..#....#..#....###..#.#.#.#.#.#.#.###################################..#.#.#.#.#.#.#.##....#..#....#..#....#..#....#..##..#.#.#.#.#.#.#.##.......#.......#.......#.......##..#.#.#.#.#.#.#.###......##......#.......##......#...#.#.#.#.#.#.#.##...#...#...#...#...#...#...#...#...#.#.#.#.#.#.#.#....##......##......##......##......#.#.#.#.#.#.#.#....#.......#.......#.......#.......#.#.#.#.#.#.#.#....#....#..#....#..#....#..#....#..#.#.#.#.#.#.#.#...##################################.#.#.#.#.#.#.#...#..#....#..#....#..#....#..#....##.#.#.#.#.#.#.#...#.......#.......#.......#.......##.#.#.#.#.#.#.#...#......##.......#......##......###.#.#.#.#.#.#.#...#...#...#...#...#...#...#...#......#.#.#.#.#.#.#......##......##......##......##......#.#.#.#.#.#.#.......#.......#.......#.......#......#.#.#.#.#.#.#..#....#..#....#..#....#..#....###..#.#.#.#.#.#.#.###################################..#.#.#.#.#.#.#.##....#..#....#..#....#..#....#..##..#.#.#.#.#.#.#.##.......#.......#.......#.......##..#.#.#.#.#.#.#.###......##......#.......##......#...#.#.#.#.#.#.#.##...#...#...#...#...#...#...#...#...#.#.#.#.#.#.#.#....##......##......##......##......#.#.#.#.#.#.#.#....#.......#.......#.......#.......#.#.#.#.#.#.#.#....#....#..#....#..#....#..#....#..#.#.#.#.#.#.#.#...##################################.#.#.#.#.#.#.#...#..#....#..#....#..#....#..#....##.#.#.#.#.#.#.#...#.......#.......#.......#.......##.#.#.#.#.#.#.#...#......##.......#......##......###.#.#.#.#.#.#.#...#...#...#...#...#...#...#...#......#.#.#.#.#.#.#......##......##......##......##......#.#.#.#.#.#.#.......#.......#.......#.......#......#.#.#.#.#.#.#..#....#..#....#..#....#..#....###..#.#.#.#.#.#.#.###################################..#.#.#.#.#.#.#.##....#..#....#..#....#..#....#..##..#.#.#.#.#.#.#.##.......#.......#.......#.......##..#.#.#.#.#.#.#.###......##......#.......##......#...#.#.#.#.#.#.#.##...#...#...#...#...#...#...#...#...#.#.#.#.#.#.#.BB...##......##......##......##......#.#.#.#.#.#.#.BB...#.......#.......#.......#.......#...#...#...#####..#....#..#....#..#....#..#....#..# 怎么说，其实结构差别不是特别大。比较好的地方是舍弃了上面那两行空的，因为那显然不太优。 然后后来也找到了类似这种的。次数62624。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454645 55#......................................................#BB#################################################SS.#BB#....########...#....########...#....########...#SS.#P.#...............#...............#...............#...#..##..............##..............##..............#..##..#...#########...#...#########...#...#########...#..##..#.......#..#...##.......#..#...##.......#..#...##..##..#.......#.......#.......#.......#.......#.......#..##..#..#...##.......#..#...##.......#..#...##.......#..##..#####...#...#########...#...#########...#...#####..##..#.......##...#..#.......##...#..#.......##...#..#..##..#.......#.......#.......#.......#.......#.......#..##..##...#..#.......##...#..#.......##...#..#.......#..##..#...#########...#...#########...#...#########...#..##..#.......#..#...##.......#..#...##.......#..#...##..##..#.......#.......#.......#.......#.......#.......#..##..#..#...##.......#..#...##.......#..#...##.......#..##..#####...#...#########...#...#########...#...#####..##..#.......##...#..#.......##...#..#.......##...#..#..##..#.......#.......#.......#.......#.......#.......#..##..##...#..#.......##...#..#.......##...#..#.......#..##..#...#########...#...#########...#...#########...#..##..#.......#..#...##.......#..#...##.......#..#...##..##..#.......#.......#.......#.......#.......#.......#..##..#..#...##.......#..#...##.......#..#...##.......#..##..#####...#...#########...#...#########...#...#####..##..#.......##...#..#.......##...#..#.......##...#..#..##..#.......#.......#.......#.......#.......#.......#..##..##...#..#.......##...#..#.......##...#..#.......#..##..#....########...#....########...#....########...#..##..#.......#..#...##.......#..#...##.......#..#...##..##..#.......#.......#.......#.......#.......#.......#..##..#..#...##.......#..#...##.......#..#...##.......#..##..#####...#...#########...#...#########...#...#####..##..#.......##...#..#.......##...#..#.......##...#..#..##..#.......#.......#.......#.......#.......#.......#..##..##...#..#.......##...#..#.......##...#..#.......#..##..#...#########...#...#########...#...#########...#..##..#.......#..#...##.......#..#...##.......#..#...##..##..#.......#.......#.......#.......#.......#.......#..##..#..#...##.......#..#...##.......#..#...##.......#..##..#####...#...#########...#...#########...#...#####...#..........##..............##..............##.....................#...............#...............#...............####...#....########...#....########...#....####... 啊居然观赏性还挺高。学到许多。（真的吗？）]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>猜结论</tag>
        <tag>GYM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1396E」Distance Matching]]></title>
    <url>%2Fblog%2FCF1396E%2F</url>
    <content type="text"><![CDATA[题意简述CF1396E 一棵树大小为 $n$（偶数）。将点两两配对，一对的权值为两点在树上的距离。求方案时使所有对的权值和为 $K$。$n\le 10^5$，需判断无解。 主要思路为缩短公式长度，定义 $M_2(x) = x \bmod 2$，$u, v$ 间匹配为 $m(u, v)$，某个方案得到的答案为 $S$。 设一条边 $e$ 将树分成两部分，其中节点数较少的为 $w_e$。不难发现，至少有 $M_2(w_e)$，至多有 $w_e$ 个匹配经过 $e$。所以对于一棵树 $T$，答案的下上界就分别是 $L(T) = \sum\limits_e M_2(w_e), R(T) = \sum\limits_e w_e$。又注意到 $S=\sum\limits_{m(u, v)}(\operatorname{dep}(u) + \operatorname{dep}(v) - 2\operatorname{dep}(\operatorname{lca}(u ,v)))\equiv \sum\limits_{u\in[1, n]}\operatorname{dep}(u)\equiv R(T)\pmod{2}$，故 $K$ 与 $R(T)$ 奇偶性相同也是一个有解的必要条件。（钦定根节点深度为 $0$。） 然后我们来证明这些就是有解的充分条件。$n = 2$显然成立。考虑归纳，下证若在 $n = 2n’ - 2$ 时命题成立，考虑 $n = 2n’$。首先我们取出一个重心 $G$，则此时 $\sum\limits_e w_e = \sum\limits_{i\neq G}\operatorname{siz}(i)$。 如果 $K = R(T)$，直接求出 dfs 序 $r_i$，将 $r_i$ 与 $r_{i+n/2}$ 匹配即可。（这里运用了一下移位技巧。） 否则，取 $G$ 的儿子 $g$ 使 $\operatorname{siz}(g)$ 最大。此时显然有 $\operatorname{siz}(g) \ge 2$（否则为上一种情况）。取节点 $w$ 为子树 $g$ 中深度最大且 $\operatorname{siz}(w)\ge 2$ 的节点。 此时，如果 $K + 2\operatorname{dep}(w) &gt; R(T)$，必然存在 $g$ 子树中的一个非叶节点 $u$ 使 $K + 2\operatorname{dep}(u) = R(T)$，匹配 $u$ 与 $u$ 的任意一个儿子，对其他点按照上面情况的移位技巧即可。 否则即 $K + 2\operatorname{dep}(w) \le R(T)$。 如果 $w$ 有两个或以上儿子 $u, v$，匹配并在树中删除它们，得到新树 $T’$。显然它们都是叶子节点，故 $K’ = K - 2, L(T’) = L(T) - 2, R(T’) = R(T) - 2(\operatorname{dep}(w) + 1)$。并且，此时 $T’$ 重心仍为 $G$，节点数减少 $2$，且 $K’\in[L(T’), R(T’)]$，故根据归纳假设有解。 如果 $w$ 只有一个儿子 $u$，匹配 $w, u$ 并删除它们，得到新树 $T’$。同理易得$K’ = K - 1, L(T’) = L(T) - 1, R(T’) = R(T) - 2\operatorname{dep}(w) - 1$。重心不变，节点数减少 $2$，根据归纳假设有解。 由此，我们证明了上述条件为有解的充要条件。 考虑如何构造，发现直接以重心为根，根据上述证明充分性的过程模拟即可。 由于操作的特殊性，复杂度可以做到 $O(n)$，但本人懒得动脑就直接写了个 $O(n\log n)$ 的。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;typedef vector&lt;int&gt; vec;typedef pair&lt;int, int&gt; pii;#define MP(a, b) make_pair(a, b)#define fr first#define sc second#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define MMR (1 &lt;&lt; 21)struct INPUT&#123; char buf[MMR], *s; INPUT()&#123; s = buf, fread(buf, 1, MMR, stdin); &#125; Templ(_Tp) inline INPUT&amp; operator &gt;&gt;(_Tp &amp;x)&#123; x = 0; while(*s &lt; 48) ++s; while(*s &gt; 47) x = x * 10 + *s++ - 48; return *this; &#125;&#125;fin;#define N 100010int n, n2;i64 K;vec E[N];int siz[N], mxs[N];int root;int dep[N], fth[N], vis[N];int oud[N];i64 L, R;set&lt;pii&gt; s[N], Q;void find_root(int u, int f)&#123; siz[u] = 1, mxs[u] = 0; for(Rint v: E[u]) if(v != f)&#123; find_root(v, u); siz[u] += siz[v], chkmax(mxs[u], siz[v]); &#125; chkmax(mxs[u], n - siz[u]); mxs[u] &lt;= n2 &amp;&amp; (root = u);&#125;void init(int u, int f, int root)&#123; siz[u] = 1; for(Rint v: E[u]) if(v != f)&#123; ++oud[u]; dep[v] = dep[u] + 1; fth[v] = u; init(v, u, root); siz[u] += siz[v]; &#125; if(siz[u] &gt; 1) s[root].insert(MP(dep[u], u)); L += siz[u] &amp; 1, R += siz[u];&#125;inline int get_son(int u)&#123; Rint v; while(E[u].size())&#123; v = E[u].back(), E[u].pop_back(); if(v != fth[u] &amp;&amp; !vis[v]) return v; &#125; return 0;&#125;inline void del(int u, int rt)&#123; Rint f = fth[u]; if(!--oud[f]) s[rt].erase(MP(dep[f], f));&#125;vec ans;void dfs(int u, int f)&#123; if(!vis[u]) ans.push_back(u); for(Rint v: E[u]) if(v != f) dfs(v, u);&#125;int main() &#123; fin &gt;&gt; n &gt;&gt; K; n2 = n &gt;&gt; 1; Rint u, v; FOR(i, 1, n - 1)&#123; fin &gt;&gt; u &gt;&gt; v; E[u].push_back(v), E[v].push_back(u); &#125; find_root(1, 0); for(Rint u: E[root])&#123; fth[u] = root; dep[u] = 1; init(u, root, u); if(siz[u] &gt; 1) Q.insert(MP(siz[u], u)); &#125; if(K &lt; L || K &gt; R || (K &amp; 1) != (R &amp; 1)) return puts("NO"), 0; puts("YES"); K = (R - K) &gt;&gt; 1; while(K)&#123; Rint rt = Q.rbegin()-&gt;sc; Q.erase(--Q.end()); Rint u = s[rt].rbegin()-&gt;sc, d = s[rt].rbegin()-&gt;fr; if(K &gt;= d)&#123; K -= d; Rint v = get_son(u); Rint w = get_son(u); if(!w) w = u; vis[v] = vis[w] = 1; del(v, rt), del(w, rt); printf("%d %d\n", v, w); &#125;else&#123; u = s[rt].lower_bound(MP(K, 0))-&gt;sc; Rint v = get_son(u); E[u].push_back(v); vis[u] = vis[v] = 1; printf("%d %d\n", u, v); break; &#125; siz[rt] -= 2; if(siz[rt] &gt; 1) Q.insert(MP(siz[rt], rt)); &#125; dfs(root, 0); Rint res = (int)ans.size() &gt;&gt; 1; FOR(i, 0, res - 1) printf("%d %d\n", ans[i], ans[i + res]); return 0;&#125; 参考资料liouzhou_101’s blog | CodeForces 1396E. Distance Matching]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>树论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1407E」Egor in the Republic of Dagestan]]></title>
    <url>%2Fblog%2FCF1407E%2F</url>
    <content type="text"><![CDATA[题意简述CF1407E $n$ 个点 $m$ 条边的有向图，边有黑白两种颜色。现在要给点染色，每个点染成黑或白，白点只能走它连出的白色边，黑点只能走它连出的黑色边，求一种染色方案使得 $1\to n$ 的最短路径最长，输出方案。 ($1 \le n, m \le 500000$) 主要思路发现正着做不好做，于是把边反过来倒着做。设 $f(x, c)$ 为当点 $x$ 颜色为 $c$ 时 $n\to x$ 的最短路径最长长度。直接 bfs 就行了。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;inline int read() &#123; Rint ans = 0; reg char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) ans = ans * 10 + c - '0'; return ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define N 500010#define inf 0x3f3f3f3fint n, m;vector&lt;int&gt; E[N][2];int f[N][2];int Q[N];#define f(x) max(f[x][0], f[x][1])inline void bfs()&#123; Rint *ql(Q), *qr(Q); *qr++ = n; f[n][0] = f[n][1] = 0; while(ql != qr)&#123; Rint u = *ql++; for(Rint v: E[u][0])&#123; if(f[v][0] &lt;= n) continue; f[v][0] = f(u) + 1; if(f(v) &lt; n) *qr++ = v; &#125; for(Rint v: E[u][1])&#123; if(f[v][1] &lt;= n) continue; f[v][1] = f(u) + 1; if(f(v) &lt; n) *qr++ = v; &#125; &#125;&#125;int main() &#123; n = read(), m = read(); Rint u, v, w; FOR(i, 1, m)&#123; u = read(), v = read(), w = read(); E[v][w].push_back(u); &#125; memset(f, 0x3f, sizeof(f)); bfs(); printf("%d\n", f(1) &gt; n ? -1 : f(1)); FOR(i, 1, n) printf("%d", f[i][0] &lt; f[i][1]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1396D」Rainbow Rectangles]]></title>
    <url>%2Fblog%2FCF1396D%2F</url>
    <content type="text"><![CDATA[题意简述CF1396D 有 $n$ 个豆子，第 $i$ 个坐标为 $(x_i + \varepsilon, y_i + \varepsilon)$，颜色 $c_i$（$\varepsilon = 0.5$）。总的坐标范围 $[0, lim]$，求有多少个格点矩形能够包含所有不同颜色的豆子。$n\le 2000$。 主要思路离散化，枚举矩形左边界做 $O(n)$ 次。考虑把右边界从 $lim$ 枚举回左边界。 那么现在左右边界确定。考虑对每一个纵坐标 $y$ 维护 $a_y$，满足对于下边界为 $y$ 时，只要上边界大于 $a_y$ 整个矩形就包含所有颜色。不难发现，任意时刻 $a_y$ 单调不降；右边界从右往左枚举的时候，一次只会把 $a$ 的一个后缀对某个数取 max。线段树，$O(n^2\log n)$。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;inline int read() &#123; Rint ans = 0; reg char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) ans = ans * 10 + c - '0'; return ans;&#125;#define mod 1000000007// inline int qmo(const int &amp;x)&#123; return x + (((mod - x) &gt;&gt; 31) &amp; mod); &#125;inline int qmo(const int &amp;x)&#123; return x &gt;= mod ? x - mod : x; &#125;typedef long long i64;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define N 2010int n, m, lim;struct Vertice&#123; int x, y, i, c;&#125;a[N];int Y[N], C[N], F[N];struct QRY&#123; int lst[N], nxt[N]; inline QRY()&#123;&#125; inline QRY(const QRY &amp;_Q)&#123; memcpy(lst, _Q.lst, sizeof(lst)); memcpy(nxt, _Q.nxt, sizeof(nxt)); &#125; inline void del(const int &amp;i)&#123; lst[nxt[i]] = lst[i]; nxt[lst[i]] = nxt[i]; &#125;&#125;Q;int lsc[N];int bar[N];namespace DS&#123;#define mid ((l + r) &gt;&gt; 1)#define lc ((t) &lt;&lt; 1)#define rc ((t) &lt;&lt; 1 | 1)#define ls lc, l, mid#define rs rc, mid + 1, rstruct Node&#123; int mn, mx, sum, tag; inline Node(int _mn = 0, int _mx = 0, int _sum = 0, int _tag = 0) : mn(_mn), mx(_mx), sum(_sum), tag(_tag)&#123;&#125; inline Node operator +(const Node &amp;rhs)const&#123; return Node(min(mn, rhs.mn), max(mx, rhs.mx), qmo(sum + rhs.sum), 0); &#125;&#125;a[N &lt;&lt; 2];inline void nd(int t, int l, int r, int v)&#123; a[t] = Node(v, v, (i64)(Y[r] - Y[l - 1]) * v % mod, v);&#125;void build(int t, int l, int r)&#123; if(l == r) return nd(t, l, r, F[l]); build(ls); build(rs); a[t] = a[lc] + a[rc];&#125;void update(int t, int l, int r, int L, int v)&#123; if(a[t].mn &gt;= v) return; if(a[t].mx &lt;= v &amp;&amp; l == L) return nd(t, l, r, v); if(a[t].tag)&#123; nd(ls, a[t].tag); nd(rs, a[t].tag); a[t].tag = 0; &#125; if(L &lt;= mid) update(ls, L, v); update(rs, max(mid + 1, L), v); a[t] = a[lc] + a[rc];&#125;#undef mid#undef lc#undef rc#undef ls#undef rs&#125;int ans;int main() &#123; n = read(), m = read(), lim = read(); FOR(i, 1, n) a[i].x = read(), a[i].y = read(), a[i].c = read(); sort(a + 1, a + n + 1, [&amp;](const Vertice &amp;lhs, const Vertice &amp;rhs)&#123; return lhs.y &lt; rhs.y; &#125;); a[0].x = a[0].y = Y[0] = -1; a[n + 1].x = a[n + 1].y = Y[n + 1] = lim; FOR(i, 1, n) a[i].i = i, Y[i] = a[i].y; FOR(i, 1, n)&#123; Q.nxt[Q.lst[i] = lsc[a[i].c]] = i; Q.nxt[i] = n + 1; lsc[a[i].c] = i; &#125; sort(a + 1, a + n + 1, [&amp;](const Vertice &amp;lhs, const Vertice &amp;rhs)&#123; return lhs.x &lt; rhs.x; &#125;); for(Rint i(1); i &lt;= n; Q.del(a[i].i), ++i)&#123; if(a[i].x == a[i - 1].x) continue; FOR(j, 1, i - 1) C[a[j].i] = 0; FOR(j, i, n) C[a[j].i] = a[j].c; for(Rint l(1), r(1), t(0); l &lt;= n; ++l)&#123; for(; r &lt;= n &amp;&amp; t &lt; m; ++r) C[r] &amp;&amp; !bar[C[r]]++ &amp;&amp; ++t; F[l] = t &lt; m ? lim : Y[r - 1]; C[l] &amp;&amp; !--bar[C[l]] &amp;&amp; --t; &#125; DS::build(1, 1, n); QRY q(Q); Rint res(0), id; ROF(j, n, i)&#123; res = qmo(res + ((Y[n] + 1ll) * lim - DS::a[1].sum) % mod * (a[j + 1].x - a[j].x) % mod); id = a[j].i; DS::update(1, 1, n, q.lst[id] + 1, Y[q.nxt[id]]); q.del(id); &#125; res = (i64)res * (a[i].x - a[i - 1].x) % mod; ans = qmo(ans + res); &#125; printf("%d\n", ans); return 0;&#125; 突然发现我开始染上了新的恶习： 对于几个if短句喜欢直接拿&amp;&amp;连接。 12if(A) if(B) C;(A) &amp;&amp; (B) &amp;&amp; (C);]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>log数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1406E」Deleting Numbers]]></title>
    <url>%2Fblog%2FCF1406E%2F</url>
    <content type="text"><![CDATA[题意简述CF1406E 交互题。给定 $n$, 猜数 $x$ ($1\le x\le n$)。 交互库将维护一个集合 $S$，初始为不大于 $n$ 的所有正整数。交互库提供三个函数： $A(a)$，返回求出 $S$ 中 $a$ 的倍数的个数 $(1\le a\le n)$。$B(a)$，返回 $A(a)$，并将所有 $a$ 的倍数从 $S$ 中删去（$x$ 不删，$a &gt; 1$）。$C(a)$，报告猜得的数 $x = a$。 三个函数总共可以调用不超过 $10^4$ 次。 主要思路未特殊提及时下列 $p$ 均为素数。 显然可以通过对每个素数 $B(p)$ 后求 $A(p^k)$ 得到 $x$ 的质因数分解。 发现 $10^5$ 内的素数及其幂次就有约 $10^4$ 个，然后暴毙了。 考虑大小分素数，称不大于 $\sqrt{n}$ 的为小素数，否则为大素数。 对于小素数可以直接通过上面的暴力得到。 如果 $x$ 有小素数因子，则显然最多有一个大素数因子，枚举大素数并求 $B(p)$ 即可得知是哪个大素数。 那么现在剩下的情况只有 $x$ 为大素数的。 发现 $A(1)$ 可以得到目前集合内剩余的数。 不妨直接暴力对每个大素数删除，每 $K$ 个 $B(p)$ 做一次 $A(1)$。如果和上次差的不是 $K$，证明 $x$ 就在刚刚删去的 $K$ 个中，每个做一次 $A(p)$ 即可。 $K$ 直接取为不大于 $\sqrt{n}$ 的素数个数即可。 参考代码然后还写挂了一会，自己写了一个 grader…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;bits/stdc++.h&gt;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;inline int read() &#123; Rint ans = 0; reg char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) ans = ans * 10 + c - '0'; return ans;&#125;#define N 100010int n;int b[N];int pr[N], *tp(pr);#ifdef LOCALnamespace grader&#123;int dt[N], X, cnt;inline void init(int x)&#123; FOR(i, 1, n) dt[i] = 1; X = x, cnt = 0; printf("R: %d %d\n", n, X);&#125;inline int A(int x)&#123; ++cnt; printf("A: %d\n", x); fflush(stdout); Rint res(0); for(Rint i(x); i &lt;= n; i += x) res += dt[i]; return res;&#125;inline int B(int x)&#123; ++cnt; printf("B: %d\n", x); fflush(stdout); Rint res(0); for(Rint i(x); i &lt;= n; i += x)&#123; if(dt[i]) ++res, dt[i] = (i == X); &#125; return res;&#125;inline int C(int x)&#123; ++cnt; printf(X == x ? "AC %d: %d\n" : "WA %d: %d\n", X, cnt); return 0;&#125;&#125;using grader::A;using grader::B;using grader::C;inline void init()&#123; FOR(i, 2, n)&#123; if(!b[i]) *tp++ = i; for(Rint *j(pr); i * *j &lt;= n &amp;&amp; j != tp; ++j)&#123; b[i * *j] = 1; if(!(i % *j)) break; &#125; &#125; grader::init(read());&#125;#elseinline int A(int x)&#123; // assert(x &lt;= n); return printf("A %d\n", x), fflush(stdout), read();&#125;inline int B(int x)&#123; // assert(x &lt;= n &amp;&amp; x &gt; 1); return printf("B %d\n", x), fflush(stdout), read();&#125;inline int C(int x)&#123; // assert(x &lt;= n); return printf("C %d\n", x), fflush(stdout), 0;&#125;inline void init()&#123; FOR(i, 2, n)&#123; if(!b[i]) *tp++ = i; for(Rint *j(pr); i * *j &lt;= n &amp;&amp; j != tp; ++j)&#123; b[i * *j] = 1; if(!(i % *j)) break; &#125; &#125;&#125;#endifint ans(1);int main() &#123; n = read(); init(); reg const int m(tp - pr); reg const int K(sqrt(m)); &#123; for(Rint *i(pr); i != pr + K; ++i)&#123; B(*i); Rint f(1); while(f * *i &lt;= n &amp;&amp; A(f * *i))&#123; f *= *i; &#125; ans *= f; &#125; &#125; if(ans &gt; 1)&#123; for(Rint *i(pr + K); (long long)ans * *i &lt;= (long long)n &amp;&amp; i != tp; ++i)&#123; if(B(ans * *i)) ans *= *i; &#125; return C(ans); &#125;else&#123; Rint c(0); Rint lst(A(1)), now; for(Rint *i(pr + K); i != tp; ++i)&#123; B(*i); if(++c != K) continue; c = 0; now = A(1); if(lst - now != K)&#123; for(Rint *j(i); j != i - K; --j)&#123; if(A(*j)) return C(*j); &#125; &#125; lst = now; &#125; if(c)&#123; now = A(1); if(lst - now != c)&#123; for(Rint *j(tp - 1); j != tp - 1 - c; --j)&#123; if(A(*j)) return C(*j); &#125; &#125; &#125; &#125; return C(ans);&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>交互题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1404D」Game of Pairs]]></title>
    <url>%2Fblog%2FCF1404D%2F</url>
    <content type="text"><![CDATA[题意简述CF1404D 交互题。给定一个正整数 $n$，两人玩游戏。游戏分两步： 先手把 $1$ 到 $2n$ 拆成 $n$ 对。 后手在每对中，选择恰好一个数。 如果选出的数之和为 $2n$ 的倍数，则后手胜，否则先手胜。 自己选择扮演先手还是后手，并给出必胜策略。$n\le 5\times 10^5$。 主要思路$n$ 是偶数时，先手必胜。 构造 $(i, n + i)$ 即可。此时无论怎么选，最后和都 $\bmod\ n$ 为 $\binom{n}{2}$。 那么下面考虑 $n$ 为奇数。 发现若已经得到了和 $\bmod\ 2n$ 为 $n$ 的方案，取不在方案内的 $n$ 个数即满足和为 $2n$ 的倍数。 于是条件就弱化为「和为 $n$ 的倍数」。 发现总有一种方案使得 $\bmod\ n = 0, 1, \cdots, n - 1$ 的数各出现一次。证明如下： 考虑一张 $n$ 个点的图，并对于每一对数 $(x, y)$，将 $x\bmod n, y\bmod n$ 间连一条边。 那么每个点的度都为 $2$，故整张图必定是若干个环。 考虑一个大小为 $m$ 的环实际上是 $m$ 对数，每对数只能选一个；$\bmod n$ 相等的也恰好组成 $m$ 对。所以直接选出 $m$ 个数两两不同对且不 $\bmod n$ 相等即可。 于是做完了，复杂度线性。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;inline int read() &#123; Rint ans = 0; reg char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) ans = ans * 10 + c - '0'; return ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define N 500010int n;int a[N &lt;&lt; 1];int f[N &lt;&lt; 1];int vis[N];inline int C(int x)&#123; return (x &gt; n) ? x - n : x + n;&#125;inline int sol_even()&#123; puts("First"); FOR(i, 1, n) printf("%d ", i); FOR(i, 1, n) printf("%d ", i); puts(""); fflush(stdout); return 0;&#125;inline int sol_odd()&#123; puts("Second"); fflush(stdout); Rint x; FOR(i, 1, n &lt;&lt; 1)&#123; x = read(); if(f[x]) a[f[x]] = i, a[i] = f[x], f[x] = 0; else f[x] = i; &#125; ROF(i, n &lt;&lt; 1, 1)&#123; if(f[i] || f[C(i)]) continue; f[x = i] = 1; while(x = a[C(x)], !f[x] &amp;&amp; !f[C(x)])&#123; f[x] = 1; &#125; &#125; x = 0; FOR(i, 1, n &lt;&lt; 1) x ^= i &amp; f[i]; FOR(i, 1, n &lt;&lt; 1) if(f[i] ^= x) printf("%d ", i); puts(""); fflush(stdout); return 0;&#125;int main() &#123; return (n = read()) &amp; 1 ? sol_odd() : sol_even();&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>图论</tag>
        <tag>交互题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「GYM102059K」Interesting Drug]]></title>
    <url>%2Fblog%2FGYM102059K%2F</url>
    <content type="text"><![CDATA[题意简述GYM102059K $n$ 个物品排列成一排。从选择某个物品开始，每一步可以选择左/右最近的未被选择的物品，直到所有物品均被选择。若第 $i$ 个物品恰好在第 $C_i$ 步被选择，则会贡献 $D_i$ 的价值。对每个 $1\le i\le n$，求出第一步选择 $i$ 能得到的最大价值。$n\le 300000$。 主要思路选物品的过程可以看作是二位平面上从 $(0, 0)$ 开始向上和向右行走，从 $i$ 开始可以看作终点是 $(i - 1, n - i)$。获得的贡献对应两条边的边权。提取出 $O(n)$ 个关键点 dp，用个树状数组维护即可 $O(n\log n)$。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define MMR (1 &lt;&lt; 23)struct INPUT&#123; char buf[MMR], *s; INPUT()&#123; s = buf, fread(buf, 1, MMR, stdin); &#125; inline INPUT&amp; operator &gt;&gt;(int &amp;x)&#123; x = 0; while(*s &lt; 48) ++s; while(*s &gt; 47) x = x * 10 + *s++ - 48; return *this; &#125;&#125;fin;struct OUTPUT&#123; char buf[MMR], *s; OUTPUT()&#123; s = buf; &#125; inline OUTPUT&amp; operator &lt;&lt;(i64 x)&#123; static char tmp[20]; reg char *top = tmp; do&#123; *++top = (x % 10) ^ 48, x /= 10; &#125;while(x); while(top != tmp) *s++ = *top--; *s++ = 32; return *this; &#125; ~OUTPUT()&#123; fwrite(buf, 1, s - buf, stdout); &#125;&#125;fout;#define N 300010#define inf 1145141919810364364llint n;int C[N], D[N];struct QRY&#123; int x, y, w, tp; QRY(int _x = 0, int _y = 0, int _w = 0, int _tp = 0): x(_x), y(_y), w(_w), tp(_tp)&#123;&#125; inline bool operator &lt;(const QRY &amp;r)const&#123; return x == r.x ? (tp == r.tp ? y &gt; r.y : tp &lt; r.tp) : x &lt; r.x; &#125;&#125;Q[N &lt;&lt; 1];int qc;struct BIT&#123; i64 a[N]; inline void upd(int x, const i64 &amp;v)&#123; for(; x; x -= (-x) &amp; x) chkmax(a[x], v); &#125; inline i64 qry(int x)&#123; reg i64 v(-inf); for(; x &lt;= n; x += (-x) &amp; x) chkmax(v, a[x]); return v; &#125;&#125;B;int main() &#123; fin &gt;&gt; n; FOR(i, 1, n) fin &gt;&gt; C[i]; FOR(i, 1, n) fin &gt;&gt; D[i]; FOR(i, 1, n)&#123; Q[++qc] = QRY(i + 1, i + C[i] - 1, D[i], 0); Q[++qc] = QRY(i - C[i] + 1, i - 1, D[i], 1); &#125; sort(Q + 1, Q + qc + 1); const QRY *ed(Q + qc + 1); reg QRY *t(Q + 1); while(t != ed &amp;&amp; t-&gt;x &lt; 1) ++t; FOR(i, 1, n)&#123; for(; t != ed &amp;&amp; t-&gt;x &lt;= i; ++t)&#123; // if(t-&gt;tp) B.upd(t-&gt;y, B.qry(t-&gt;y + 1) + t-&gt;w); // else B.upd(t-&gt;y, B.qry(t-&gt;y) + t-&gt;w); B.upd(t-&gt;y, B.qry(t-&gt;y + t-&gt;tp) + t-&gt;w); &#125; fout &lt;&lt; B.qry(i) + (C[i] == 1 ? D[i] : 0); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>log数据结构</tag>
        <tag>GYM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「GYM102059D」Dumae]]></title>
    <url>%2Fblog%2FGYM102059D%2F</url>
    <content type="text"><![CDATA[题意简述GYM102059D 构造一个 $n$ 的排列 $p$，要求 $p_i\in[l_i, r_i]$ 且满足 $m$ 个限制 $(u, v)$，表示 $p_{u} &lt; p_{v}$。$n\le 3\times 10^5, m\le 10^6$，需判断无解。 主要思路首先如果没有 $(u, v)$ 的限制，直接从左到右贪心选择右端点最小的即可。假设有限制 $(u, v)$，可以令 $l_v\gets max\{l_v, l_u + 1\}, r_u\gets \{r_u, r_v - 1\}$。容易发现在这样操作后，$u$ 必定在 $v$ 之前被选择。如果有多个限制，按拓扑序处理即可。时间复杂度 $O(n\log n + m)$。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define MMR (1 &lt;&lt; 23)struct INPUT&#123; char buf[MMR], *s, *t; INPUT()&#123; t = (s = buf) + fread(buf, 1, MMR, stdin); &#125; #define gc() (s == t ? \ (t = (s = buf) + fread(buf, 1, MMR, stdin), \ s == t ? -1 : *s++) : *s++) inline INPUT&amp; operator &gt;&gt;(int &amp;x)&#123; x = 0; reg char c(gc()); while(c &lt; 48) c = gc(); while(c &gt; 47) x = x * 10 + c - 48, c = gc(); return *this; &#125;&#125;fin;struct OUTPUT&#123; char buf[MMR], *s; OUTPUT()&#123; s = buf; &#125; inline OUTPUT&amp; operator &lt;&lt;(int x)&#123; static int tmp[10]; Rint *top = tmp; do&#123; *++top = (x % 10) ^ 48, x /= 10; &#125;while(x); while(top != tmp) *s++ = *top--; *s++ = 10; return *this; &#125; ~OUTPUT()&#123; fwrite(buf, 1, s - buf, stdout); &#125;&#125;fout;#define N 300010#define M 1000010struct segment&#123; int l, r, i; inline segment(): l(0), r(0), i(0)&#123;&#125; inline segment(const int &amp;_l, const int &amp;_r, const int &amp;_i) : l(_l), r(_r), i(_i)&#123;&#125; inline bool operator &lt;(const segment &amp;x)const&#123; return r &gt; x.r; &#125;&#125;s[N];int n, m;int ind[N], ans[N];vector&lt;int&gt; E[N];int Q[N];priority_queue&lt;segment&gt; P;inline void topo()&#123; Rint *ql(Q), *qr(Q); FOR(i, 1, n) !ind[i] &amp;&amp; (*qr++ = i); while(ql != qr)&#123; Rint u = *ql++; for(Rint v: E[u]) !--ind[v] &amp;&amp; (*qr++ = v); &#125; Rint *t(Q); while(t != qr)&#123; Rint u = *t++; for(Rint v: E[u]) chkmax(s[v].l, s[u].l + 1); &#125; while(t != Q)&#123; Rint u = *--t; for(Rint v: E[u]) chkmin(s[u].r, s[v].r - 1); &#125;&#125;int main() &#123; fin &gt;&gt; n &gt;&gt; m; FOR(i, 1, n) fin &gt;&gt; s[i].l &gt;&gt; s[i].r, s[i].i = i; Rint u, v; FOR(i, 1, m)&#123; fin &gt;&gt; u &gt;&gt; v; E[u].push_back(v); ++ind[v]; &#125; topo(); FOR(i, 1, n) if(ind[i] || s[i].l &gt; s[i].r) return puts("-1"), 0; sort(s + 1, s + n + 1, [&amp;](const segment &amp;lhs, const segment &amp;rhs)&#123; return lhs.l == rhs.l ? lhs.i &lt; rhs.i: lhs.l &lt; rhs.l; &#125;); reg segment *t(s + 1), res; const segment *ed_t(s + n + 1); FOR(i, 1, n)&#123; while(t != ed_t &amp;&amp; t-&gt;l &lt;= i) P.push(*t++); if(P.empty()) return puts("-1"), 0; res = P.top(), P.pop(); if(res.r &lt; i) return puts("-1"), 0; ans[i] = res.i; &#125; FOR(i, 1, n) fout &lt;&lt; ans[i]; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>GYM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「GYM102059C」Dstorv]]></title>
    <url>%2Fblog%2FGYM102059C%2F</url>
    <content type="text"><![CDATA[题意简述GYM 102059C 数轴上有 $n$ 个人，每人以相同速度向左或右移动。两人相遇则会有一人消失。向左的人消失概率为 $h$，向右的人消失概率为 $r = 1 - h$。给定每个人的移动方向，求最终恰好剩下 $A$ 个向左的人和 $B$ 个向右的人的概率。（$n\le 5000$。） 主要思路注意到每种最终的状态都有唯一的分界点，其左边全都是向左的人，右边全都是向右的人。 不妨考虑 dp 出每个前缀剩下 $A$ 个向左的人的概率，每个后缀剩下 $B$ 个向右的人的概率，然后枚举分界点求出答案。 这里以前缀为例，设 $f(i, j)$ 表示前 $i$ 个人右边加上 $j$ 个向左的人后，剩余 $A$ 个向左的人的概率。 考虑第 $i$ 个人的方向： 向左，则 $f(i, j) = f(i - 1, j + 1)$。 向右，则 $f(i, j) = [j &gt; 0]\cdot(h\cdot f(i, j - 1) + r\cdot f(i - 1, j))$。 显然有初始 $f(0, A) = 1$。于是轻松愉快地获得了 $O(n^2)$ 复杂度。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;#define Templ(T) template &lt;typename T&gt;inline int read() &#123; Rint ans = 0; reg char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) ans = ans * 10 + c - '0'; return ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define mod 1000000007inline int ksm(int x, int y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = 1ll * x * x % mod) if (y &amp; 1) res = 1ll * res * x % mod; return res;&#125;inline void qmo(int &amp;x)&#123; x += x &gt;&gt; 31 &amp; mod; &#125;&#125; // namespace my_stdusing namespace my_std;#define N 5010inline int init_n()&#123; return read();&#125;inline int init_R()&#123; int a(read()), b(read()); return (i64)a * ksm(a + b, mod - 2) % mod;&#125;inline int init_H(const int &amp;r)&#123; int a = 1 - r; qmo(a); return a;&#125;const int n(init_n());const i64 R(init_R()), H(init_H(R));//R: right, H: leftint rf[N][N], hf[N][N];int Rl, Hl;char s[N];int main() &#123; scanf("%s", s + 1); Rl = read(), Hl = read(); hf[0][Hl] = 1; FOR(i, 1, n)&#123; if(s[i] == 'H')&#123; // FOR(j, 0, n) hf[i][j] = hf[i - 1][j + 1]; memcpy(hf[i], hf[i - 1] + 1, sizeof(int) * (n + 1)); &#125;else&#123; FOR(j, 1, n)&#123; hf[i][j] = (R * hf[i - 1][j] + H * hf[i][j - 1]) % mod; &#125; &#125; &#125; rf[n + 1][Rl] = 1; ROF(i, n, 1)&#123; if(s[i] == 'R')&#123; // FOR(j, 0, n) rf[i][j] = rf[i + 1][j + 1]; memcpy(rf[i], rf[i + 1] + 1, sizeof(int) * (n + 1)); &#125;else&#123; FOR(j, 1, n)&#123; rf[i][j] = (H * rf[i + 1][j] + R * rf[i][j - 1]) % mod; &#125; &#125; &#125; Rint res(0); FOR(i, 0, n) qmo(res += (i64)hf[i][0] * rf[i + 1][0] % mod - mod); printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>GYM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「GYM102059B」Dev, Please Add This!]]></title>
    <url>%2Fblog%2FGYM102059B%2F</url>
    <content type="text"><![CDATA[由于一些不明原因，俺的同学们都开始搞杂题选蒋，所以我也来胡几个题（ 题意简述GYM 102059B $n\times m$ 的网格，网格上有一些障碍和星星，以及一个球。每次移动可以令球上下左右任意方向滚动直到撞到边界或障碍停下。球在移动过程中会收集经过的星星。求是否能收集所有星星。$n, m\le 50$。 主要思路每个格子向其四个方向能到达的格子连边。缩点。 注意到每个格子向左右走到的格子必定属于一个强连通分量，上下也是。且一个星星能被收集当且仅当路径经过这两个强连通分量的至少一个。 这是一个 2-SAT 问题： 每个星星对应的两个强连通分量至少有一个被选择。 每一对选择的强连通分量都可达。 每个选择的强连通分量都从起点可达。 时间复杂度 $O(n^2m^2)$，但显然不满，感觉开 200 都绰绰有余。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define N 55#define M 2505typedef unsigned long long u64;struct MyB&#123; #define W 40 u64 a[W]; inline void reset()&#123; FOR(i, 0, W - 1) a[i] = 0; &#125; inline void set(int x)&#123; a[x &gt;&gt; 6] |= 1ull &lt;&lt; (x &amp; 63); &#125; MyB()&#123; reset(); &#125; inline MyB operator |(const MyB &amp;rhs)const&#123; reg MyB res; FOR(i, 0, W - 1) res.a[i] = a[i] | rhs.a[i]; return res; &#125; inline MyB operator |=(const MyB &amp;rhs)&#123; FOR(i, 0, W - 1) a[i] |= rhs.a[i]; return *this; &#125; inline bool operator [](const int &amp;x)const&#123; return (a[x &gt;&gt; 6] &gt;&gt; (x &amp; 63)) &amp; 1; &#125; #undef W&#125;;int n, m;char str[N][N];int Lx[N][N], Ux[N][N], id[N][N];vector&lt;int&gt; E[M];int bx, by;inline void Init()&#123; scanf("%d%d", &amp;n, &amp;m); FOR(i, 1, n) scanf("%s", str[i] + 1); FOR(i, 1, n) str[i][0] = str[i][m + 1] = '#'; FOR(i, 1, m) str[0][i] = str[n + 1][i] = '#'; // FOR(i, 0, n + 1) FOR(j, 0, m + 1) printf("%c%c", str[i][j], " \n"[j == m + 1]); FOR(i, 1, n) FOR(j, 1, m)&#123; id[i][j] = (j == 1 ? id[i - 1][m] : id[i][j - 1]) + 1; if(str[i][j] == 'O') bx = i, by = j; &#125; ROF(i, n, 1) ROF(j, m, 1)&#123; if(str[i][j + 1] == '#') Lx[i][j] = j; else E[id[i][j]].push_back(id[i][Lx[i][j] = Lx[i][j + 1]]); if(str[i + 1][j] == '#') Ux[i][j] = i; else E[id[i][j]].push_back(id[Ux[i][j] = Ux[i + 1][j]][j]); &#125; // FOR(i, 1, n) FOR(j, 1, m) printf("%d%c", Lx[i][j], " \n"[j == m]); // FOR(i, 1, n) FOR(j, 1, m) printf("%d%c", Ux[i][j], " \n"[j == m]); memset(Lx, 0, sizeof(Lx)), memset(Ux, 0, sizeof(Ux)); FOR(i, 1, n) FOR(j, 1, m)&#123; if(str[i][j - 1] == '#') Lx[i][j] = j; else E[id[i][j]].push_back(id[i][Lx[i][j] = Lx[i][j - 1]]); if(str[i - 1][j] == '#') Ux[i][j] = i; else E[id[i][j]].push_back(id[Ux[i][j] = Ux[i - 1][j]][j]); &#125; // FOR(i, 1, n) FOR(j, 1, m) printf("%d%c", Lx[i][j], " \n"[j == m]); // FOR(i, 1, n) FOR(j, 1, m) printf("%d%c", Ux[i][j], " \n"[j == m]);&#125;namespace TAR&#123;int dfn[M], low[M], dcnt, scc[M], scnt;int st[M], *tp(st);bool ins[M], vis[M];void tarjan(const int &amp;u)&#123; dfn[u] = low[u] = ++dcnt; *tp++ = u, ins[u] = 1; for(Rint v: E[u])&#123; if(!dfn[v]) tarjan(v), chkmin(low[u], low[v]); else if(ins[v]) chkmin(low[u], dfn[v]); &#125; if(low[u] == dfn[u])&#123; ++scnt; while(*--tp != u)&#123; scc[*tp] = scnt, ins[*tp] = 0; &#125; scc[*tp] = scnt, ins[*tp] = 0; &#125;&#125;vector&lt;int&gt; obj[M];MyB clo[M];void trans(const int &amp;U)&#123; // clo[U].set(U); #define V scc[v] vis[U] = 1; for(Rint u: obj[U]) for(Rint v: E[u]) if(U != V)&#123; if(!vis[V]) trans(V); clo[U] |= clo[V]; &#125; #undef V&#125;inline int Tr_Cl()&#123;//Transitive closure tarjan(id[bx][by]); FOR(i, 1, n) FOR(j, 1, m) obj[scc[id[i][j]]].push_back(id[i][j]); FOR(i, 1, scnt) clo[i].set(i); trans(scc[id[bx][by]]); return scnt;&#125;&#125;MyB *con(TAR::clo);namespace Ni_SAT&#123;int sc;MyB clo[M];inline bool build()&#123; FOR(i, 2, sc &lt;&lt; 1 | 1) clo[i].set(i); FOR(i, 1, sc) FOR(j, i + 1, sc) if(!con[i][j] &amp;&amp; !con[j][i])&#123; clo[i &lt;&lt; 1].set(j &lt;&lt; 1 | 1), clo[j &lt;&lt; 1].set(i &lt;&lt; 1 | 1); &#125; FOR(i, 1, n) FOR(j, 1, m) if(str[i][j] == '*')&#123; Rint L(TAR::scc[id[i][Lx[i][j]]]), U(TAR::scc[id[Ux[i][j]][j]]); if(!L &amp;&amp; !U) return 0; if(L == U) clo[L &lt;&lt; 1 | 1].set(L &lt;&lt; 1); else if(!U) clo[L &lt;&lt; 1 | 1].set(L &lt;&lt; 1); else if(!L) clo[U &lt;&lt; 1 | 1].set(U &lt;&lt; 1); else clo[L &lt;&lt; 1 | 1].set(U &lt;&lt; 1), clo[U &lt;&lt; 1 | 1].set(L &lt;&lt; 1); &#125; return 1;&#125;inline void Tr_Cl()&#123; FOR(i, 2, sc &lt;&lt; 1 | 1) FOR(j, 2, sc &lt;&lt; 1 | 1)&#123; if(clo[j][i]) clo[j] |= clo[i]; &#125;&#125;&#125;MyB *B(Ni_SAT::clo);int main() &#123; Init(); Ni_SAT::sc = TAR::Tr_Cl(); // printf("sc: %d\n", Ni_SAT::sc); // FOR(i, 1, n) FOR(j, 1, m) printf("%d%c", TAR::scc[id[i][j]], " \n"[j == m]); if(!Ni_SAT::build()) return puts("NO"), 0; Ni_SAT::Tr_Cl(); FOR(i, 1, Ni_SAT::sc)&#123; if(B[i &lt;&lt; 1][i &lt;&lt; 1 | 1] &amp;&amp; B[i &lt;&lt; 1 | 1][i &lt;&lt; 1])&#123; return puts("NO"), 0; &#125; &#125; return puts("YES"), 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>2-SAT</tag>
        <tag>GYM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CTS2019」重复]]></title>
    <url>%2Fblog%2FCTS2019D2T2%2F</url>
    <content type="text"><![CDATA[题意简述LOJ 3123 给个串 $s$，求有多少个长为 $m$ 的串，无限次重复后能找到一个长为 $|s|$ 的字典序小于 $s$ 的子串。小写字母，$|s|, m\le 2000$。 主要思路设 $n = |s|$ 与 $m$ 同阶。看到 rqy 的题解搞了一个 $O(n\operatorname{poly}(n))$ 的做法，然后我比较菜没看懂，于是采用了比较多人用的 kmp 做法。 首先给 $s$ 建 kmp 自动机，考虑把一个串 $t$ 扔到上面跑，判断是否合法。发现加入一个字符 $c$ 时，如果当前位置的 fail 树上的祖先存在一个点的下一个位置大于 $c$，直接返回合法。 所以考虑统计不合法串的个数。 此时自动机变成这样：对于每个点，存在一个字符 $c$，使得下一个字符是 $c$ 时会指向某个位置，大于 $c$ 时会指向原点，小于 $c$ 时则转移不存在。 考虑一个不合法串 $t$，若其重复足够多次后在自动机上匹配到状态 $pos$，那么走 $m$ 步仍然会回到 $pos$。 于是可以求出 $dp(i, j)$ 表示从原点走 $i$ 步走到 $j$ 的方案数，然后枚举位置 $pos$，枚举走了几步才第一次走到原点，然后用 dp 数组计算答案。 复杂度 $O(nm)$。 这种东西场上我一辈子都想不出来罢 参考代码细节见代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define mod 998244353inline int ksm(int x, int y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = 1ll * x * x % mod) if (y &amp; 1) res = 1ll * res * x % mod; return res;&#125;inline void qmo(int &amp;x)&#123; x += x &gt;&gt; 31 &amp; mod; &#125;&#125; // namespace my_stdusing namespace my_std;#define N 2020int n, m, ans;char s[N];int nxt[N], to[N], mx[N];int f[N][N], g[N][N], len;inline void build()&#123; Rint j(0); for(Rint i = 2; i &lt;= n;)&#123; while(j &amp;&amp; s[i] != s[j + 1]) j = nxt[j]; if(s[i] == s[j + 1]) ++j; nxt[i++] = j; &#125; for(Rint i = 0; i &lt;= n; ++i)&#123; Rint k(i == n ? nxt[i] : i); mx[i] = s[k + 1] - 97; to[i] = k + 1; while(k)&#123; k = nxt[k]; if(chkmax(mx[i], s[k + 1] - 97)) to[i] = k + 1; &#125; if(to[i] != i + 1) len = i - to[n = i] + 1; &#125;&#125;int main() &#123; scanf("%d%s", &amp;m, s + 1); n = strlen(s + 1); build(); f[0][0] = 1; FOR(i, 1, m) FOR(j, 0, n)&#123; qmo(f[i][to[j]] += f[i - 1][j] - mod); qmo(f[i][0] += (25ll - mx[j]) * f[i - 1][j] % mod - mod); &#125; FOR(i, 0, n) g[1][i] = 25 - mx[i]; FOR(i, 2, m) FOR(j, 0, n) g[i][j] = g[i - 1][to[j]]; Rint ans(!(m % len) ? len : 0); FOR(i, 0, m) FOR(j, 0, n) qmo(ans += (i64)f[i][j] * g[m - i][j] % mod - mod); qmo(ans = ksm(26, m) - ans); printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>字符串</tag>
        <tag>CTSC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CTSC2018」青蕈领主]]></title>
    <url>%2Fblog%2FCTSC2018D1T3%2F</url>
    <content type="text"><![CDATA[题意简述LOJ 2554 一个排列，给出右端点为 $i$ 的最长连续段长度 $L_i$，求可能的排列总数对 $998244353$ 取模。不超过 $100$ 组数据，$n\le 5\times 10^4$。 主要思路下称「非平凡连续段」为长度大于一的连续段。由于连续段的交与并也是连续段，因此一个合法的输入连边相交线段应当构成一个树形结构。考虑一个节点的子树，其对应的区间值域连续，且其不能出现在更大的连续区间中，因此可以等效地看成一个数。因此，记 $f_n$ 为长度为 $n$ 的，去掉最后一个元素后不存在非平凡连续段的排列个数，$son_n$ 表示点 $n$ 的子节点个数。则答案为 $\prod\limits_{i=1}^{n}f_{son_i}$。 现在我们考虑如何求出 $f$。去掉最后一个元素后不存在非平凡连续段的排列的逆排列即不存在不包含最大值的非平凡连续段的排列，显然其个数与不存在不包含最小值的非平凡连续段的排列相同。那么考虑加上排列的最小值，此时排列长度为 $n+1$。 排列原先已满足不存在不包含最小值的非平凡连续段。那么只需不与次小值相邻即可，故有 $n - 1$ 个插入位置。 排列原先存在不包含最小值的非平凡连续段。枚举其中不包含最小值的非平凡连续段的最大长度 $j$($j\in[2, n - 2]$)，其值域应不包含最小值 $2$，共 $n - j - 1$ 种取值。插入最小值 $1$ 后，该区间及全局都不再存在不包含最小值的非平凡连续段，故可行的排列数为 $f_jf_{n-j}$。 于是递推式即为 $f_n = (n-1)f_{n-1} +\sum\limits_{j=2}^{n-2}(n-j-1)f_jf_{n-j}$。分治 FFT 即可。 参考代码这个分治 FFT 由于是自己更新自己的，如果按照正常方法，左端点为整个分治的左端点时会有部分未处理完全，就会出问题。所以要改一改，具体都写在代码里了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;typedef unsigned long long u64;#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define mod 998244353inline int ksm(int x, int y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = (i64)x * x % mod) if (y &amp; 1) res = (i64)res * x % mod; return res;&#125;inline void qmo(int &amp;x)&#123; x += (x &gt;&gt; 31) &amp; mod; &#125;&#125; // namespace my_stdusing namespace my_std;#define MMR (1 &lt;&lt; 23)struct INPUT&#123; char buf[MMR], *s, *t; INPUT()&#123; t = (s = buf) + fread(buf, 1, MMR, stdin); &#125; #define gc() (s == t ? \ (t = (s = buf) + fread(buf, 1, MMR, stdin), \ s == t ? -1 : *s++) : *s++) inline INPUT&amp; operator &gt;&gt;(int &amp;x)&#123; x = 0; reg char c(gc()); while(c &lt; 48) c = gc(); while(c &gt; 47) x = x * 10 + c - 48, c = gc(); return *this; &#125;&#125;fin;struct OUTPUT&#123; char buf[MMR], *s; OUTPUT()&#123; s = buf; &#125; inline OUTPUT&amp; operator &lt;&lt;(int x)&#123; static int tmp[16]; Rint *top = tmp; do&#123; *++top = (x % 10) ^ 48, x /= 10; &#125;while(x); while(top != tmp) *s++ = *top--; *s++ = 10; return *this; &#125; inline void operator ++()&#123; *s++ = 48, *s++ = 10; &#125; ~OUTPUT()&#123; fwrite(buf, 1, s - buf, stdout); &#125;&#125;fout;#define N 131131int LMT(1);int rev[N], omg[N], l2g[N];inline void init(const int &amp;n)&#123; FOR(i, 2, n &lt;&lt; 1) l2g[i] = l2g[i &gt;&gt; 1] + 1;&#125;inline void poly_init(const int &amp;n)&#123; Rint l(0); while(LMT &lt;= n) LMT &lt;&lt;= 1, ++l; FOR(i, 1, LMT - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)); reg const i64 t(ksm(3, (mod - 1) &gt;&gt; l)); omg[LMT &gt;&gt; 1] = 1; FOR(i, (LMT &gt;&gt; 1) + 1, LMT - 1) omg[i] = t * omg[i - 1] % mod; ROF(i, (LMT &gt;&gt; 1) - 1, 1) omg[i] = omg[i &lt;&lt; 1]; LMT = l;&#125;inline int get_len(const int &amp;n)&#123; return 1 &lt;&lt; (l2g[n] + 1);&#125;inline void DFT(int *a, const int &amp;n)&#123; static u64 tmp[N]; reg const int fix(LMT - l2g[n]); Rint t; FOR(i, 0, n - 1) tmp[i] = a[rev[i] &gt;&gt; fix]; for(Rint i(1); i &lt; n; i &lt;&lt;= 1)&#123; for(Rint j(0); j &lt; n; j += i &lt;&lt; 1)&#123; FOR(k, j, j + i - 1)&#123; t = tmp[i + k] * omg[i + k - j] % mod; tmp[i + k] = tmp[k] + mod - t; tmp[k] += t; &#125; &#125; &#125; FOR(i, 0, n - 1) a[i] = tmp[i] % mod;&#125;inline void IDFT(int *a, const int &amp;n)&#123; reverse(a + 1, a + n); DFT(a, n); reg const i64 bk(mod - (mod - 1) / n); FOR(i, 0, n - 1) a[i] = bk * a[i] % mod;&#125;int n;int f[N];int tmp[N];#define mst(A, B, C) memset((A), (B), (C) * sizeof(int))#define mcp(A, B, C) memcpy((A), (B), (C) * sizeof(int))void dac(const int &amp;l, const int &amp;r)&#123; if(l == r)&#123; qmo(f[l] += (3ll + mod - l) * f[l - 1] % mod - mod); return; &#125; static int A[N], B[N]; Rint mid((l + r) &gt;&gt; 1), lim(get_len(r - l + 1)); dac(l, mid); mst(A, 0, lim), mst(B, 0, lim); if(l == 1)&#123; FOR(i, 1, mid) A[i - 1] = (i - 1ll) * f[i] % mod, B[i] = f[i]; if(lim &lt;= 24)&#123; mst(tmp, 0, lim); FOR(i, 0, (lim) - 1) FOR(j, 0, (lim) - 1) qmo(tmp[i + j] += (i64)A[i] * B[j] % mod - mod); FOR(i, mid + 1, r) qmo(f[i] += tmp[i - 1] - mod); &#125;else&#123; DFT(A, lim), DFT(B, lim); FOR(i, 0, lim - 1) A[i] = (i64)A[i] * B[i] % mod; IDFT(A, lim); FOR(i, mid + 1, r) qmo(f[i] += A[i - 1] - mod); &#125; &#125;else&#123; mcp(A, f + l, mid + 1 - l); mcp(B + 1, f + 1, r - l); if(lim &lt;= 24)&#123; mst(tmp, 0, lim); FOR(i, 0, (lim) - 1) FOR(j, 0, (lim) - 1) qmo(tmp[i + j] += (i64)A[i] * B[j] % mod - mod); FOR(i, mid + 1, r) qmo(f[i] += tmp[i - l] * (i - 2ll) % mod - mod); &#125;else&#123; DFT(A, lim), DFT(B, lim); FOR(i, 0, lim - 1) A[i] = (i64)A[i] * B[i] % mod; IDFT(A, lim); FOR(i, mid + 1, r) qmo(f[i] += A[i - l] * (i - 2ll) % mod - mod); &#125; &#125; dac(mid + 1, r);&#125;int a[N];int c[N];int d[N];inline void work()&#123; FOR(i, 1, n) fin &gt;&gt; a[i]; if(a[n] != n) return ++fout; Rint *t(d); mst(c, 0, n); Rint g, r, mx(0); FOR(i, 1, n)&#123; g = 0, r = i; while(d != t &amp;&amp; *t &gt;= i - a[i] + 1) ++g, r = *t--; if(r - a[r] &lt; i - a[i]) return ++fout; chkmax(mx, g); ++c[g], *++t = i; &#125; Rint A(1); FOR(i, 1, mx) A = (i64)A * ksm(f[i], c[i]) % mod; fout &lt;&lt; A;&#125;int main() &#123; Rint esac; fin &gt;&gt; esac &gt;&gt; n; init(n), poly_init(n &lt;&lt; 1); f[1] = 2, dac(1, n), f[0] = 1; while(esac --) work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>CTSC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JOI2019Final」独特的城市]]></title>
    <url>%2Fblog%2FJOIF2019T5%2F</url>
    <content type="text"><![CDATA[题意简述LOJ 3014 一棵树 $n$ 个点，点有颜色 $c_i$。对于每个点，求出以其为根时，所有没有其他深度相同点的点的不同颜色个数。$n\le 2\times 10^5$。 主要思路不妨称在某个点为根时没有其他深度相同点的点为该点的合法点。那么显然一个点的合法点在其到它最远点的路径上。最远点显然是直径端点之一，故只需对直径两端点提为根做一次。 那么此时一个点只需要关心它到根路径上的点了。这条路径上哪些点是合法的呢？考虑一条从这条路径上的点开始的往下的路径，显然该点上方的路径长度个点都不合法。最后剩下的就是合法的。 dfs，用栈维护当前合法的点，用桶维护每种颜色的出现次数。长链剖分，先往重儿子走（用轻儿子的最大深度弹栈），再往轻儿子走（用重儿子最大深度弹栈）。注意到这样可以不必撤销——假设现在 dfs 到某点，走到某个儿子时若某个祖先被弹掉，该祖先在该儿子及其他儿子的子树内都应被弹掉。但是有一个例外就是该点本身可能被弹掉后在别处仍合法，所以 dfs 一个儿子后要重新加回去。总入栈次数 $O(n)$，故复杂度 $O(n)$。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define MMR (1 &lt;&lt; 23)struct INPUT&#123; char buf[MMR], *s; INPUT()&#123; s = buf, fread(buf, 1, MMR, stdin); &#125; inline INPUT&amp; operator &gt;&gt;(int &amp;x)&#123; x = 0; while(*s &lt; 48) ++s; while(*s &gt; 47) x = x * 10 + *s++ - 48; return *this; &#125;&#125;fin;struct OUTPUT&#123; char buf[MMR], *s; OUTPUT()&#123; s = buf; &#125; inline OUTPUT&amp; operator &lt;&lt;(int x)&#123; static int tmp[10]; Rint *top = tmp; do&#123; *++top = (x % 10) ^ 48, x /= 10; &#125;while(x); while(top != tmp) *s++ = *top--; *s++ = 10; return *this; &#125; ~OUTPUT()&#123; fwrite(buf, 1, s - buf, stdout); &#125;&#125;fout;#define N 200010int n, m;vector&lt;int&gt; E[N];int c[N], a[N], ans[N];int dep[N], son[N], len[N];void init(int u, int f, int &amp;S)&#123; dep[u] = dep[f] + 1; if(dep[S] &lt; dep[u]) S = u; for(Rint v: E[u]) if(v != f) init(v, u, S);&#125;void dfs1(int u, int f)&#123; dep[u] = dep[f] + 1; son[u] = len[u] = 0; for(Rint v: E[u])&#123; if(v == f) continue; dfs1(v, u); if(len[v] &gt; len[son[u]]) son[u] = v; &#125; len[u] = len[son[u]] + 1;&#125;int st[N];int g, *tp = st, *tg = st;//tp 是当前栈顶，tg 是当前栈中最靠近栈顶的未被实际扔掉的位置#define add(x) (g += (++c[a[x]] == 1))#define del(x) (g -= (--c[a[x]] == 0))void dfs2(int u, int f)&#123; while(tg != tp &amp;&amp; dep[u] - dep[*(tg + 1)] &gt; len[u] - 1) add(*++tg); //更新未被实际扔掉的最靠近栈顶的位置 chkmax(ans[u], g); if(!son[u]) return; Rint ll(0); for(Rint v: E[u]) if(v != f &amp;&amp; v != son[u]) chkmax(ll, len[v]); while(tp != st &amp;&amp; dep[u] - dep[*tp] &lt;= ll) (tg == tp) &amp;&amp; del(*tg--), --tp; //弹掉距离 u 不超过次长链长度的点 *++tp = u; dfs2(son[u], u); for(Rint v: E[u])&#123; if(v == f || v == son[u]) continue; while(tp != st &amp;&amp; dep[u] - dep[*tp] &lt;= len[u] - 1) (tg == tp) &amp;&amp; del(*tg--), --tp; //弹掉距离 u 不超过最长链长度的点 if(*tp != u) *++tp = u; //u 可能不需要弹掉 dfs2(v, u); &#125; //不必把栈内留存的 u 子树内的点弹掉 //因为会在考虑到 u 的兄弟时弹掉&#125;inline void sol(int S)&#123; dfs1(S, 0); memset(c, 0, sizeof(c)); g = 0, tg = tp = st; dfs2(S, 0);&#125;int main() &#123; fin &gt;&gt; n &gt;&gt; m; Rint u, v; FOR(i, 1, n - 1)&#123; fin &gt;&gt; u &gt;&gt; v; E[u].push_back(v), E[v].push_back(u); &#125; FOR(i, 1, n) fin &gt;&gt; a[i]; Rint S(0), T(0); init(1, 0, S), init(S, 0, T); sol(S), sol(T); FOR(i, 1, n) fout &lt;&lt; ans[i]; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树论</tag>
        <tag>JOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JOI2017Final」绳]]></title>
    <url>%2Fblog%2FJOIF2017T5%2F</url>
    <content type="text"><![CDATA[所以标题到底应不应该空格啊 题意简述LOJ 2336 一根绳子，长为 $n$，初始绳子上每个单位长度有一个颜色。可以把绳子沿两个单位长度之间折起来，但要求折起来后对应的位置颜色相同。可以花费该单位长度绳子厚度的代价对某个单位长度染任意色。对于每种初始在绳子上的颜色，求将绳子折起来后能够只剩两个单位长度且有位置为该颜色的最小代价。$n\le 2\times 10^6$。 主要思路显然先染色不劣（有厚度影响），并且最开始染色后只会保留两种颜色。发现折绳子等价于将边上的颜色连续段长度减少 1，或者把对称点所在的连续段长度减半并将其到边上的绳子删去（即其变到边上）。所以初始状态必须除了边上的颜色连续段长度都为偶数，容易证明其充分性。于是对于某种需要保留的颜色，枚举最左边颜色连续段的奇偶性，即可知道每个该颜色连续段是否要向左右伸展一格。然后在剩下的位置中找个众数留下来即可。通过 $O(1)$ 删加点 $O(1)$ 求众数的 trick 就可以做到 $O(n)$。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define MMR (1 &lt;&lt; 23)struct INPUT&#123; char buf[MMR], *s, *t; INPUT()&#123; s = buf, fread(buf, 1, MMR, stdin); &#125; inline INPUT&amp; operator &gt;&gt;(int &amp;x)&#123; x = 0; while(*s &lt; 48) ++s; while(*s &gt; 47) x = x * 10 + *s++ - 48; return *this; &#125;&#125;fin;struct OUTPUT&#123; char buf[MMR], *s; OUTPUT()&#123; s = buf; &#125; inline OUTPUT&amp; operator &lt;&lt;(int x)&#123; static int tmp[10]; Rint *top = tmp; do&#123; *++top = (x % 10) ^ 48, x /= 10; &#125;while(x); while(top != tmp) *s++ = *top--; *s++ = 10; return *this; &#125; ~OUTPUT()&#123; fwrite(buf, 1, s - buf, stdout); &#125;&#125;fout;#define N 1000010int n, m;int a[N], c[N];int fix[N];vector&lt;int&gt; v[N];int ans[N];struct DS&#123; int b[N], g; inline void add(reg const int p)&#123; --b[c[p]]; if(c[p] == g) ++g; ++b[++c[p]]; &#125; inline void del(reg const int p)&#123; --b[c[p]]; if(c[p] == g &amp;&amp; !b[c[p]]) --g; ++b[--c[p]]; &#125;&#125;B;inline void sol()&#123; FOR(p, 1, m)&#123; reg const int C(c[p]); FOR(i, 1, C) B.del(p); for(Rint i: v[p])&#123; if(fix[i] &amp;&amp; a[fix[i]] != p)&#123; B.del(a[fix[i]]); &#125; &#125; chkmin(ans[p], n - C - B.g); for(Rint i: v[p])&#123; if(fix[i] &amp;&amp; a[fix[i]] != p)&#123; B.add(a[fix[i]]); &#125; &#125; FOR(i, 1, C) B.add(p); &#125;&#125;int main() &#123; fin &gt;&gt; n &gt;&gt; m; FOR(i, 1, n)&#123; fin &gt;&gt; a[i]; v[a[i]].push_back(i); &#125; if(m == 1) return fout &lt;&lt; 0, 0; FOR(i, 1, m) ans[i] = n; *B.b = m; FOR(i, 1, n) B.add(a[i]); FOR(i, 1, n) fix[i] = ((i - 1) ^ 1) + 1; if(n &amp; 1) fix[n] = 0; sol(); fix[1] = 0; FOR(i, 2, n) fix[i] = i ^ 1; if(!(n &amp; 1)) fix[n] = 0; sol(); FOR(i, 1, m) fout &lt;&lt; ans[i]; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>JOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JOISC2019」开关游戏]]></title>
    <url>%2Fblog%2FJOISC2019D3T2%2F</url>
    <content type="text"><![CDATA[题意简述LOJ 3037 一列灯 $n$ 个，给定初始状态和目标状态。每次操作可以区间开启/关闭/取反，求最少操作次数从初始状态变为目标状态。$n\le 10^6$。 主要思路注意到若相邻两个是先区间反转再区间赋值，可以简单地通过一些变换使得把两者顺序调换。那么必然存在一个最优操作序列，使得前面全为区间赋值，后面都是区间反转；同时可以有区间赋值操作互不相交。设 $f(i, [0, 2])$ 为处理到第 $i$ 盏灯，钦定这盏灯被赋值为0/1/2(未被赋值)，此时需要的区间反转次数的两倍。简单 dp 即可。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;#define gcr() getchar()inline int read() &#123; reg int ans = 0, f = 1; reg char c = gcr(); while (!isdigit(c)) f ^= (c == '-'), c = gcr(); for (; isdigit(c); c = gcr()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;const int N = 1000010, tr[3][3] = &#123; &#123;0, 2, 1&#125;, &#123;2, 0, 1&#125;, &#123;1, 1, 0&#125;&#125;;int n;char a[1 &lt;&lt; 20], b[1 &lt;&lt; 20];void read_line(char *a)&#123; for(*a = gcr(); *a != 48 &amp;&amp; *a != 49; *a = gcr()); for(; *a == 48 || *a == 49; *++a = gcr());&#125;int f[1 &lt;&lt; 20][3];#define val(x, o) ((o) &amp; 2 ? (a[x] ^ b[x]) : ((o) ^ b[x] ^ 48))int main()&#123; n = read(); read_line(a), read_line(b); a[n] = b[n] = 48; memset(f, 0x3f, sizeof(f)); f[0][2] = *a ^ *b; f[0][0] = 1 + (*b ^ 48); f[0][1] = 1 + (*b ^ 49); FOR(i, 1, n) FOR(k, 0, 2)&#123; FOR(j, 0, 2)&#123; chkmin(f[i][k], f[i - 1][j] + tr[j][k] + (val(i, k) ^ val(i - 1, j))); &#125; &#125; printf("%d\n", f[n][2] &gt;&gt; 1); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>JOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《西哈诺》小感]]></title>
    <url>%2Fblog%2F20200904%2F</url>
    <content type="text"><![CDATA[我们这种人的口袋里，随时都有几封给梦中情人的信。我们的情人不过是随便借个名字，用幻想吹出来的肥皂泡！……把信拿去吧，你可以假戏真做。我本来是无病呻吟，漫无目的地吐露爱情，现在这些飘泊无定的鸟儿有地方栖息了。你可以从信里看出来——拿去吧！——由于不是出自真心，话就说得格外动听！——拿去吧，就这么办！ 这个人终于找到《西哈诺·德·贝热拉克》的原剧本了。 《西哈诺》各个版本中人名的译法差距非常大。本文中人名译法将以本人手上的版本为准。 然后顺便推荐一下纯粹与应用素学研究这篇专栏。 西哈诺的故事可以按照爱情与战斗分成两条主线。 西哈诺才华横溢、文武双全，却因有一个丑陋的大鼻子，不敢对他所爱的罗克桑娜倾诉爱意。 然而罗克桑娜突然主动向西哈诺发出了邀请，他欣喜若狂，一口答应。谁知罗克桑娜对英俊潇洒、风流倜傥的克里斯蒂安一见钟情，要求表哥西哈诺保护克里斯蒂安，维护他们的关系。 西哈诺强忍心中悲痛，选择将悲痛留在心底。他相信让罗克桑娜得到幸福，就是他最大的幸福。 莽撞的克里斯蒂安在部队公然嘲讽西哈诺的大鼻子，令他愤怒到了极点。自尊心极强的西哈诺由于自己心爱的罗克桑娜的要求，不但不能伤害他，甚至还要保护好他。西哈诺不得不克制住了自己，原谅克里斯蒂安。克里斯蒂安被他的宽容大度打动，从此二人成为好友。 然而克里斯蒂安缺乏素养、胸无点墨，他所说的话一定会招致罗克桑娜的反感。西哈诺正好相反，有着满腹才华，却因丑陋的大鼻子令他不被接受。于是，二人一拍即合，这一个借用那一个的外表，那一个注入这一个的灵魂。 西哈诺选择教给克里斯蒂安那些优美的言语，自己却躲进阴影之中，自己的甜言蜜语最终促成的是罗克桑娜与克里斯蒂安的爱情。他对罗克桑娜的爱越热切，与她的距离却越远。但他的自尊与无私要求他这么做——他要给自己的表妹以最高的幸福。 克里斯蒂安夺得罗克桑娜之吻的那个夜晚，西哈诺的感情爆发。他终于可以不用假借他人之口诉说对罗克桑娜的爱意。在夜幕笼罩中，他终于不必自惭形秽，能够自由地对她诉说积压在心中多年的感情了。他此时此刻将自己心中激动的情感满怀激情地、毫无限制地诉说出来。 克里斯蒂安爬上窗台与罗克桑娜相拥，神父秘密举行了二人的婚礼。 西哈诺与克里斯蒂安被发配到战场上，这令西哈诺的孤独感与日俱增。然而不断为罗克桑娜攒写的信件，也仅仅能用克里斯蒂安的名义寄出罢了。最后一战前夕，他为罗克桑娜写最后一封信时，思念结成泪滴，滴在信上。 意想不到的是，罗克桑娜被这些情书深深感动，竟冒险到阵地上看望克里斯蒂安。罗克桑娜表露，自己内心深爱着的其实是克里斯蒂安的灵魂。这使克里斯蒂安无地自容，他决定坦白一切，让西哈诺取回本应属于他自己的爱情。 现在西哈诺只要说出这一真相，就能取回那本属于他的爱情了。可是就在这一刻，克里斯蒂安战死的消息传来。面对逝者，他又能如何说出真相呢？那些言语确实出于西哈诺之手，但他现在绝不能做出损害罗克桑娜心中克里斯蒂安形象的事了。 西哈诺用尽一生之力，最终也只是为别人争取到了幸福。而这幸福即将归于自身的一瞬间，却突然被推进了万丈深渊。战场上的故事便在强烈的悲剧色彩中戛然而止。 西哈诺一直为他的大鼻子而感到自卑。在剧场时他面对前来挑衅的华威尔子爵，不仅讽刺他胸无点墨，还一边吟诗、一边舞剑，诗末一剑将华威尔刺中。西哈诺的机智、风度、勇敢在这场决斗中表现得淋漓尽致。 西哈诺的不畏强权也在剧中得到充分的体现。德吉什为西哈诺争取到话剧表演的机会，并且表示只要西哈诺将他的剧本改动一点点，很可能就能得到上映的机会。然而西哈诺断然拒绝——他即使死去也不愿看到自己的剧作被改动一个标点。他即使死了，也要维护他高傲的荣耀。 德吉什伯爵觊觎罗克桑娜的美貌，在克里斯蒂安夺得罗克桑娜之吻的夜晚，送来最后通牒要求罗克桑娜与他结婚。罗克桑娜假意宣称德吉什希望她与自己心上人克里斯蒂安结婚，于是赶快秘密举行婚礼，由西哈诺展现智慧与德吉什来了一场斗智斗勇，拖到了结婚仪式结束，破坏了德吉什的美梦。 德吉什恼羞成怒，迁怒与西哈诺与克里斯蒂安，抽出军令，将他俩调往了前线。 战争激烈，德吉什只能与西哈诺冰释前嫌、通力合作。最后的决战中，西哈诺请求德吉什用尽一切办法将罗克桑娜和克里斯蒂安的遗体带到安全的地方，然后义无反顾地投入战斗中，战争便在西哈诺在枪林弹雨中的朗诵中落幕。 战争结束后 15 年，早已沧海桑田，物是人非。 罗克桑娜自从战争结束，便进入修道院，开始了隐居生活，十年如一日地怀念失去的克里斯蒂安。西哈诺尽管仍然不向任何人低头，却孤苦无依，一贫如洗。 只有每周六，西哈诺来到修道院，给罗克桑娜讲这周的新闻，她才能从失去丈夫的悲痛中暂时解脱——这就是故事的终章，「西哈诺的新闻报告」。 在一个普通的星期六，却发生了巨变。 西哈诺被一位下人暗算，奄奄一息。他拿来自己写给罗克桑娜的最后一封信，饱含深情地读起来。他终于能够再次将自己的真心毫无保留地献给罗克桑娜。 得知真相的罗克桑娜不顾一切地想向西哈诺诉说他的真情，但身负重伤的西哈诺已经不希望能得到罗克桑娜多少爱，只希望能够了却此生最后的心愿。 他燃尽了最后的生命，举起佩剑，向死神做出了最后的呐喊。他睿智、勇敢、坚毅、痴情，用自己的生命，捍卫了爱情和荣耀。 有评论家将《西哈诺》称为「法国浪漫主义戏剧的绝唱」，我个人是很赞同的。 几位主要人物都塑造得极为饱满：西哈诺的理想主义；克里斯蒂安后期的觉悟；罗克桑娜知晓真相后的不顾一切的诉说。 剧中文字极具诗意，西哈诺的决斗，甚至怎样做杏仁小塔饼都写成风趣小诗。华丽的文字，激情的创作，为整部戏剧增色不少。 结构上，最后一幕采用的「二次结局」手法，令人回味无穷；整部剧的剧情安排紧凑而不刻意，情节跌宕起伏、引人入胜。爱情与战斗的双线索结构，共同构成了西哈诺这一悲剧式的人物——「无所不能」，却又「一事无成」。 西哈诺 勒布雷，我今天要登上乳白色的月球了，不需要发明什么机器……. 罗克桑娜 您在说什么呀？ 西哈诺 是啊，我跟您说，我会被送到那里去建造我的天堂，不止一个我所爱的人大概都被放逐到那里了，我会遇到苏格拉底和伽利略 ！ 勒布雷 （愤慨地）不！不！这实在太愚蠢，太不公平了！这样一位诗人！这么伟大，这么崇高的心灵！就这样死去！……死去！ 西哈诺 勒布雷又在抱怨了！ 勒布雷 （泪流满面）我亲爱的朋友…… 西哈诺 （支撑着站起来，眼神迷乱）这就是加斯科涅的贵族子弟兵……元素的质量……是啊！……这就是关键所在！ 勒布雷 神志昏乱了……还谈他的学问！ 西哈诺 哥白尼说…… 罗克桑娜 噢！ 西哈诺 也说他到底去干什么呢？他到底去双桅战船上干什么呢？ ……哲学家，物理学家，诗人，剑客，音乐家，空中旅行家，针尖对麦芒的辩士，为人作嫁的情人！——赫丘利斯—萨维尼安•西哈诺•德•贝热拉克长眠于此，他无所不能，却一事无成。……对不起，我该走了，我不能让人久等，你们看，月光来接我了！（又跌坐下去，罗克桑娜的哭声使他回到现实。他注视她，抚摸她的面纱）我不要您为迷人、善良、英俊的克里斯蒂安少流些眼泪，我只要您在我尸骨已寒之后，给这黑面纱以双重的意义，让我分享一点您对他的哀悼。 罗克桑娜 我向您发誓！…… 西哈诺 （浑身发抖，猛然立起）不！不！不能在这把椅子上！（众人要冲上去扶他）——别扶我！——谁也别扶！（走到一棵树旁，背靠树干）只要树就行了！（静默）她来了！我已经感到穿上了大理石靴——戴上了铅制的手套！（挺直身子）噢！……既然她在路上，我就站着等她，（抽剑）手中握剑！ 勒布雷 西哈诺！ 罗克桑娜 （支持不住）西哈诺！ 【众人惊恐地朝后退。 西哈诺 我觉得她在看……她竟敢看我的鼻子，这个塌鼻子死神。（举剑）你们说什么？……这没有用？……我知道！可是人不是有胜利的希望才作战的，不！不！知其不可为而为之，这才更漂亮！——这一大堆是什么人呀？——有一千个？啊！我认出来了，都是我的宿敌！“谎言”？（朝空中挥剑）嘿嘿！——哈哈！“妥协”、“偏见”、“懦弱”！……（挥剑）要我让步吗？不！绝不！——啊！你也在这里，“愚蠢”！——我知道你们最后一定会把我打倒，我不在乎：我还是打！还是打！还是打！（把剑舞得似风车一般，然后气喘吁吁地停下来）是的，你们抢走我的一切，桂冠和玫瑰！尽管抢吧！但有一样东西，你们只好任凭我今晚带进天堂，我一行礼就把蔚蓝的入口清扫得纤尘不染，这件东西没有一丝皱褶，没有一个污点，你们只好任凭我把它带走，（高举着剑向前冲）那就是（剑从他手中掉落，他摇晃着身子，跌入勒布雷和拉格诺的怀中。） 罗克桑娜 （俯身吻他的前额）是什么？…… 西哈诺 （睁开眼睛，认出了她，冲她微笑）我帽子上的羽毛！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeChef TRIPS」Children Trips]]></title>
    <url>%2Fblog%2FCC-TRIPS%2F</url>
    <content type="text"><![CDATA[题意简述CodeChef TRIPS 一棵树，边有 $1$ 或 $2$ 的边权，多次询问从点 $u$ 到 $v$，每次移动最多能走 $w$（不能在两点之间停下），要几次才能到达。$n, m\le 10^5$。 主要思路这个题感觉有一车 $O(n\sqrt{n})$ 做法？这里介绍一种在线的树分块做法。设 $M = \sqrt{n}$。先钦定根，定义点 $u$ 的深度 $dep(u)$ 为到根路径上的边数。 那么我们将 $M | dep(u)$ 的节点设为关键点，于是这棵树就被分为若干块（关键点属于其下面的块）。（若一块大小不足 $M$ 跟上面的块合并。） 这样每个块的大小就不小于 $M$，个数就不大于 $M$，且直径最大为 $2M$（此处直径指连通块中两点路径间最多的边的数量）。 显然对于询问 $(u, v, w)$，从两个人两边出发直到碰头所用的总步数和单人走完是相同的。 那么若 $u, v$ 在同一块中，则直接暴力每次将较深的一个往上跳一条边就行了。 若在不同块中，则由于块数量也为 $O(M)$，我们希望一次能够令一个点上跳一个块。 假设点 $u$，一次走的距离为 $i$（$i\le 2M$）。设 $db(u)$ 为到最近的不同块的祖先的距离，$du(u)$ 为到父亲的距离；$rc(u, i)$ 为向上走一次能到达的最远的点；$sp(u, i)$ 表示向上走最少几次能跳出块，$rm(u, i)$ 为最后一次会剩余多少未使用距离。 考虑步长为 $w$，当前向上跳的点为 $u$，根号分治： 对 $w\le 2M$，由于处理了 $sp, rm$，一次可以直接跳出一个块； 对 $w &gt; 2M$，由于块数 $O(M)$，可以把一次移动拆成多次长为 $2M$ 的移动，一步只跳一个块。 预处理？对 $rc$，继承父亲的；对 $sp, rm$ 继承 $rc(u, i)$ 的。嘛还有些讨论细节啥的，不过不重要。 反正这样就 $O(n\sqrt{n})$ 了。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define GO(x, e, i, v) for (register int i = head[x], v; i; i = e[i].link)#define Templ(T) template &lt;typename T&gt;inline int read() &#123; reg int ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) f ^= (c == '-'), c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define N 100010#define BN 350#define M 317#define M2 634#define swap(a, b) (a ^= b ^= a ^= b)struct Edge&#123; int link, to, wgh;&#125;e[N &lt;&lt; 1];int ecnt, head[N];inline void A_E(int u, int v, int w)&#123; e[++ecnt] = (Edge)&#123;head[u], v, w&#125;; head[u] = ecnt;&#125;int n, m;int fth[N], du[N], dep[N], siz[N];int key[BN], bc, bl[N];int sk[N], st;#define TB(u) key[bl[u]]void dfs0(int u)&#123; siz[u] = 1; sk[st++] = u; GO(u, e, i, v)&#123; v = e[i].to; if(v == fth[u]) continue; fth[v] = u, du[v] = e[i].wgh; dep[v] = dep[u] + 1; dfs0(v); siz[u] += siz[v]; &#125; if(!(dep[u] % M) &amp;&amp; siz[u] &gt;= M)&#123; key[++bc] = u, bl[u] = bc; while(sk[--st] != u)&#123; bl[sk[st]] = bc; &#125; &#125;&#125;int rc[N][BN &lt;&lt; 1], db[N], sp[N][BN &lt;&lt; 1], rm[N][BN &lt;&lt; 1];//点 u，跳一次距离 i：//到达的点；与最近的块外祖先距离；跳几步能跳出块；最后一步会剩下多少；void dfs1(int u)&#123; reg const int d(du[u]), f(fth[u]); rc[u][0] = u; rc[u][1] = d == 1 ? f : u; FOR(i, 2, M2)&#123; rc[u][i] = (i &gt;= d) ? rc[f][i - d] : f; &#125; if(bl[u] == bl[f])&#123; Rint v; FOR(i, 2, M2)&#123; v = rc[u][i]; if(bl[u] == bl[v])&#123; sp[u][i] = sp[v][i] + 1; rm[u][i] = rm[v][i]; &#125; else&#123; sp[u][i] = 1; rm[u][i] = rm[f][i] - d; &#125; &#125; db[u] = db[f] + d; &#125; else&#123; FOR(i, 2, M2)&#123; sp[u][i] = 1; rm[u][i] = i - d; &#125; db[u] = d; &#125; GO(u, e, i, v)&#123; v = e[i].to; if(v != f) dfs1(v); &#125;&#125;inline void init()&#123; n = read(); Rint u, v, w; FOR(i, 1, n - 1)&#123; u = read(), v = read(), w = read(); A_E(u, v, w), A_E(v, u, w); &#125; dfs0(1); dfs1(1); m = read();&#125;//同一块中暴力跳inline int queryb(int *u, int *s, const int &amp;p)&#123; int ans(0); while(u[0] != u[1])&#123; if(dep[u[0]] &lt; dep[u[1]]) swap(u[0], u[1]), swap(s[0], s[1]); if(*s &gt;= du[*u]) *s -= du[*u]; else *s = p - du[*u], ++ans; *u = fth[*u]; &#125; if(s[0] + s[1] &gt;= p) --ans; return ans;&#125;//不同块，步长小，一步跳一块inline int query0(int *u, const int &amp;p)&#123; int ans(0), s[2] = &#123;&#125;; while(bl[u[0]] != bl[u[1]])&#123; if(bl[u[0]] &gt; bl[u[1]]) swap(u[0], u[1]), swap(s[0], s[1]); if(db[*u] &gt; *s)&#123; *u = rc[*u][*s]; ans += sp[*u][p], *s = rm[*u][p]; &#125; else *s = rm[*u][*s]; *u = fth[TB(*u)]; &#125; return ans + queryb(u, s, p);&#125;//不同块，步长大，一步跳一块inline int query1(int *u, const int &amp;p)&#123; int ans(0), s[2] = &#123;&#125;; while(bl[u[0]] != bl[u[1]])&#123; if(bl[u[0]] &gt; bl[u[1]]) swap(u[0], u[1]), swap(s[0], s[1]); if(db[*u] &lt;= *s) *s -= db[*u], *u = fth[TB(*u)]; else&#123; if(*s &gt; M2)&#123; *s -= M2 - (rc[*u][M2] == rc[*u][M2 - 1]); *u = rc[*u][M2]; &#125; else *u = rc[*u][*s], ++ans, *s = p; &#125; &#125; return ans + queryb(u, s, p);&#125;int main() &#123; init(); Rint u[2], w; while(m--)&#123; u[0] = read(), u[1] = read(), w = read(); printf("%d\n", (w &lt;= M ? query0 : query1)(u, w)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>CodeChef</tag>
        <tag>树论</tag>
        <tag>树分块</tag>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ARC070D」HonestOrUnkind]]></title>
    <url>%2Fblog%2FARC070D%2F</url>
    <content type="text"><![CDATA[题意简述ARC 070D 交互题。$A$ 个诚实的人和 $B$ 个不诚实的人互相知道各自是否诚实。这些人编号 $[0, A+B)$，你希望判断每个编号的人是否诚实。你可进行不超过 $2n$ 次提问，每次提问可给出两数 $(a,b)$，表示询问 $a$ 号人 $b$ 号人是否诚实。若 $a$ 诚实则他会如实回答，否则他有可能说假话。有无法判断的情况。$1\le A,B\le 2000$。 主要思路若 $A\le B$ 显然无解。那 $B$ 个人总有办法串通起来让你无法判断某人是否诚实。 于是只用考虑 $A&gt;B$ 的情况。 发现若询问 $(a, b)$ 回答不诚实，那么这二人至少有一人不诚实。考虑用一个栈维护，每次新加一个人，若栈不为空则询问栈顶的人新来的人是否诚实。若回答不诚实，则弹出栈顶且扔掉新来的；否则把新来的加入栈中。 考察最后栈的情况，必定是栈底若干个不诚实的人（可能无），栈顶若干个诚实的人（必定有）。为啥？一次删除最多会删掉一个诚实的和一个不诚实的，由于诚实的人多，所以最后必定能留下诚实的人；并且诚实的人一定会披露不诚实的，故栈顶必为诚实的人。 最后再问栈顶的人每个人是否诚实即可。 参考代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;#define FOR(i, a, b) for (int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define N 4010int A, B, n;int d[N], t;char f[N], g[5];int main() &#123; scanf("%d%d", &amp;A, &amp;B); n = A + B; if(A &lt;= B) return puts("Impossible"), 0; FOR(i, 0, n - 1)&#123; if(!t) d[++t] = i; else&#123; printf("? %d %d\n", d[t], i), fflush(stdout); scanf("%s", g); *g == 'Y' ? d[++t] = i : --t; &#125; &#125; const int u = d[t]; f[u] = 49; FOR(i, 0, n - 1) if(i != u)&#123; printf("? %d %d\n", u, i), fflush(stdout); scanf("%s", g); f[i] = (*g == 'Y') + 48; &#125; printf("! %s\n", f), fflush(stdout); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>AtCoder</tag>
        <tag>交互题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC041F」Histogram Rooks]]></title>
    <url>%2Fblog%2FAGC041F%2F</url>
    <content type="text"><![CDATA[题意简述AGC 041F 给定一个 $n\times n$ 的被破坏的棋盘，其中第 $i$ 列只剩了最底下的 $h_i$ 个。 求有多少种在棋盘中放置「車」的数量使得棋盘被「車」控制，即其他位置均在「車」的攻击范围内。$n\le 400$。 主要思路这题官方题解 $O(n^3)$，然后有一群人踩标算…… $O(n^3)$考虑 $[l, r]$ 列中除了前 $h$ 行外的格子。这块区域要合法，则每列有三种情况： 此列有「車」。 此列无「車」，但这些格子都被其他「車」控制了。 此列无「車」，且有部分格子没被其它「車」控制，则必须该列前 $h$ 行有「車」。 显然我们一次可以处理一段极长的每列都不少于 $h$ 行的列区间。于是状态数 $O(nh)$。 但是有个好性质，就是第 2 类列和第 3 类列不能共存。于是对状态整一个 $0/1$ 表示是有第 2 类列还是第 3 类列，然后按「$[l, r]$ 列中有无 $h_i=h$」疯狂讨论转移即可。 反正一通讨论后，有的话就是个背包（因为 $h$ 再升高就要分裂成几段了），没有的话就是个递推啥的。 反正最后能推出来复杂度是 $O(n^3)$ 就是了。 $O(n^2)$称某一行中未被破坏的格子的极长格子段为「行连续段」。称有位置没有被控制的列为「未解决」的列，其余为「已解决」的列。 考虑容斥。枚举未解决的列的集合 $S$，那么这些列的所有格子都不能放「車」。此时对于一个行连续段，假设其段长为 $len$，有 $p$ 个位置所在的列是未解决的列。 在这个行上不存在位置不被控制，则剩余的 $len - p$ 个格子随便放，贡献 $2^{len - p}$。 在这个行上存在位置不被控制，则方案数为 $1$，因为不能够放放置任何「車」。枚举多少个位置放了车，乘上容斥系数即 $\sum\limits_{i=1}^{p}(-1)^i\binom{p}{i} = -[p\neq 0]$。 但是这玩意是错的，因为未解决的列可能在某些方案中是已解决的，此时该方案不改变被算入。 继续考虑容斥，枚举 $S$ 基础上，枚举最后的选择方案中已解决的列的子集 $T$，容斥系数为 $(-1)^{|T|}$。 这样如果某个行连续段存在 $p$ 个位置所在的列在 $S$ 中，$q$ 个位置所在的列在集合 $T$ 中，方案数将变为 $2^{len - p} - [p\neq q]$。（尽管 $T$ 中的列实际已解决，但在容斥时应仍当成未解决的列。） 发现 $p\ge q$，并且某个定行连续段的贡献只有两个变量 $p, [p &gt; q]$。并且对于左右端点的列相同的行连续段，贡献也一定相同。 于是图被划分成一堆矩形。对于一个矩形，它包含的在 $S$ 中的列的数量为其正上方的所有矩形包含在 $S$ 中的列的总数量加上其独有的数量（这些列是顶端即为该矩形顶端的列）。 给每个矩形一个标号，设 $f(i, j, 0/1)$ 表示 $i$ 号矩形中，有 $j$ 个位置所在的列在 $S$ 中，不存在/存在在 $S$ 中而不在 $T$ 中的列，这样的方案数。 转移先从其正上方矩形将该数组合并，再考虑其独有的若干列的选择，最后乘上每行如何放车的系数。 预处理下系数，就 $O(n^2)$ 了。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;#define Templ(T) template &lt;typename T&gt;inline int read() &#123; reg int ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) f ^= (c == '-'), c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define mod 998244353inline void qmo(int &amp;x) &#123; x += (x &gt;&gt; 31) &amp; mod; &#125;&#125; // namespace my_stdusing namespace my_std;#define N 410#define inf (1145141919)int n, h[N];int c[2][N][N], f[N][N][2];int T;inline void init()&#123; n = read(); FOR(i, 1, n) h[i] = read(); f[0][0][0] = -inf; FOR(i, 0, n) c[0][i][0] = c[0][0][i] = 1; FOR(i, 1, n)&#123; qmo(c[0][i][1] = -mod + (c[0][i - 1][1] &lt;&lt; 1)); qmo(c[1][i][1] = c[0][i][1] - 1); FOR(j, 2, n)&#123; qmo(c[0][i][j] = (i64)c[0][i][1] * c[0][i][j - 1] % mod); qmo(c[1][i][j] = (i64)c[1][i][1] * c[1][i][j - 1] % mod); &#125; &#125;&#125;inline int dp(int l, int r)&#123; if(l &gt; r) return 0; static int tmp[N][2]; reg const int id(++T), len(r - l + 1); reg int (*g)[2] = f[id]; Rint mn(inf), num(0); FOR(i, l, r) chkmin(mn, h[i]); g[0][0] = 1; for(Rint L(l), R(l), siz(0); R &lt;= r + 1; ++R) if(h[R] == mn || R == r + 1)&#123; reg int (*u)[2] = f[dp(L, R - 1)]; if(u[0][0] == -inf)&#123; ++num, L = R + 1; continue; &#125; memset(tmp, 0, sizeof(tmp)); FOR(i, 0, siz) FOR(j, 0, R - L)&#123; FOR(x, 0, 1) FOR(y, 0, 1)&#123; qmo(tmp[i + j][x | y] += (i64)g[i][x] * u[j][y] % mod - mod); &#125; &#125; memcpy(g, tmp, sizeof(tmp)); ++num, siz += R - L; L = R + 1; &#125;//处理儿子 FOR(o, 1, num - 1)&#123; memcpy(tmp, g, sizeof(tmp)); FOR(j, 0, len - 1)&#123; qmo(tmp[j + 1][0] -= g[j][0]); qmo(tmp[j + 1][1] += g[j][0] - mod); &#125; memcpy(g, tmp, sizeof(tmp)); &#125;//处理 num - 1 个最低的位置 reg const int hgh(mn - max(h[l - 1], h[r + 1])); FOR(i, 0, len)&#123; qmo(g[i][0] = (i64)c[0][len - i][hgh] * g[i][0] % mod); qmo(g[i][1] = (i64)c[1][len - i][hgh] * g[i][1] % mod); &#125;//乘容斥系数 return id;&#125;inline void get_ans(reg const int &amp;t)&#123; Rint ans(0); FOR(i, 0, n)&#123; qmo(ans += f[t][i][0] - mod); qmo(ans += f[t][i][1] - mod); &#125; printf("%d\n", ans);&#125;int main() &#123; init(); get_ans(dp(1, n)); return 0;&#125; 参考资料AGC041F Histogram Rooks | PuFanyi’s BlogAtCoder Grand Contest 041 | hl666’s BlogAGC041F Histogram Rooks | Itst’s Blog]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>计数</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC045E」Fragile Balls]]></title>
    <url>%2Fblog%2FAGC045E%2F</url>
    <content type="text"><![CDATA[题意简述AGC 045E 有 $n$ 个箱子 $m$ 个球，第 $i$ 个球开始在箱子 $a_i$，你希望把它移到箱子 $b_i$。但是移动有限制：想要把某个球移动到某个箱子中，该球原先所在的箱子中至少要有两个球；并且，每个球都是易碎的，所以第 $i$ 个球不能移动超过 $c_i$ 次。 请问是否能达成目标，并求出至少要移动多少次球。保证目标状态中任意箱子中都至少有一个球。$1\le n, m, c_i\le 10^5$。 主要思路首先对于 $a_i \neq b_i$ 的球，移动至少 1 次是不可少的，故先给答案加上这样的球的个数。 不妨把箱子看作点，球 $i$ 看作边 $a_i\rightarrow b_i$。显然，可以在钦定边无向的情况下先把连通块全拆出来。注意到每个点都有入度，故不可能出现树的连通块。然后就有了三种连通块： 只有一个点的自环。 单个环。 其他连通块。 第 0 类连通块不用操作次数，而第 2 种可以自己构造出每个球只用移动 1 次的合法方案。于是如果没有第 1 类连通块，此时已经做完了。 发现从第 1 类连通块外移动一个球到块内，之后块内每个球也只用移动 1 次。不妨称此过程为「处理」。设第 1 类连通块有 $x$ 个。显然将一个块外球移动到块内这 1 步是不可少的，所以也可以先扔到答案里面。 考虑将第 $i$ 个球移出其所在连通块来处理其他连通块： 若其在第 2 类连通块内，且 $a_i \neq b_i$，则其最多可处理 $c_i - 1$ 个连通块，不需要额外操作次数。 若其在（已处理的）第 1 类连通块内，则其最多可以处理 $c_i - 1$ 个连通块，而处理该连通块的操作次数在上文已经计算，故同样不需要额外操作次数。 若其在第 2 类连通块内，且 $a_i = b_i$，则其最多可处理 $c_i - 1$ 个连通块，且由于其本来不必移动，故需要额外操作次数 $1$ 次。 若其在第 0 类连通块内，则其最多可处理 $c_i - 2$ 个连通块，且由于其本来不必移动，并且其移动前需要另一球来「处理」，故需要额外操作次数 $2$ 次。 如何保证 $i$ 球能够移动（即能够安排先后顺序使得其移动前所在连通块已经被处理）？只需先取一个第 2 连通块中的球开始移动。 然后显然不需要额外操作次数的都随便拿。于是只剩下额外操作次数为 $1, 2$ 的球，然后排个序 Two Pointers 即可。 除排序外，复杂度 $O(n)$。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;#define Templ(T) template &lt;typename T&gt;inline int read() &#123; reg int ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) f ^= (c == '-'), c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define N 100010#define pb push_backint n, m, a[N], b[N], c[N];int oud[N], f[N], s[N], r[N];//out degree, father, size, ringvector&lt;int&gt; q[4];i64 ans;inline int find(int x)&#123; return x == f[x] ? x : (f[x] = find(f[x])); &#125;//0类：自环自成连通块//1类：环自成连通块//2/3类：其他连通块（中的自环/其他边）int main() &#123; n = read(), m = read(); FOR(i, 1, n) f[i] = i, r[i] = 1; FOR(i, 1, m)&#123; a[i] = read(), b[i] =read(), c[i] = read(); ++oud[a[i]], ans += a[i] != b[i]; f[find(a[i])] = find(b[i]); &#125; FOR(i, 1, n)&#123; ++s[find(i)]; if(oud[i] != 1) r[find(i)] = 0; &#125; reg i64 cnt(0); FOR(i, 1, n)&#123; cnt += find(i) == i &amp;&amp; s[i] &gt; 1 &amp;&amp; r[i]; &#125; if(!cnt) return printf("%lld\n", ans), 0; ans += cnt; //无环 FOR(i, 1, m)&#123; if(c[i] == 1) continue; Rint u = (find(a[i])); if(r[u])&#123; if(s[u] == 1) q[0].pb(c[i] - 2); else if(s[u] &gt; 1) q[1].pb(c[i] - 1); &#125; else&#123; q[a[i] == b[i] ? 2 : 3].pb(c[i] - 1); &#125; &#125; reg i64 sum(0); FOR(o, 0, 3) for(Rint i: q[o]) sum += i; if(sum &lt; cnt) return puts("-1"), 0; //可用次数不够 if(q[2].empty() &amp;&amp; q[3].empty()) return puts("-1"), 0; //没有能开始贡献的 FOR(o, 0, 3) sort(q[o].begin(), q[o].end()); if(q[3].size()) cnt -= q[3].back(), q[3].pop_back(); else ++ans, cnt -= q[2].back(), q[2].pop_back(); //开始贡献 for(Rint i: q[1]) cnt -= i; for(Rint i: q[3]) cnt -= i; if(cnt &lt;= 0) return printf("%lld\n", ans), 0; //无需额外次数 reg i64 res(1145141919810364364ll); sum = 0; Rint p(0); for(Rint i: q[2]) sum += i; ROF(i, q[0].size(), 0)&#123; if(i &lt; (int)q[0].size()) sum += q[0][i]; while(p &lt; (int)q[2].size() &amp;&amp; sum - q[2][p] &gt;= cnt) sum -= q[2][p++]; if(sum &gt;= cnt)&#123; chkmin(res, 2ll * ((int)q[0].size() - i) + ((int)q[2].size() - p)); &#125; &#125; //2 Pointers求剩余两种各取几个 printf("%lld\n", ans + res); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>图论</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC044E」Random Pawn]]></title>
    <url>%2Fblog%2FAGC044E%2F</url>
    <content type="text"><![CDATA[题意简述AGC 044E 给出一个长为 $n$ 的环，每个点有 $a_i, b_i$。随机一个点 $i$ 开始，每次你可以选择停止，则获得当前位置的价值 $a_i$；或者耗费 $b_i$ 的价值，等概率随机移动到左右两点中的一个。 求期望获得的最大价值。$2\le n\le 200000, 0\le a_i\le 10^{12}, 0\le b_i\le 100$。 主要思路由于花费非负，若移动到了价值最大的点上显然不会再移动。故可以断环为以最大价值的点开头和结尾的长 $n+1$ 的序列。 显然，若设 $g_i$ 为从点 $i$ 开始的期望最大价值，则 $g_i = \max(a_i, \dfrac{g_{i - 1} + g_{i + 1}}{2} - b_i)$。 但是这式子里有个 $b_i$ 不好搞，给每个点设一个修正值 $c_i$，然后两边同时减去这个值。 $$g_i - c_i = \max(a_i - c_i, \dfrac{g_{i - 1} - c_{i - 1} + g_{i + 1} - c_{i + 1}}{2} - b_i - c_i + \dfrac{c_{i - 1} + c_{i + 1}}{2})$$ 为了消去 $b_i$，应有 $b_i + c_i = \dfrac{c_{i - 1} + c_{i + 1}}{2}$。 钦定 $c_1 = 0$，即可求出所有 $c_i$。设 $f_i = g_i - c_i, v_i = a_i - c_i$，此时的转移式即为 $f_i = \max(v_i, \dfrac{f_{i-1}+f_{i+1}}{2})$。 这是个经典问题。类似于价值最大的点，应当有一些「终止点」，移动到则直接停止最优。 假设相邻的两个终止点 $l, r$，考虑求 $\sum\limits_{i=l}^{r} f_i$。显然 $f_l = v_l, f_r = v_r$。而对于 $i\in(l, r)$，应有 $f_i = \dfrac{f_{i-1}+f_{i+1}}{2}$，即 $f_i, i\in[l, r]$ 为等差数列。 于是贡献就是相邻终止点向 $x$ 轴作垂线形成梯形的面积。不妨求出答案的两倍。即贡献为 $(v_l + v_r) \times (r - l)$。 显然当选取终止点形成上凸壳时，总贡献取最大值。于是直接 $O(n)$ 做就完事了。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;#define Templ(T) template &lt;typename T&gt;Templ(T) inline T read() &#123; reg T ans = 0; reg char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define N 200010int n;i64 a[N], c[N];int b[N];struct Point&#123; i64 x, y; inline Point(i64 _x = 0, i64 _y = 0)&#123; x = _x, y = _y; &#125; inline Point operator -(const Point &amp;t)const&#123; return Point(x - t.x, y - t.y); &#125;&#125;d[N];inline i64 cross(const Point &amp;l, const Point &amp;r)&#123; return l.x * r.y - r.x * l.y;&#125;void init()&#123; i64 *aa = new i64[N], mx(-1); int *bb = new int[N], pos(0); n = read&lt;int&gt;(); FOR(i, 1, n)&#123; if(chkmax(mx, aa[i] = read&lt;i64&gt;())) pos = i; &#125; FOR(i, 1, n) bb[i] = read&lt;int&gt;(); memcpy(a + 1, aa + pos, sizeof(i64) * (n - pos + 1)); memcpy(a + n - pos + 2, aa + 1, sizeof(i64) * pos); memcpy(b + 1, bb + pos, sizeof(int) * (n - pos + 1)); memcpy(b + n - pos + 2, bb + 1, sizeof(int) * pos); delete aa; delete bb;&#125;int main() &#123; init(); c[1] = 0, ++n; FOR(i, 2, n) c[i] = 2 * (c[i - 1] + b[i - 1]) - c[i - 2]; reg Point t; Rint h(0); FOR(i, 1, n)&#123; t = Point(i, a[i] - c[i]); while(h &gt; 1 &amp;&amp; cross(d[h] - d[h - 1], t - d[h]) &gt; 0) --h; d[++h] = t; &#125; reg i64 ans(0); FOR(i, 2, h)&#123; ans += (d[i].x - d[i - 1].x) * (d[i].y + d[i - 1].y); &#125; ans += d[1].y + d[h].y; ans -= 2 * a[1]; FOR(i, 1, n) ans += 2 * c[i]; printf("%.12lf", 0.5 * ans / (n - 1.0)); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC038E」Gachapon]]></title>
    <url>%2Fblog%2FAGC038E%2F</url>
    <content type="text"><![CDATA[粉兔题解，好！ 题意简述AGC 038E 有 $n$ 个物品，第 $i$ 个物品给定 $a_i$ 和 $b_i$。 每一个单位时间你会获得一个物品，设 $\sum_{i=1}^n a_i = \sum a, \sum_{i=1}^n b_i = \sum b$，则第 $i$ 个物品有 $\dfrac{a_i}{\sum a}$ 的概率获得。 计算第一次对于每个 $i$ 都有第 $i$ 个物品获得至少 $b_i$ 个的期望时间。 $n, \sum a, \sum b\le 400$。 主要思路先 min-max 容斥，转化为对于每个非空子集 $S$ 求第一次自己中的任意一个物品获得至少 $b_i$ 个的期望时间，对答案贡献为 $(-1)^{|S|+1}$。也就是满足子集 $S$ 中的所有物品获得的数量都少于 $b_i$ 个的期望时刻数量，加上 $1$。可以把开始无物品的状态也算作 $1$ 个时刻，即可略去 $+1$。 考虑计算这个期望时刻数量（包括初始时刻）。即对每种物品获得的状态，计算这种状态在所有可能情况下的期望次数（包括初始时刻），再求和。不难发现，一旦第一次变成了某种状态，只要再次获得 $S$ 中的物品，状态就会改变。所以一个状态将期望持续 $\dfrac{\sum a}{\sum\limits_{i\in S}a_i}$ 个时刻。于是只用考虑每种情况的出现概率即可，这时就可以不考虑 $S$ 以外的物品的影响了。 假设第 $i$ 个物品获得了 $0\le x_i&lt; b_i$ 次，$i\in S$，那么达到这种状态就是存在一个获得 $S$ 中的物品前缀满足 $i$ 恰好出现了 $x_i$ 次。令 $X=\sum\limits_{i\in S}x_i,C=\sum\limits_{i\in S}a_i$，则概率即为 $X!\displaystyle\prod\limits_{i\in S}\left(\dfrac{a_i}{C}\right)^{x_i}\dfrac{1}{x_i!}=\displaystyle\dfrac{X!}{C^X} \prod_{i\in S} \frac{a_i^{x_i}}{(x_i)!}$。阶乘来源于多重组合数。 然后你发现这个状态只关系 $X, C$ 了。不妨设 $f(C, X)$ 为 $(-1)^{|S|+1}\displaystyle\prod_{i\in S} \frac{a_i^{x_i}}{(x_i)!}$ 的期望。于是转移就非常简单了：加入 $i$ 时，枚举 $0\le x_i&lt; b_i$，$f(C, X) \leftarrow^{-} f(C - a_i, k - x_i)\dfrac{a_i^{x_i}}{x_i!}$。 这样依次加入 $n$ 个物品，每次复杂度为 $O(b_iXC)$ 暴力，总时间复杂度 $O((\sum b)^2\sum a)$。最后求答案的时候记得对于 $f(C, X)$ 乘上 $\dfrac{X!}{C^{X - 1}\sum a}$ 的系数。在 EGF 层面考虑，其实这个东西就大概是个卷积形式。 然后也确实有一个暴推生成函数的做法，大概最后能化成 $\sum\limits_{n\ge 0}n![z^n]\sum\limits_{i, j}c_{i, j}z^i e^{jz}$ 之类的东西，然后那个 $j$ 是一堆概率乘一起，所以这玩意就收敛了…… 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;#define Templ(T) template &lt;typename T&gt;inline int read() &#123; reg int ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) f ^= (c == '-'), c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define mod 998244353inline void inc(int &amp;x, const int &amp;y) &#123; x += y; if (x &gt;= mod) x -= mod; &#125;inline void dec(int &amp;x, const int &amp;y) &#123; x -= y; if (x &lt; 0) x += mod; &#125;inline void qmo(int &amp;x)&#123; x += (x &gt;&gt; 31) &amp; mod; &#125;inline int ksm(int x, i64 y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = (i64)x * x % mod) if (y &amp; 1) res = (i64)res * x % mod; return res;&#125;&#125; // namespace my_stdusing namespace my_std;#define N 410int fac[N], ifac[N];int n;inline void init(int lim)&#123; *fac = *ifac = 1; FOR(i, 1, lim) fac[i] = (i64)i * fac[i - 1] % mod; ifac[lim] = ksm(fac[lim], mod - 2); ROF(i, lim - 1, 1) ifac[i] = (i64)(i + 1) * ifac[i + 1] % mod;&#125;int a[N], b[N], Sa, Sb;int f[N][N];int main() &#123; n = read(); FOR(i, 1, n) a[i] = read(), Sb += (b[i] = read()) - 1; init(Sb), Sb = 0; f[0][0] = mod - 1; FOR(i, 1, n)&#123; Sa += a[i], Sb += b[i] - 1; ROF(j, Sa, a[i]) ROF(k, Sb, 0)&#123; reg i64 t(1); FOR(x, 0, min(b[i] - 1, k))&#123; qmo(f[j][k] -= t * ifac[x] % mod * f[j - a[i]][k - x] % mod); (t *= a[i]) %= mod; &#125; &#125; &#125; Rint ans(0); FOR(j, 1, Sa)&#123; reg const int inv(ksm(j, mod - 2)); reg i64 t(Sa * (i64)inv % mod); FOR(k, 0, Sb)&#123; qmo(ans += (t * fac[k] % mod * f[j][k] % mod) - mod); (t *= inv) %= mod; &#125; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>AtCoder</tag>
        <tag>概率期望</tag>
        <tag>min-max容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC006F」Blackout]]></title>
    <url>%2Fblog%2FAGC006F%2F</url>
    <content type="text"><![CDATA[题意简述AGC 006F 给定平面上的 $m$ 个整点 $(x, y), x, y\in[1, n]$，将这 $n$ 个点染黑。然后任取两个黑色的点 $(a, b), (b, c)$ 并将点 $(c, a)$ 染黑，直至无法再染黑任何点为止。 求最后平面上有多少点被染黑。$n, m\le 5\times 10^5$。 主要思路不妨建出一个 $n$ 个点的图，对于每一对给定的 $(x, y)$ 则在图中连边 $x\to y$。则对于任何一条长为 $2$ 的链，其形态会变成一个三元环。 考虑对每个弱连通块三染色。 如果染色成功，则最后连通块中所有颜色 $0,1,2$ 的点会分别向所有颜色 $1,2,0$ 的点连边。 如果不成功但用了每种颜色，则可知一定出现了长度不为 $3$ 的倍数的环，这个连通块会被连成完全图（包括自环）。 如果不成功且没有用到每种颜色，则不会新加边。 于是做完了。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define GO(x, p, e, i, v) for (register int i = p[x].head, v; i; i = e[i].link)typedef long long i64;#define Templ(T) template &lt;typename T&gt;inline int read() &#123; reg int ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) f ^= (c == '-'), c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define N 500010int n, m;int f[3];int comp;struct Edge&#123; int link, to;&#125;e[N &lt;&lt; 1];struct Vertice&#123; int head, col;&#125;p[N];int ecnt(0);#define col(x) p[x].col#define head(x) p[x].headinline void A_E(int u, int v)&#123; e[++ecnt] = (Edge)&#123;head(u), v&#125;; head(u) = ecnt;&#125;inline int qm3(reg const int &amp;x)&#123; return x &gt; 2 ? x - 3 : x;&#125;inline i64 sqr(reg const int &amp;x)&#123; return (i64)x * x;&#125;inline void dfs(int u)&#123; Rint t; ++f[col(u)]; GO(u, p, e, i, v)&#123; v = e[i].to; if(i &amp; 1) ++ecnt; t = qm3(col(u) + 1 + (!(i &amp; 1))); if(col(v) == -1)&#123; col(v) = t, dfs(v); &#125; else&#123; if(col(v) != t) comp = 1; &#125; &#125;&#125;int main() &#123; n = read(), m = read(); Rint u, v; FOR(i, 1, m)&#123; u = read(), v = read(); A_E(u, v), A_E(v, u); &#125; FOR(i, 1, n) col(i) = -1; reg i64 ans(0); FOR(i, 1, n) if(col(i) == -1)&#123; col(i) = 0, f[0] = f[1] = f[2] = 0; ecnt = 0, comp = 0; dfs(i); if(comp)&#123; ans += sqr(f[0] + f[1] + f[2]); continue; &#125; if(!f[0] || !f[1] || !f[2])&#123; ans += ecnt; continue; &#125; ans += (i64)f[0] * f[1] + (i64)f[1] * f[2] + (i64)f[2] * f[0]; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>猜结论</tag>
        <tag>图论</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC043C」Giant Graph]]></title>
    <url>%2Fblog%2FAGC043C%2F</url>
    <content type="text"><![CDATA[题意简述AGC 043C 给三个点数均为 $n$ 的无向图 $G_0, G_1, G_2$，构造一张新无向图 $W$，点数为 $n^3$，每个点的形式为 $(x_0, x_1, x_2)$。对于原来 $G_0$ 中的一条边 $u, v$，连接所有 $(u, x_1, x_2), (v, x_1, x_2)$。$G_1, G_2$ 中的边同理。点 $(x_0, x_1, x_2)$ 的点权为 $V^{x_0 + x_1 + x_2}$，其中 $V = 10^{18}$。求 $W$ 的最大权独立集的权值。$n, m_0, m_1, m_2\le 10^5$。 主要思路显然贪心优先选 $x_0 + x_1 + x_2$ 大的是最优的。不妨设所有的边的方向为从权值小的点连向权值大的。那么一个点被选仅当它的出边中没有点被选。不妨将其想象成一个公平游戏，则 $sg(x_0, x_1, x_2) = \operatorname{mex}\limits_{e((x_0, x_1, x_2), (y_0, y_1, y_2))}sg(y_0, y_1, y_2)$，为 $0$ 则选。然后观察到三个维度是独立的，可以分开来做。注意到这样的 SG 函数的上界是 $O(\sqrt{m})$ 的。于是甚至不用写 FWT，暴力枚举就好了。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define pb push_backtypedef long long i64;#define Templ(T) template &lt;typename T&gt;inline int read() &#123; reg int ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) f ^= (c == '-'), c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define mod 998244353inline void inc(int &amp;x, const int &amp;y) &#123; x += y; if (x &gt;= mod) x -= mod; &#125;inline void dec(int &amp;x, const int &amp;y) &#123; x -= y; if (x &lt; 0) x += mod; &#125;inline void qmo(int &amp;x)&#123; x += (x &gt;&gt; 31) &amp; mod; &#125;&#125; // namespace my_stdusing namespace my_std;#define N 100010#define BN 610const i64 V = i64(1e18) % mod;int n;struct Graph&#123; vector&lt;int&gt; E[N]; int sg[N], n, m, val[BN], mxsg; inline void build()&#123; n = ::n, m = read(); Rint u, v; FOR(i, 1, m)&#123; u = read(), v = read(); if(u &gt; v) u ^= v ^= u ^= v; E[u].pb(v); &#125; &#125; inline void topo()&#123; int *c = new int[BN]; mxsg = 0; memset(c, 0, sizeof(int) * BN); ROF(u, n, 1)&#123; for(Rint v: E[u]) c[sg[v]] = 1; Rint t(0); while(c[t]) ++t; chkmax(mxsg, sg[u] = t); for(Rint v: E[u]) c[sg[v]] = 0; &#125; delete c; Rint x(V); FOR(i, 1, n)&#123; qmo(val[sg[i]] += x - mod); x = V * x % mod; &#125; &#125;&#125;G[3];int main() &#123; n = read(); FOR(i, 0, 2) G[i].build(), G[i].topo(); Rint ans(0); FOR(i, 0, G[0].mxsg) FOR(j, 0, G[1].mxsg)&#123; qmo(ans += ((i64)G[0].val[i] * G[1].val[j] % mod * G[2].val[i ^ j] % mod) - mod); &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>AtCoder</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC046D」Secret Passage]]></title>
    <url>%2Fblog%2FAGC046D%2F</url>
    <content type="text"><![CDATA[题意简述AGC 046D 给定一个01串 $S$，每次操作把最前面的两个字符删除，并将其中一个插入回串中。求能获得的串的个数，取模。 $|S|\le 300$。 主要思路考虑这个过程，不妨设 $(i, c_0, c_1)$ 这个状态表示目前串最长的等于 $S$ 的后缀的子序列长度为 $|S| - i$，除此以外分别多出 $c_0, c_1$ 个0,1。 我们设 $tr(i, c_0, c_1)$ 为这个状态是否可达，$dp(i, c_0, c_1)$ 为这个状态的方案数。 （初始 $tr(0, 0, 0) = 1$，$dp(n, 0, 0) = 1$，一个要顺着一个要倒着转移。） 然后转移非常多情况要讨论，都扔到注释里了。都是力气活…… 总之最后复杂度就是 $O(|S|^3)$ 了。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;const int mod = 998244353;inline void inc(int &amp;x, const int &amp;y) &#123; x += y; if (x &gt;= mod) x -= mod; &#125;inline void dec(int &amp;x, const int &amp;y) &#123; x -= y; if (x &lt; 0) x += mod; &#125;&#125; // namespace my_stdusing namespace my_std;#define N 350char s[N];int n;int dp[N][N][N];bool tr[N][N][N];//[i][c0][c1]: 剩下 i 个字符没有匹配，多了 c0 个 0 和 c1 个 1int main() &#123; scanf("%s", s + 1); n = strlen(s + 1); tr[0][0][0] = 1; FOR(i, 1, n)&#123; ROF(c0, n, 0) ROF(c1, n, 0)&#123; if(i == n &amp;&amp; !c0 &amp;&amp; !c1) continue; tr[i][c0][c1] |= tr[i - 1][c0][c1]; if(s[i] == 48) tr[i][c0][c1] |= tr[i][c0][c1 + 1]; if(s[i] == 49) tr[i][c0][c1] |= tr[i][c0 + 1][c1]; //删掉两个把第二个加回原来位置 //加回去的可能是多出来的字符 &#125; if(i &gt; 1) FOR(c0, 0, n) FOR(c1, 0, n)&#123; if((s[i - 1] == 48 || s[i] == 48) &amp;&amp; c0)&#123; tr[i][c0][c1] |= tr[i - 2][c0 - 1][c1]; //前面两个都不是多余的，把'0'扔到多余的位置 &#125; if(s[i - 1] == 48 &amp;&amp; s[i] == 48 &amp;&amp; c0)&#123; tr[i][c0][c1] |= tr[i - 1][c0 - 1][c1 + 1]; //前面是"10"（'1'是多余的），并把'0'扔到多余的位置 &#125; if((s[i - 1] == 49 || s[i] == 49) &amp;&amp; c1)&#123; tr[i][c0][c1] |= tr[i - 2][c0][c1 - 1]; //前面两个都不是多余的，把'1'扔到多余的位置 &#125; if(s[i - 1] == 49 &amp;&amp; s[i] == 49 &amp;&amp; c1)&#123; tr[i][c0][c1] |= tr[i - 1][c0 + 1][c1 - 1]; //前面是"01"（'0'是多余的），并把'1'扔到多余的位置 &#125; &#125; &#125; dp[n][0][0] = 1; ROF(i, n, 1)&#123; FOR(c0, 0, n) FOR(c1, 0, n)&#123; Rint t(dp[i][c0][c1]); inc(dp[i - 1][c0][c1], t); if(s[i] == 48) inc(dp[i][c0][c1 + 1], t); if(s[i] == 49) inc(dp[i][c0 + 1][c1], t); &#125; &#125; Rint ans(0); FOR(i, 0, n)&#123; FOR(c0, 0, i) FOR(c1, 0, i)&#123; if(tr[i][c0][c1]) inc(ans, dp[i][c0][c1]); &#125; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF650E」Clockwork Bomb]]></title>
    <url>%2Fblog%2FCF650E%2F</url>
    <content type="text"><![CDATA[题意简述CF 650E 给两棵树 $T_0, T_1$，每次删去 $T_0$ 的一条边后加入一条新边，要求加入后仍为树。求最少次数使得将 $T_0$ 修改为 $T_1$ 并构造方案。$n\le 500000$。 主要思路可以强行用LCT做动态最小生成树无脑肝过去 显然改掉两棵树都有的边不优，猜测其他边均只需改变一次。 考虑对于 $T_0$ 中的一对父子关系 $f_0(v) = u$，若 $(u, v)$ 不在 $T_1$ 中出现应在断掉后如何连边。 一个简单的想法是直接连接 $(f_1(v), v)$，问题在于这条边可能已经在 $T_0$ 中连了。 想象一下由 $T_0, T_1$ 中都存在的边构成的子图，发现这其实是一堆连通块并且块内的结构在过程中是不变的。 设 $find(v)$ 为在上述子图中 $v$ 所在连通块内的在 $T_1$ 中最浅的祖先 $w$。根据上述子图的定义，$(f_1(w), w)$ 在 $T_0$ 中不存在且不在上述子图中的同一个连通块内，故删去 $(u, v)$ 后连接 $(f_1(w), w)$ 仍能保证其为一棵树。 求 $find(v)$ 可以并查集。复杂度 $O(n\alpha(n))$。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define pb push_back#define Templ(T) template &lt;typename T&gt;inline int read() &#123; reg int ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) f ^= (c == '-'), c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define N 500010vector&lt;int&gt; E[2][N];int fth[2][N];int ans[N][4], acnt;int n;int pr[N];int find(int u)&#123; return u == pr[u] ? u : pr[u] = find(pr[u]);&#125;inline bool chk_pr(int x, int y)&#123; if(!x || !y) return 0; return fth[0][x] == y || fth[0][y] == x;&#125;void dfs_ff(const int &amp;id, int u)&#123; for(Rint v: E[id][u])&#123; if(v == fth[id][u]) continue; fth[id][v] = u, dfs_ff(id, v); &#125;&#125;void dfs_ce(int u)&#123; Rint t; for(Rint v: E[0][u])&#123; if(v == fth[0][u]) continue; dfs_ce(v); if(fth[1][v] != u &amp;&amp; fth[1][u] != v)&#123; t = find(v); ans[++acnt][0] = u; ans[acnt][1] = v; ans[acnt][2] = t; ans[acnt][3] = fth[1][t]; &#125; &#125;&#125;int main() &#123; n = read(); FOR(o, 0, 1)&#123; Rint u, v; FOR(i, 1, n - 1)&#123; u = read(), v = read(); E[o][u].pb(v), E[o][v].pb(u); &#125; dfs_ff(o, 1); &#125; FOR(i, 1, n)&#123; pr[i] = chk_pr(i, fth[1][i]) ? fth[1][i] : i; &#125; dfs_ce(1); printf("%d\n", acnt); FOR(i, 1, acnt)&#123; FOR(j, 0, 3) printf("%d ", ans[i][j]); putchar(10); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>树论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF641F」Little Artem and 2-SAT]]></title>
    <url>%2Fblog%2FCF641F%2F</url>
    <content type="text"><![CDATA[题意简述CF 641F 对于 $n$ 个布尔元素 $a(x), x\in [0, n)$，给定两个 2-SAT 问题，问是否解集相同，否则构造一组解使得其仅为其中之一的解。 两个 2-SAT 均形如 $\land_{i = 0}^{m - 1}(f(x_{i, 0})\lor f(x_{i, 1}))$。 其中 $x_{i, j}\in[0, 2n)$，并有恒等式 $a(x) = \lnot f(2x) = f(2x + 1)$。 $n, m\le 1000$。 主要思路先把 2-SAT 图建出来，求一下是否有解。 如果两 2-SAT 均无解，则解集相同。如果仅一个 2-SAT 有解，则构造其任意一个解即可。故只需考虑两 2-SAT 均有解的情况。 先来个传递闭包，然后有一些变量的值就是确定的（即可从该变量的某状态到达另一状态）。如果有一个变量 $f(x)$ 仅在一个 2-SAT 中被确定，则钦定 $f(x)=0$，求出另一 2-SAT 的一个解即可。如果有一个变量在两个 2-SAT 中被确定的值不同，直接求出某个 2-SAT 的任意一解即可。 现在确定的变量集合已经相同了。 设 $u\implies v$ 意为 $u$ 可达 $v$。若存在 $u, v$ 使在一个 2-SAT 中有 $u\implies v$ 而另一 2-SAT 中没有，则钦定 $f(u)=1,f(v)=0$，在另一 2-SAT 中求一解即可。否则两 2-SAT 解集相同。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define MP make_pairtypedef unsigned long long u64;#define Templ(T) template &lt;typename T&gt;inline int read() &#123; reg int ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) f ^= (c == '-'), c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define N 2048struct myB&#123; u64 a[32]; inline void reset()&#123; FOR(i, 0, 31) a[i] = 0; &#125; inline void set()&#123; FOR(i, 0, 31) a[i] = ~0ull; &#125; inline myB()&#123; reset(); &#125; inline bool test(int x)&#123; return (a[x &gt;&gt; 6] &gt;&gt; (x &amp; 63)) &amp; 1; &#125; inline void set(int x)&#123; a[x &gt;&gt; 6] |= 1ull &lt;&lt; (x &amp; 63); &#125; inline void reset(int x)&#123; a[x &gt;&gt; 6] &amp;= ~(1ull &lt;&lt; (x &amp; 63)); &#125; inline myB operator |(const myB &amp;rhs)const&#123; reg myB res; FOR(i, 0, 31) res.a[i] = a[i] | rhs.a[i]; return res; &#125; inline myB operator |=(const myB &amp;rhs)&#123; FOR(i, 0, 31) a[i] |= rhs.a[i]; return *this; &#125; inline bool operator [](const int &amp;x)const&#123; return (a[x &gt;&gt; 6] &gt;&gt; (x &amp; 63)) &amp; 1; &#125;&#125;;inline int trans(const int &amp;u)&#123; return u &gt; 0 ? (u - 1) &lt;&lt; 1 | 1 : (-u - 1) &lt;&lt; 1;&#125;struct SAT2&#123; int n, m, fix[N], fail; myB lnk[N]; inline void dfs(int u)&#123; fix[u] = 1, fix[u ^ 1] = 0; FOR(v, 0, n * 2 - 1)&#123; if(lnk[u][v] &amp;&amp; fix[v] == -1) dfs(v); &#125; &#125; inline void build(int _n, int _m)&#123; n = _n, m = _m; FOR(i, 1, m)&#123; Rint u = trans(read()), v = trans(read()); lnk[u ^ 1].set(v), lnk[v ^ 1].set(u); &#125; FOR(i, 0, 2 * n - 1) lnk[i].set(i), fix[i] = -1; FOR(v, 0, 2 * n - 1) FOR(u, 0, 2 * n - 1)&#123; if(lnk[u][v]) lnk[u] |= lnk[v]; &#125;//传递闭包 fail = 0; FOR(i, 0, n - 1)&#123; if(lnk[i &lt;&lt; 1][i &lt;&lt; 1 | 1] &amp;&amp; lnk[i &lt;&lt; 1 | 1][i &lt;&lt; 1]) fail = 1; &#125;//同元素正反相连 if(fail) return; FOR(i, 0, n - 1)&#123; if(fix[i &lt;&lt; 1] != -1 || fix[i &lt;&lt; 1 | 1] != -1) continue; if(lnk[i &lt;&lt; 1][i &lt;&lt; 1 | 1]) dfs(i &lt;&lt; 1 | 1); if(lnk[i &lt;&lt; 1 | 1][i &lt;&lt; 1]) dfs(i &lt;&lt; 1); &#125; &#125; inline void solve(int f0 = -1, int f1 = -1)&#123; if(f0 &gt;= 0) dfs(f0); if(f1 &gt;= 0) dfs(f1); //钦定 f0, f1 为真 FOR(i, 0, 2 * n - 1)&#123; if(fix[i] == -1) dfs(i); &#125; FOR(i, 0, n - 1) printf("%d ", fix[i &lt;&lt; 1 | 1]); putchar(10); &#125;&#125;S0, S1;int n, m0, m1;int main() &#123; n = read(), m0 = read(), m1 = read(); S0.build(n, m0), S1.build(n, m1); if(S0.fail &amp;&amp; S1.fail) return puts("SIMILAR"), 0; //都无解 if(S0.fail) return S1.solve(), 0; if(S1.fail) return S0.solve(), 0; //仅一个有解 FOR(i, 0, 2 * n - 1)&#123; if(S0.fix[i] &amp;&amp; !S1.fix[i]) return S0.solve(i), 0; if(!S0.fix[i] &amp;&amp; S1.fix[i]) return S1.solve(i), 0; &#125;//确定的变量不相同或确定变量的值不同 FOR(i, 0, 2 * n - 1)&#123; if(S0.fix[i] == -1)&#123; FOR(j, 0, i - 1)&#123; if(S0.fix[j] == -1 &amp;&amp; !S0.lnk[i][j] &amp;&amp; S1.lnk[i][j]) return S0.solve(i, j ^ 1), 0; &#125; &#125; if(S1.fix[i] == -1)&#123; FOR(j, 0, i - 1)&#123; if(S1.fix[j] == -1 &amp;&amp; !S1.lnk[i][j] &amp;&amp; S0.lnk[i][j]) return S1.solve(i, j ^ 1), 0; &#125; &#125; &#125; //若一个 2SAT 中有 i -&gt; j 而另一个没有， //则可在另一个中钦定 i 取真而 j 取假（即 (j ^ 1) 取真） return puts("SIMILAR"), 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>bitset</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF674G」Choosing Ads]]></title>
    <url>%2Fblog%2FCF674G%2F</url>
    <content type="text"><![CDATA[题意简述CF 674G 维护序列，支持： 区间推平。 区间查询出现频率不小于 $p%$ 的数，保证有解。$n, m\ge 1.5\times 10^5, 20\le p\le 100$。 主要思路先考虑 $p = 50$。 这便是一个经典问题：长度为 $n$ 的数列中存在一个出现次数不小于 $n/2$ 的数，设计一个算法找到它。 只要每次删除两个不同的数，最后留下的那个数（或那些数，但这些数全部相同）就是要求的答案。 原理是，如果一个数出现了 $a$ 次，其中 $a\ge n−a$。则两边都减去 $1$，仍有 $a−1\ge n−a−1=(n−2)−(a−1)$。 拓展情况可以如法炮制。令 $k = \lfloor\dfrac{100}{p}\rfloor$，则每次删除 $k + 1$ 个数，则对的数一定会留下来。 两个区间合并的过程显然可以 $O(k^2)$ 一堆分类讨论。上棵线段树，做完了，时间复杂度 $O(n k^2\log n)$。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long LL;#define Templ(T) template &lt;typename T&gt;inline int read() &#123; reg int ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) f ^= (c == '-'), c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;const int N = 150010;int n, m;inline int init()&#123; n = read(), m = read(); return 100 / read();&#125;const int K = init();struct Node&#123; int d[6], c[6]; Node()&#123; memset(d, 0, 6 * sizeof(int)); memset(c, 0, 6 * sizeof(int)); &#125; inline void print()&#123; Rint t = 0; FOR(i, 0, K - 1) if(d[i]) ++t; printf("%d", t); FOR(i, 0, K - 1) if(d[i]) printf(" %d", d[i]); putchar(10); &#125; friend Node operator +(reg Node L, reg Node R)&#123; FOR(i, 0, K - 1)&#123; reg bool flag(0); FOR(j, 0, K - 1) if(L.d[j] == R.d[i])&#123; L.c[j] += R.c[i]; flag = 1; break; &#125;//有相同的数，就合并 if(flag) continue; int o = K, mn = R.c[i]; FOR(j, 0, K - 1) if(chkmin(mn, L.c[j])) o = j; FOR(j, 0, K - 1) L.c[j] -= mn; if(o &lt; K) L.d[o] = R.d[i], L.c[o] = R.c[i] - mn; //没有相同的，就每种都删去 最小的一种的个数 &#125; return L; &#125;&#125;tr[N &lt;&lt; 2];int len[N &lt;&lt; 2], tag[N &lt;&lt; 2];#define lc (t &lt;&lt; 1)#define rc (t &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)inline void cover(int t, int x)&#123; tr[t] = Node(); tr[t].d[0] = tag[t] = x; tr[t].c[0] = len[t];&#125;inline void p_d(int t)&#123; if(tag[t])&#123; cover(lc, tag[t]), cover(rc, tag[t]); tag[t] = 0; &#125;&#125;void build(int t, int l, int r)&#123; len[t] = r - l + 1; if(l == r)&#123; tr[t].d[0] = read(), tr[t].c[0] = 1; return; &#125; build(lc, l, mid), build(rc, mid + 1, r); tr[t] = tr[lc] + tr[rc];&#125;void update(int t, int l, int r, int L, int R, int x)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) return cover(t, x); p_d(t); if(L &lt;= mid) update(lc, l, mid, L, R, x); if(R &gt; mid) update(rc, mid + 1, r, L, R, x); tr[t] = tr[lc] + tr[rc];&#125;Node query(int t, int l, int r, int L, int R)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) return tr[t]; p_d(t); reg Node res; if(L &lt;= mid) res = query(lc, l, mid, L, R); if(R &gt; mid) res = res + query(rc, mid + 1, r, L, R); return res;&#125;int main() &#123; build(1, 1, n); Rint opt, l, r; while(m --)&#123; opt = read(), l = read(), r = read(); if(opt == 2) query(1, 1, n, l, r).print(); else update(1, 1, n, l, r, read()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伯努利数学习笔记]]></title>
    <url>%2Fblog%2F%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[下 Summer Pockets REFLECTION BLUE 的时候太无聊，于是就来学这个东西了。 伯努利数(Bernoulli number)是由雅各布·伯努利的名字命名的。 定义我们定义伯努利数 $B_n$ 是满足如下递归式 $\sum_{i=0}^{n}\binom{n + 1}{i}B_i = [n = 0]$ 的数列。定义自然数幂和函数 $S(n, k)=\sum\limits_{i=0}^{n - 1}i^k$。 EGF首先求出它的 EGF $B(z)$。定义式两边同加 $B_{n + 1}$ 得 $\sum\limits_{i = 0}^{n + 1} \binom{n + 1}{i} B_i = [n = 0] + B_{n + 1}$。 处理一下就是 $\sum\limits_{i = 0}^{n} \binom{n}{i} B_i = [n = 1] + B_{n}$。 所以 $B(z)e^z = B(z) + z$，即 $B(z) = \dfrac{z}{e^z - 1}$。 与自然数幂的转化$$S(n, k) = \sum_{i = 0}^{n - 1} i^k = \dfrac{1}{k + 1}\sum_{i = 0}^{k}\binom{k + 1}{i} B_i n^{k - i + 1}$$ 这玩意大概有两种常见证法。 利用归纳法证明这个证明方法来自 Concrete Mathematics 6.5 BERNOULLI NUMBER。 $$\begin{aligned}S(n, k)+n^{k + 1} &amp;= \sum_{i = 0}^{n - 1}(i + 1)^{k + 1}\\&amp;= \sum_{i = 0}^{n - 1}\sum_{j=0}^{k + 1}\binom{k + 1}{j}k^j\\&amp;= \sum_{j = 0}^{k + 1}\binom{k + 1}{j}S(n, j)\end{aligned}$$ 两边同时减去 $S(n, k)$ 得 $$n^{k + 1} = \sum_{j = 0}^{k} \binom{k + 1}{j} S(n, j)$$ 设 $\hat{S}(n, k) = \sum_{i = 0}^{n - 1} i^k = \dfrac{1}{k + 1}\sum_{i = 0}^{k}\binom{k + 1}{i} B_i n^{k - i + 1}$，且对于 $j\in [0, k)$ 均有 $S(n, j) = \hat{S}(n, j)$ 成立。则需证明 $S(n, k) = \hat{S}(n, k)$。 则此时 $n^{k + 1} = \sum_{j = 0}^{k - 1} \binom{k + 1}{j} \hat{S}(n, j) + S(n, k)$，故转化为证 $n^{k + 1} = \sum_{j = 0}^{k} \binom{k + 1}{j}\hat{S}(n, j)$。 $$\begin{aligned} &amp;\sum_{j = 0}^{k} \binom{k + 1}{j}\hat{S}(n, j)\\ &amp;= \sum_{j = 0}^{k} \binom{k + 1}{j}\dfrac{1}{j + 1}\sum_{i = 0}^{j}\binom{j + 1}{i} B_i n^{j - i + 1}\\ &amp;= \sum_{j = 0}^{k} \binom{k + 1}{j}\dfrac{1}{j + 1}\sum_{i = 0}^{j}\binom{j + 1}{i + 1} B_{j - i} n^{i + 1}\\ &amp;= \sum_{j = 0}^{k} \binom{k + 1}{j}\sum_{i = 0}^{j}\binom{j}{i} B_{j - i} \dfrac{n^{i + 1}}{i + 1}\\ &amp;= \sum_{i = 0}^{k} \dfrac{n^{i + 1}}{i + 1}\sum_{j = i}^{k}\binom{k + 1}{j}\binom{j}{i} B_{j - i}\\ &amp;= \sum_{i = 0}^{k} \dfrac{n^{i + 1}}{i + 1}\binom{k + 1}{i}\sum_{j = i}^{k}\binom{k + 1 - i}{j - i} B_{j - i}\\ &amp;= \sum_{i = 0}^{k} \dfrac{n^{i + 1}}{i + 1}\binom{k + 1}{i}\sum_{j = 0}^{k - i}\binom{k + 1 - i}{j} B_{j}\\ &amp;= \sum_{i = 0}^{k} \dfrac{n^{i + 1}}{i + 1}\binom{k + 1}{i}[i = k]\\ &amp;= \dfrac{n^{k + 1}}{k + 1}\binom{k + 1}{k}\\ &amp;= n^{k + 1}\end{aligned}$$ 其中倒数第二步用的是定义式。 利用指数生成函数证明设 $F_n(z) = \sum\limits_{k\ge 0}\dfrac{S(n, k)}{k!}z^k$。 $$\begin{aligned} F_n(z) &amp;= \sum\limits_{k\ge 0}\dfrac{S(n, k)}{k!}z^k\\ &amp;= \sum_{i=0}^{n-1}\sum_{k\ge 0}\dfrac{i^kz^k}{k!}\\ &amp;= \sum_{i=0}^{n-1}e^{iz}\\ &amp;= \dfrac{e^{nz} - 1}{e^z - 1}\\ &amp;= \dfrac{z}{e^z - 1}\cdot\dfrac{e^{nz} - 1}{z}\\ &amp;= B(z)\cdot\dfrac{e^{nz} - 1}{z}\\ &amp;= \left(\sum_{i\ge 0}\dfrac{B_i}{i!} \right)\left(\sum_{i\ge 0}\dfrac{n^{i+1} z^{i}}{(i+1)!}\right)\end{aligned}$$ 然后取一项就行了。 $$\begin{aligned} S(n, k) &amp;= k![z^k]F_n(z)\\ &amp;= m!\sum_{i=0}^{k}\dfrac{B_i}{i!}\cdot\dfrac{n^{k-i+1}}{(k-i+1)!}\\ &amp;= \dfrac{1}{k+1}\sum_{i=0}^{k}\binom{k+1}{i}B_in^{k-i+1}\end{aligned}$$ 例题未特别说明时，模数均为998244353。 「Luogu 3711」仓鼠的数学题Luogu 3711 给数列 ${a_n}$，求 $Ans(z) = \sum\limits_{k = 0}^{n}(S(z, k) + z^k)a_k$。$n\le 2.5\times 10^5$。 $\sum\limits_{k = 0}^n a_k z^k$ 是个常量可以先扔出来。 $$\begin{aligned} &amp;Ans(z) -\sum\limits_{k = 0}^n a_k z^k\\ &amp;= \sum_{k = 0}^{n}S(z, k)a_k\\ &amp;= \sum_{k = 0}^{n}a_k\dfrac{1}{k+1}\sum_{i=0}^{k}\binom{k + 1}{i}B_i z^{k - i + 1}\\ &amp;= \sum_{k = 0}^{n}a_k k!\sum_{i = 0}^{k} \dfrac{B_i}{i!}\cdot\dfrac{z^{k + 1 - i}}{(k + 1 - i)!}\\ &amp;= \sum_{k = 0}^{n}a_k k!\sum_{i = 1}^{k + 1} \dfrac{B_{k + 1 - i}}{(k + 1 - i)!}\cdot\dfrac{z^i}{i!}\\ &amp;= \sum_{i = 1}^{n + 1}\dfrac{z^i}{i!}\sum_{k = i - 1}^{n}(a_k k!)\dfrac{B_{k + 1 - i}}{(k + 1 - i)!}\end{aligned}$$ 后面那坨是个差卷积，于是翻转一下多项式做完了。 「HDU 6340」Delightful FormulasHDU 6340 给一个大数 $n = \prod\limits_{o = 0}^{m - 1} p_o^{\alpha_o}$ 的分解和正整数 $K$，求 $\sum\limits_{i=1}^{n}[\gcd(i, n) = 1]S(i, K)$。$m\le 20, K\le 10^5, p_o, \alpha_o\le 10^9$。 首先来个莫比乌斯反演，$Ans = \sum\limits_{d|n} \mu(d)\sum\limits_{i=1}^{n/d}S(i\cdot d, K)$。设 $a_i = \dfrac{1}{k + 1}\binom{k + 1}{j}B_{k + 1 - j}$。 $$\begin{aligned} Ans &amp;= \sum_{d|n}\mu(d)\sum_{j=1}^{K+1}a_j d^j \sum_{i = 1}^{n/d} i^j\\ &amp;= \sum_{d|n}\mu(d)\sum_{j=1}^{K+1}a_j d^j \sum_{i=1}^{j+1}(\dfrac{n}{d})^i\dfrac{1}{j + 1}\binom{j + 1}{i}B_{j + 1 - i}\end{aligned}$$ 到这里，枚举 $c = j - i + 1\in[0, K + 1]$： $$\begin{aligned} Ans &amp;= \sum_{d|n}\mu(d)\sum_{c=-}1^{K}d^c\sum_{j=1}^{K+1}a_j n^{j-c} \dfrac{1}{j + 1}\binom{j+1}{c+1}B_{c+1}\\ &amp;= \sum_{c=-1}^{K}B_{c+1}\sum_{j=1}^{K+1}\dfrac{a_j}{j+1}\binom{j+1}{c+1}n^{j-c} \sum_{d|n}d^c\mu(d)\\ &amp;= \sum_{c=0}^{K+1}B_{c}\sum_{j=1}^{K+1}\dfrac{a_j}{j+1}\binom{j+1}{c}n^{j-c+1} \sum_{d|n}d^{c-1}\mu(d)\end{aligned}$$ 发现 $\sum\limits_{d|n}d^c\mu(d)=\prod\limits_{o=0}(1 - p_o)$，所以考虑 $F_c = \sum\limits_{j=1}^{K+1}\dfrac{a_j}{j+1}\binom{j+1}{c}n^{j-c+1}$，我们要对于 $c\in[0, K + 1]$ 全求出来。 $$\begin{aligned} F_c &amp;= \sum_{j=1}^{K+1}\dfrac{a_j}{j+1}\binom{j+1}{c}n^{j-c+1}\\ &amp;= \dfrac{1}{c!}\sum_{j=1}^{K+1}a_j j!\dfrac{n^{j - c + 1}}{(j - c + 1)!}\end{aligned}$$ 又是差卷积，稍微算算发现 $K-j+c\in[-K-1, K]$，所以设 $b_i=\dfrac{n^{K - i + 2}}{(K - i + 2)!}$。就变成求 $F_c = \sum\limits_{j=1}^{K+1}a_j j! b_{K + 1-j+c}$。（这个 $a_i$ 其实拆开形式比较好） 于是做完了。记得乘上一堆麻烦的系数。 不知道为什么板子一直 WA……后来重写了一遍就过了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long i64;typedef unsigned long long u64;#define Templ(T) template &lt;typename T&gt;inline int read() &#123; reg int ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) f ^= (c == '-'), c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define using_mod// const int mod = 998244353;#define mod 998244353#ifdef using_modinline void inc(int &amp;x, const int &amp;y) &#123; x += y; if (x &gt;= mod) x -= mod;&#125;inline void dec(int &amp;x, const int &amp;y) &#123; x -= y; if (x &lt; 0) x += mod;&#125;inline int qmo(reg const int &amp;x) &#123; return x + ((x &gt;&gt; 31) &amp; mod); &#125;inline int ksm(int x, i64 y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = (i64)x * x % mod) if (y &amp; 1) res = (i64)res * x % mod; return res;&#125;#endif&#125; // namespace my_stdusing namespace my_std;#define swap(x, y) (x ^= y ^= x ^= y)const int N = 550010;int LMT = 1;int rev[N], omg[N], inv[N];int fac[N], ifac[N];int l2g[N &lt;&lt; 1];inline void init(const int &amp;n) &#123; fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = 1; FOR(i, 2, n) &#123; inv[i] = (i64)(mod - mod / i) * inv[mod % i] % mod; fac[i] = (i64)fac[i - 1] * i % mod; ifac[i] = (i64)ifac[i - 1] * inv[i] % mod; &#125; l2g[1] = 0; FOR(i, 2, n &lt;&lt; 1) l2g[i] = l2g[i &gt;&gt; 1] + 1;&#125;inline void poly_init(const int &amp;n)&#123; Rint l = 0; while(LMT &lt;= n) LMT &lt;&lt;= 1, ++l; FOR(i, 1, LMT - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)); reg const int t = ksm(3, (mod - 1) &gt;&gt; l); omg[LMT &gt;&gt; 1] = 1; FOR(i, (LMT &gt;&gt; 1) + 1, LMT - 1) omg[i] = (i64)omg[i - 1] * t % mod; ROF(i, (LMT &gt;&gt; 1) - 1, 1) omg[i] = omg[i &lt;&lt; 1]; LMT = l;&#125;inline int get_len(const int &amp;n)&#123; return 1 &lt;&lt; (l2g[n] + 1);&#125;inline void DFT(int *a, const int &amp;n)&#123; static u64 tmp[N]; reg const int fix = LMT - l2g[n]; Rint t; FOR(i, 0, n - 1) tmp[i] = a[rev[i] &gt;&gt; fix]; for(Rint i = 1; i &lt; n; i &lt;&lt;= 1)&#123; for(Rint j = 0; j &lt; n; j += i &lt;&lt; 1)&#123; FOR(k, j, j + i - 1)&#123; t = tmp[i + k] * omg[i + k - j] % mod; tmp[i + k] = tmp[k] + mod - t; tmp[k] += t; &#125; &#125; &#125; FOR(i, 0, n - 1) a[i] = tmp[i] % mod;&#125;inline void IDFT(int *a, const int &amp;n)&#123; reverse(a + 1, a + n); DFT(a, n); reg const int bk = mod - (mod - 1) / n; FOR(i, 0, n - 1) a[i] = (i64)bk * a[i] % mod;&#125;inline void poly_mul(int *a, int *b, int *c, const int &amp;deg)&#123; static int tmp1[N], tmp2[N]; reg const int len = get_len(deg); memcpy(tmp1, a, sizeof(int) * len), memcpy(tmp2, b, sizeof(int) * len); DFT(tmp1, len), DFT(tmp2, len); FOR(i, 0, len - 1) c[i] = (i64)tmp1[i] * tmp2[i] % mod; IDFT(c, len); memset(c + deg, 0, sizeof(int) * (len - deg));&#125;inline void poly_inv(int *a, int *b, const int &amp;deg)&#123; static int tmp[N]; if(deg == 1)&#123; *b = ksm(*a, mod - 2); return; &#125; poly_inv(a, b, (deg + 1) &gt;&gt; 1); reg const int len = get_len(deg &lt;&lt; 1); memcpy(tmp, a, sizeof(int) * deg); memset(tmp + deg, 0, sizeof(int) * (len - deg)); DFT(b, len), DFT(tmp, len); FOR(i, 0, len - 1)&#123; b[i] = (i64)qmo(2ll - (i64)b[i] * tmp[i] % mod) * b[i] % mod; &#125; IDFT(b, len); memset(b + deg, 0, sizeof(int) * (len - deg));&#125;#define M (1 &lt;&lt; 17)int bnl[N], A[N], G[N];int mc, n, K;int pr[20], aph[20], pt[20];inline void work()&#123; K = read(), mc = read(), n = 1; FOR(o, 0, mc - 1)&#123; pr[o] = read(), aph[o] = read(); n = n * (i64)ksm(pr[o], aph[o]) % mod; &#125; reg const int len = get_len((K + 5) * 2); memset(A, 0, sizeof(int) * len); memset(G, 0, sizeof(int) * len); FOR(i, 0, K)&#123; A[K + 1 - i] = (i64)ifac[i] * bnl[i] % mod; &#125; for(Rint i = 1, j = 1; i &lt;= K + 2; ++i)&#123; j = j * (i64)n % mod; G[K + 2 - i] = j * (i64)ifac[i] % mod; &#125; poly_mul(A, G, G, len - 1); Rint ans(0); FOR(o, 0, mc - 1) pt[o] = ksm(pr[o], mod - 2); FOR(c, 0, K + 1)&#123; Rint res = G[c + K + 1] * (i64)bnl[c] % mod * ifac[c] % mod; FOR(o, 0, mc - 1)&#123; res = (i64)res * (1ll - pt[o] + mod) % mod; pt[o] = pt[o] * (i64)pr[o] % mod; &#125; ans = qmo(ans + res - mod); &#125; ans = (i64)fac[K] * ans % mod; printf("%d\n", ans);&#125;int main() &#123; init(M &lt;&lt; 1); poly_init(M &lt;&lt; 1); memcpy(G, ifac + 1, sizeof(int) * M); poly_inv(G, bnl, M); FOR(i, 1, M - 1) bnl[i] = (i64)bnl[i] * fac[i] % mod; bnl[1] = mod - bnl[1]; int esac(read()); while (esac--) work(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>生成函数</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU5451」Best Solver]]></title>
    <url>%2Fblog%2FHDU5451%2F</url>
    <content type="text"><![CDATA[这都啥年代的套路了 题意简述For a given integer $x$ and a given prime number $p$, print$$[(5 + 2\sqrt{6})^{1 + 2^x}]%p$$$[A]$ means the integer part of $A$.$T$ test cases, $T\le 1000, 1\le x&lt; 2^32, p\le 46337$. 主要思路不难发现 $0 &lt; 5 - 2\sqrt{6}&lt; 1$，所以 $[(5 + 2\sqrt{6})^K] + 1 = (5 + 2\sqrt{6})^K + (5 - 2\sqrt{6})^K$。然后根据共轭根式的性质，若 $(5 + 2\sqrt{6})^K = A + B\sqrt{6}$，则 $(5 - 2\sqrt{6})^K = A - B\sqrt{6}$。这东西显然可以维护根式然后快速幂。还有个问题是 $1 + 2^x$ 太大了无法直接快速幂。但注意到我们实际上是在有限域上做计算，然后除了加法单位元（即 $0 + 0\sqrt{6}$）外元素个数是 $p^2 - 1$，所以循环节必然是 $p^2 - 1$ 的因数。于是做完了。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)typedef long long LL;typedef pair&lt;int, int&gt; PII;#define Templ(T) template &lt;typename T&gt;Templ(T) inline T read() &#123; reg T ans = 0; reg char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) ans = ans * 10 + c - '0'; return ans;&#125;&#125; // namespace my_stdusing namespace my_std;#define MP make_pair#define fr first#define sc secondint ksm(Rint x, reg LL y, reg const int p)&#123; Rint res(1); for(; y; y &gt;&gt;= 1, x = (LL)x * x % p) if(y &amp; 1) res = (LL)res * x % p; return res;&#125;#define mul(x, y) \ MP((6ll * x.sc * y.sc + (LL)x.fr * y.fr) % p, \ ((LL)x.fr * y.sc + (LL)x.sc * y.fr) % p)PII ksm(reg PII x, reg LL y, reg const int p)&#123; reg PII res(1, 0); for(; y; y &gt;&gt;= 1, x = mul(x, x)) if(y &amp; 1) res = mul(res, x); return res;&#125;inline void work()&#123; LL n(read&lt;LL&gt;()); int p(read&lt;int&gt;()); int res(ksm(MP(5, 2), ksm(2, n, p * p - 1) + 1, p).fr); printf("%d\n", (res * 2 + p - 1) % p);&#125;int main() &#123; Rint esac = read&lt;int&gt;(); FOR(o, 1, esac)&#123; printf("Case #%d: ", o); work(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF356E」Xenia and String Problem]]></title>
    <url>%2Fblog%2FCF356E%2F</url>
    <content type="text"><![CDATA[大型分类讨论。 题意简述称字符串 $s$ 为Gray的串，仅当满足以下所有条件： $|s|$ 为奇数。 串正中间的字符仅在 $s$ 中出现一次。 要么 $|s| = 1$，要么删去中间的字符，左右是相等的Gray。 给一个字符串 $|S|$，一个字串 $s$ 若为Gray，贡献为 $|s|^2$，否则贡献为 $0$。求更改最多 $1$ 个字符后整个串的最大总贡献。 $|S|\le 10^5$。 [CF 356E] 主要思路设 $n = |S|$。不难发现Gray的长度均为 $2^k - 1$，故总共只有 $O(n\log n)$ 个可能成为Gray的字串。先考虑不修改求总贡献。 考虑 $[s_l, e_r]$ 是否为Gray，假设 $[s_l, e_r] = [s_r, e_r]$ 且均为Gray，则只需判断 $s_{s_r - 1}$ 是否字串 $[s_l, e_r]$ 中只出现一次即可。 求两个字串是否相等，后缀数组求 lcp 即可。 考虑将 $s_i$ 改为 $v$ 会发生什么：减掉先前所有包含 $i$ 的Gray的贡献，再加上所有更改为 $v$ 后新的贡献。 包含 $i$ 的贡献 $c(i)$ 好求，维护差分，每次判断到一个Gray更新即可。 而 $s_i$ 改为 $v$ 后的新贡献 $f(i, v)$ 不好直接求，考虑枚举每个可能为Gray的字串是否更改 $1$ 个字符可变为Gray。 对于一个Gray，仅可能更改中间的位置。 对于左半边右半边均非Gray的串，仅更改一个位置不可能。 对于左右均为Gray且相等，可能可更改中间位置。 对于左右至少有一个为Gray且左右字串仅相差 1 个字符的，可能可以更改该位置，注意同时保证中间位置的字符仅出现一次。 就结束了。使用后缀数组 $O(1)$ lcp，复杂度 $O(\Sigma n\log n)$。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef long long LL;#define Templ(T) template &lt;typename T&gt;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;const int N = 100010;int n;char str[N];int l2g[N];int g[N][26], s[N][26];LL f[N][26], c[N], ans;int a[N];namespace SA&#123;int sa[N], rk[N], oldrk[N &lt;&lt; 1], cnt[N], px[N], id[N], ht[N];int st[20][N];inline int cmp(const int &amp;x, const int &amp;y, const int &amp;w)&#123; return oldrk[x] == oldrk[y] &amp;&amp; oldrk[x + w] == oldrk[y + w];&#125;inline void build()&#123; Rint m = 127, p = 0, w = 0; FOR(i, 1, n) ++cnt[rk[i] = str[i]]; FOR(i, 1, m) cnt[i] += cnt[i - 1]; ROF(i, n, 1) sa[cnt[rk[i]]--] = i; for(w = 1; p &lt; n; w &lt;&lt;= 1, m = p)&#123; p = 0; ROF(i, n, n - w + 1) id[++p] = i; FOR(i, 1, n) if(sa[i] &gt; w) id[++p] = sa[i] - w; memset(cnt, 0, sizeof(cnt)); FOR(i, 1, n) ++cnt[px[i] = rk[id[i]]]; FOR(i, 1, m) cnt[i] += cnt[i - 1]; ROF(i, n, 1) sa[cnt[px[i]]--] = id[i]; p = 0; memcpy(oldrk, rk, sizeof(rk)); FOR(i, 1, n)&#123; rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p; &#125; &#125; //build sa[], rk[] p = 0; FOR(i, 1, n)&#123; if(p) --p; while(str[i + p] == str[sa[rk[i] - 1] + p]) ++p; ht[rk[i]] = p; &#125; //build ht[] //ht[i] = lcp(sa[i], sa[i - 1]) FOR(i, 1, n) st[0][i] = ht[i]; FOR(i, 2, n + 1) l2g[i] = l2g[i &gt;&gt; 1] + 1; FOR(i, 1, l2g[n])&#123; FOR(j, 1, n - (1 &lt;&lt; i) + 1)&#123; st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 &lt;&lt; (i - 1))]); &#125; &#125; // FOR(i, 1, n)&#123; // FOR(j, sa[i], n) putchar(str[j]); // putchar('\n'); // &#125;&#125;inline int st_q(Rint x, Rint y)&#123; Rint k = l2g[y - x + 1]; y -= (1 &lt;&lt; k) - 1; return min(st[k][x], st[k][y]);&#125;inline int lcp(Rint x, Rint y)&#123; if(x == y) return n - x + 1; x = rk[x], y = rk[y]; if(x &gt; y) swap(x, y); // if(!x || !y) return 0; return st_q(x + 1, y);&#125;&#125;#define lsp(x, y) SA::lcp(x, y)#define len ((1 &lt;&lt; (t - 1)) - 1)#define ls (i)#define rs (i + (1 &lt;&lt; (t - 1)))#define le (i + (1 &lt;&lt; (t - 1)) - 2)#define re (i + (1 &lt;&lt; t) - 2)#define LEN ((1 &lt;&lt; t) - 1)inline int S(int l, int r, int o)&#123; return s[r][o] - s[l - 1][o];&#125;inline LL sqr(int x)&#123; return (LL)x * x;&#125;int main() &#123; scanf("%s", str + 1); n = strlen(str + 1); FOR(i, 1, n) g[i][1] = 1, a[i] = str[i] - 'a'; SA::build(); FOR(i, 1, n) FOR(o, 0, 25)&#123; s[i][o] = s[i - 1][o] + (a[i] == o); &#125; const int lim = l2g[n + 1]; c[1] = 1; ans = n; FOR(t, 2, lim) FOR(i, 1, n - (1 &lt;&lt; t) + 2)&#123; if(g[ls][t - 1] &amp;&amp; g[rs][t - 1] &amp;&amp; lsp(ls, rs) &gt;= len &amp;&amp; S(ls, re, a[rs - 1]) == 1)&#123; g[ls][t] = 1; c[ls] += sqr(LEN), c[re + 1] -= sqr(LEN); ans += sqr(LEN); FOR(o, 0, 25) if(a[rs - 1] != o &amp;&amp; S(ls, re, o) == 0) f[rs - 1][o] += sqr(LEN); &#125; &#125;//get g[][], c[], ans // FOR(t, 1, lim) FOR(i, 1, n - (1 &lt;&lt; t) + 2)&#123; // if(g[i][t]) printf(":%d %d\n", i, t); // &#125; FOR(t, 2, lim) FOR(i, 1, n - (1 &lt;&lt; t) + 2) if(!g[i][t])&#123; if(g[ls][t - 1] &amp;&amp; g[rs][t - 1])&#123; if(lsp(ls, rs) &gt;= len)&#123; FOR(o, 0, 25) if(a[rs - 1] != o &amp;&amp; S(ls, re, o) == 0) f[rs - 1][o] += sqr(LEN); // printf("1: %d %d\n", i, t); &#125;else&#123; int h = lsp(ls, rs); if((h == len - 1 || lsp(ls + h + 1, rs + h + 1) + h + 1 &gt;= len) &amp;&amp; S(ls, re, a[rs - 1]) == int(a[rs + h] == a[rs - 1] || a[ls + h] == a[rs - 1]) + 1)&#123; // printf("3: %d %d %d %d\n", i, t, ls + h, rs + h); f[ls + h][a[rs + h]] += sqr(LEN), f[rs + h][a[ls + h]] += sqr(LEN); if(a[ls + h] == a[rs - 1]) f[rs + h][a[ls + h]] -= sqr(LEN); if(a[rs + h] == a[rs - 1]) f[ls + h][a[rs + h]] -= sqr(LEN); &#125; &#125; &#125;else if(g[ls][t - 1] + g[rs][t - 1] == 1)&#123; int h = lsp(ls, rs); if((h == len - 1 || (lsp(ls + h + 1, rs + h + 1) + h + 1 &gt;= len)) &amp;&amp; S(ls, re, a[rs - 1]) == (((g[ls][t - 1] ? a[rs + h] : a[ls + h]) == a[rs - 1]) ? 2 : 1))&#123; // printf("2: %d %d %d\n", i, t, (g[ls][t - 1] ? rs : ls) + h); (g[ls][t - 1] ? f[rs + h][a[ls + h]] : f[ls + h][a[rs + h]]) += sqr(LEN); &#125; &#125; &#125;//get f[][] FOR(i, 1, n) c[i] += c[i - 1]; reg LL res = ans; // printf("%lld\n", ans); FOR(i, 1, n) FOR(o, 0, 25) if(a[i] != o)&#123; chkmax(res, ans - c[i] + 1 + f[i][o]); &#125; printf("%lld\n", res); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1063E」Lasers and Mirrors]]></title>
    <url>%2Fblog%2FCF1063E%2F</url>
    <content type="text"><![CDATA[题意简述一个 $n\times n$ 的网格，在每列上方各有一个激光发射器，下方各有一个激光接收器。 第 $i$ 个接收器希望接收来自第 $p_i$ 个发射器的激光。你可以在一些位置 45 度放置镜子，使得最多的接收器满足其需求。 求出最多数量并给出一种放置镜子的方案，保证 ${a_n}$ 为排列，$n\le 1000$。 [CF 1063E] 主要思路简单构造题。 容易发现除非对于任意 $i$ 均有 $i = p_i$ 时答案为 $n$，其余答案均为 $n - 1$。 等价地，设第 $i$ 个发射器希望射到 $a_i$ 列。 不妨钦定第 $1$ 个发射器无法满足，则对于点 $1$ 所在的环 $S$，容易使用 $|S| - 1$ 行对该环中的其他元素均满足，从第 $a_1$ 个发射器开始，依次处理即可。 对任意其他环 $T$，可以使用 $|T|$ 行使其中所有元素均满足：找到一个位置使得 $x &gt; a_x, a_x &lt; a_{a_x}$，则可以利用第一列满足该环——从第 $a_x$ 发射器开始依次处理即可。 以下是一个简单例子： 123456789a:4 6 2 7 3 5 1. . . . . . ./ . / . . . .. . / . / . .. . . . / / .\ \ . . . \ ./ . . . . . /. . . \ . . \ 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)inline int read() &#123; Rint ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) &#123; f ^= (c == '-'); c = getchar(); &#125; for (; isdigit(c); c = getchar()) ans = ans * 10 + c - '0'; return f ? ans : -ans;&#125;&#125; // namespace my_stdusing namespace my_std;const int N = 1010;#define pcr(x) putchar(x)#define pb push_backinline void write(int x)&#123; static char tmp[10], *t = tmp; do&#123; *++t = (x % 10) ^ 48, x /= 10; &#125;while(x); while(t != tmp) pcr(*t--); pcr(10);&#125;int n, a[N], b[N];vector&lt;int&gt; v[N];char g[N][N];// '\' -// '/' +inline bool Identity()&#123; FOR(i, 1, n) if(a[i] != i) return 0; return 1;&#125;inline int Check(int i)&#123; int x = i; ROF(j, n, 1) if(g[j][x] != '.')&#123; if(g[j][x] == '/')&#123; ++x; while(x &lt;= n &amp;&amp; g[j][x] != '/') ++x; if(x &gt; n)&#123; printf("%d %d: %d +\n", i, b[i], j); return 0; &#125; &#125; else&#123; --x; while(x &gt; 0 &amp;&amp; g[j][x] != '\\') --x; if(x &lt; 1)&#123; printf("%d %d: %d -\n", i, b[i], j); return 0; &#125; &#125; &#125; if(x != b[i]) printf("%d %d %d\n", i, b[i], x); return x == b[i];&#125;inline void Check()&#123; FOR(i, 1, n) b[a[i]] = i; FOR(i, 1, n) Check(i);&#125;int main() &#123; n = read(); FOR(i, 1, n) a[read()] = i; if(Identity())&#123; write(n); FOR(i, 1, n)&#123; FOR(i, 1, n) pcr('.'); pcr(10); &#125; return 0; &#125; write(n - 1); Rint c = n; &#123; int x = a[1]; while(x != 1)&#123; if(x &lt; a[x]) v[c].pb(-x), v[c].pb(-a[x]); else v[c].pb(x), v[c].pb(a[x]); b[x] = 1, x = a[x], --c; &#125; &#125; FOR(i, 2, n) if(!b[i] &amp;&amp; i != a[i])&#123; const int t = c; int y = i; while(y &lt; a[y] || a[y] &gt; a[a[y]]) y = a[y]; int x = a[y]; while(x != y)&#123; if(x &lt; a[x]) v[c].pb(-x), v[c].pb(-a[x]); else v[c].pb(x), v[c].pb(a[x]); b[x] = 1, x = a[x], --c; &#125; v[c].pb(1), v[c].pb(x); v[t].pb(-1); b[y] = 1, --c; &#125; FOR(i, 1, n) FOR(j, 1, n) g[i][j] = '.'; FOR(i, 1, n)&#123; for(int x: v[i])&#123; x &gt; 0 ? g[i][x] = '/' : g[i][-x] = '\\'; &#125; &#125; FOR(i, 1, n)&#123; FOR(j, 1, n) pcr(g[i][j]); pcr(10); &#125; // Check(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫队二次离线学习笔记]]></title>
    <url>%2Fblog%2F%E8%8E%AB%E9%98%9F%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在进行莫队时，若不能快速地在线计算移动区间后的贡献变化，可以考虑将 $O(n\sqrt{n})$ 个移动再次离线，每次 $O(1)$ 求出贡献变化。 这就是所谓莫队二次离线。 注意这里贡献要求具有可减性，因为我们每次求的是贡献变化。 思路目前，运用该 trick 的题目通常为求区间中合法点对数量。 设 $S([l_1, r_1], [l_2, r_2])$ 为前面的数在 $[l_1, r_1]$ 位置，后面的数在 $[l_2, r_2]$ 位置所组成的合法点对数。 考虑从上一个区间 $[l_1, r_1]$ 转移至当前需求区间 $[l_2, r_2]$ 的过程。不失一般性地，设 $l_1 &lt; l_2, r_1 &lt; r_2$（其他情况可类似推出）。 $$\begin{aligned} &amp;\ S([l, r], [l, r])\\ &amp;= S([1, r], [1, r]) + S([l, n], [l, n])\\ &amp;+ S([1, l - 1], [r + 1, n]) - S([1, n], [1, n])\end{aligned}$$ 注意到： $$\begin{aligned} &amp;\ S([1, l_2 - 1], [r_2 + 1, n]) - S([1, l_1 - 1], [r_1 + 1, n])\\ &amp;= S([l_1, l_2 - 1], [r_2 + 1, n]) - S([1, l_1 - 1], [r_1 + 1, r_2])\end{aligned}$$ 所以： $$\begin{aligned} &amp;\ S([l_2, r_2], [l_2, r_2]) - S([l_1, r_1], [l_1, r_1])\\ &amp;= S([1, r_2], [1, r_2]) - S([1, r_1], [1, r_1]) - S([l_1, n], [l_1, n]) + S([l_2, n], [l_2, n]) \\ &amp;- S([1, l_1 - 1], [r_1 + 1, r_2]) + S([l_1, l_2 - 1], [r_2 + 1, n])\end{aligned}$$ 虽然基本每个题都是这个式子，但因为太长实在没有记的必要，直接画出1,n,l_1,r_1,l_2,r_2现推往往更快。 下面是原来的较为繁琐的推法： $$\begin{aligned} &amp;\ S([l_2, r_2], [l_2, r_2]) - S([l_1, r_1], [l_1, r_1])\\ &amp;= S([l_2, r_2], [r_1 + 1, r_2]) - S([l_1, l_2 - 1], [l_1, r_1])\\ &amp;= (S([1, r_2], [r_1 + 1, r_2]) - S([1, l_1 - 1], [r_1 + 1, r_2]))\\ &amp;- (S([l_1, l_2 - 1], [l_1, n]) - S([l_1, l_2 - 1], [r_2 + 1, n]))\\ &amp;= S([1, r_2], [1, r_2]) - S([1, r_1], [1, r_1]) - S([l_1, n], [l_1, n]) + S([l_2, n], [l_2, n]) \\ &amp;- S([1, l_1 - 1], [r_1 + 1, r_2]) + S([l_1, l_2 - 1], [r_2 + 1, n])\end{aligned}$$ 故，不失一般性地，只需考虑 $S([1, r], [1, r]), S([1, l_1 - 1], [r_1 + 1, r_2])$ 的求法。前者一般因题而异且不为难点，故本处只考虑后者。 不妨为每个位置开一个vector。将一个 $S([1, l_1 - 1], [r_1 + 1, r_2])$ 的询问记录在第 $l_1 - 1$ 个vector上。 然后使用可以用类似扫描线的做法，依次处理每个vector上的询问， 例题「Ynoi2019模拟赛」Yuno loves sqrt technology IILuogu 5047 给定长 $O(n)$ 序列，离线 $O(n)$ 次查询区间逆序对，希望做到 $O(n\sqrt{n})$ 复杂度。 主要思路显然利用树状数组有复杂度 $O(n\sqrt{n}\log n)$ 的莫队，且瓶颈在于计算移动区间后的贡献变化。 $S([1, r], [1, r])$ 可以直接使用树状数组求出。考虑 $S([1, l_1 - 1], [r_1 + 1, r_2])$。 套上上面那套东西，则问题转化为维护可重集，要求 $O(n\sqrt{n})$ 次查询比某数小的元素个数且有 $O(n)$ 次加点。 利用一个值域分块即可做到 $O(\sqrt{n})$ 加点，$O(1)$ 查询。 故总时间复杂度 $O(n\sqrt{n})$，空间 $O(n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define Templ(T) template &lt;typename T&gt;typedef long long i64;#define MMR (1 &lt;&lt; 23)static char InB[MMR], *In_s = InB;static char OutB[MMR], *Out_s = OutB;inline void F_In()&#123; fread(InB, 1, MMR, stdin); &#125;inline void F_Out()&#123; fwrite(OutB, 1, Out_s - OutB, stdout); &#125;inline int read()&#123; Rint res = 0; for(; *In_s &lt; 48; ++In_s); for(; *In_s &gt; 47;) res = res * 10 + (*In_s++ &amp; 15); return res;&#125;inline void write(reg i64 x)&#123; static char tmp[20], *t = tmp; do&#123; *++t = (x % 10) ^ 48, x /= 10; &#125;while(x); while(t != tmp) *Out_s++ = *t--; *Out_s++ = 10;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;&#125; // namespace my_stdusing namespace my_std;#define N 100010#define BN 330#define M 317#define PB push_backint n, m;int a[N], bl[N], Lb[BN], Rb[BN];i64 ans[N];i64 sumL[N], sumR[N];//前/后 i 个有多少逆序对int Sb[BN], Cb[N];//块前/后缀和，点在块内前/后缀和struct BiT&#123; int a[N]; inline void upd(int x)&#123; for(; x &lt;= n; x += x &amp; (-x)) ++a[x]; &#125; inline int qry(int x)&#123; Rint res = 0; for(; x; x ^= x &amp; (-x)) res += a[x]; return res; &#125;&#125;T;struct Q&#123; int l, r, id; inline bool operator &lt;(const Q &amp;rhs)const&#123; return bl[l] == bl[rhs.l] ? ((bl[l] &amp; 1) ? r &gt; rhs.r : r &lt; rhs.r) : l &lt; rhs.l; &#125;&#125;q[N];struct Node&#123; int l, r, i, v;&#125;;vector&lt;Node&gt; vL[N], vR[N];void init()&#123; n = read(), m = read(); int *aa = new int[N]; FOR(i, 1, n) aa[i] = a[i] = read(); sort(aa + 1, aa + n + 1); FOR(i, 1, n) a[i] = lower_bound(aa + 1, aa + n + 1, a[i]) - aa; delete aa; Rint c = M; FOR(i, 1, n)&#123; bl[i] = bl[i - 1], ++c; if(c &gt; M) Rb[bl[i]] = i - 1, Lb[++bl[i]] = i, c = 1; &#125; Rb[bl[n]] = n; FOR(i, 1, m) q[i].l = read(), q[i].r = read(), q[i].id = i; sort(q + 1, q + m + 1); q-&gt;l = 1; FOR(i, 1, n) sumL[i] = sumL[i - 1] + i - 1 - T.qry(a[i]), T.upd(a[i]); memset(T.a, 0, sizeof(T.a)); ROF(i, n, 1) sumR[i] = sumR[i + 1] + T.qry(a[i] - 1), T.upd(a[i]);&#125;int main() &#123; F_In(); init(); FOR(i, 1, m)&#123; ans[i] = sumL[q[i].r] - sumL[q[i - 1].r] + sumR[q[i].l] - sumR[q[i - 1].l]; if(q[i].r &gt; q[i - 1].r)&#123; vR[q[i - 1].l - 1].PB((Node)&#123;q[i - 1].r + 1, q[i].r, i, -1&#125;); &#125; else if(q[i].r &lt; q[i - 1].r)&#123; vR[q[i - 1].l - 1].PB((Node)&#123;q[i].r + 1, q[i - 1].r, i, 1&#125;); &#125; if(q[i].l &lt; q[i - 1].l)&#123; vL[q[i].r + 1].PB((Node)&#123;q[i].l, q[i - 1].l - 1, i, -1&#125;); &#125; else if(q[i].l &gt; q[i - 1].l)&#123; vL[q[i].r + 1].PB((Node)&#123;q[i - 1].l, q[i].l - 1, i, 1&#125;); &#125; &#125;//二次离线 FOR(i, 1, n)&#123; reg const int p = bl[a[i]]; FOR(v, 1, p - 1) ++Sb[v]; FOR(v, Lb[p], a[i]) ++Cb[v]; for(reg Node &amp;x: vR[i])&#123; reg i64 res = 0; FOR(j, x.l, x.r) res += Sb[bl[a[j] + 1]] + Cb[a[j] + 1]; x.v &gt; 0 ? (ans[x.i] += res) : (ans[x.i] -= res); &#125; &#125; memset(Cb, 0, sizeof(Cb)), memset(Sb, 0, sizeof(Sb)); ROF(i, n, 1)&#123; reg const int p = bl[a[i]]; ROF(v, M, p + 1) ++Sb[v]; ROF(v, Rb[p], a[i]) ++Cb[v]; for(reg Node &amp;x: vL[i])&#123; reg i64 res = 0; FOR(j, x.l, x.r) res += Sb[bl[a[j] - 1]] + Cb[a[j] - 1]; x.v &gt; 0 ? (ans[x.i] += res) : (ans[x.i] -= res); &#125; &#125; reg i64 *res = new i64[N]; FOR(i, 1, m) res[q[i].id] = ans[i] += ans[i - 1]; FOR(i, 1, m) write(res[i]); delete res; F_Out(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>Ynoi</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF506E」Mr. Kitayuta's Gift]]></title>
    <url>%2Fblog%2FCF506E%2F</url>
    <content type="text"><![CDATA[队爷的 pdf 题解根本看不懂，，， 题意简述给定一个小写字符串 $s$ 与正整数 $n$。$|s|\le 200, n\le 10^9$。 要求在 $s$ 中插入恰好 $n$ 个小写字符使其为回文串的方案数，对 $10^4 + 7$ 取模。 [CF 506E] 主要思路在这里只考虑 $n + |s|$ 为偶数的情况（因为实际上两者差不多）。 考虑 dp。设 $f(i, l, r)$ 为只考虑最终回文串的前 $i$ 与后 $i$ 个字符，它们与 $s$ 尽可能匹配后还剩下 $[l, r]$ 这段区间的方案数。然后顺便设 $g(i)$ 为只考虑最终回文串的前 $i$ 与后 $i$ 个字符已经将 $s$ 完全匹配的方案数。 显然转移有： $s_l = s_r, r - l\le 1$:$$\begin{aligned} g(i + 1)&amp;\leftarrow f(i, l, r)\\ f(i + 1, l, r)&amp;\leftarrow 25\cdot f(i, l, r)\end{aligned}$$ $s_l = s_r, r - l &gt; 1$:$$\begin{aligned} f(i + 1, l + 1, r - 1)&amp;\leftarrow f(i, l, r)\\ f(i + 1, l, r)&amp;\leftarrow 25\cdot f(i, l, r)\end{aligned}$$ $s_l \ne s_r$:$$\begin{aligned} f(i + 1, l + 1, r)&amp;\leftarrow f(i, l, r)\\ f(i + 1, l, r - 1)&amp;\leftarrow f(i, l, r)\\ f(i + 1, l, r)&amp;\leftarrow 24\cdot f(i, l, r)\end{aligned}$$ $g$:$$g(i + 1)\leftarrow 26\cdot g(i)$$ 把这个状态数 $O(|s|^2)$ 的 dp 强行矩乘优化可得到 $O(|s|^6\log n)$ 的复杂度，但显然无法通过此题。 观察，可以发现这个 dp 可以表示为在一个有限状态自动机上匹配的过程。我们不妨将终点设为 $T$，转移过程的点设为 $(l, r)$。 例如如下为abaac的转移图： 令对于所有 $(l, r)$ 满足 $s_l = s_r$，设其为一类点（上图粉色），否则设为二类点（上图蓝色）。 由于除了 $l = r$ 以外，经过一个一类点会使得未匹配长度减少 $2$，故若一条链上经过了 $x$ 个二类点，则应经过 $\lceil\frac{|s| - i}{2}\rceil$ 个一类点。所以本质不同的链只有 $O(|s|)$ 条。 不妨设 $h(i, l, r)$ 为起点到 $(l, r)$ 经过 $i$ 个二类点的路径的数量。显然 $h(i, l, r)$ 可以 $O(|s|^3)$ 记忆化搜索求出。 此时对每一条链矩乘优化即可得到 $O(|s|^4\log n)$ 的总复杂度，仍无法通过此题。 考虑能否将这 $O(|s|)$ 条链压缩成 $O(|s|)$ 个点。 答案是能的。只要我们先各作一条一类点、二类点的链，再将每两个二类点连向一个对应的一类点即可。 转移系数等类似地可以 $O(|s|^3)$ 求出。故矩乘优化总时间复杂度为 $O(|s|^3\log n)$。 不要忘记上述讨论均基于 $n + |s|$ 为偶数。若 $n + |s|$ 为奇数如何？ 不难发现，除了最后一步转移（即最终串只剩中间位没有确定时）不能从 $s_l = s_r, l + 1 = r$ 的点转移过来其他均相同。 故在上述图中去掉 $T$ 的自环，并仅保留最后从未匹配长度为 $2$ 的一类点转移至终点的链，再做一次矩乘优化即得到多算的方案数。 参考代码难写，，， （作上面两幅图的素材被扔到graph.7z里了，不过都是 mspaint 手撸大概也没什么保存的必要）]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>Codeforces</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构题的一些小trick]]></title>
    <url>%2Fblog%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8Ftrick%2F</url>
    <content type="text"><![CDATA[鉴于许多数据结构题都是一些套路的组合，把一些坑过本人的 trick 记录下来。 在没有特别说明的情况下，$n$ 均为维护元素个数，$W = 10^9$。 可重集$O(1)$ 单点加删，$O(\sqrt{n})$ 第k大，值域 $O(n)$对值域分块，询问枚举答案在哪一块即可。 $O(\sqrt{n})$ 单点加删，$O(1)$ 第k大，值域 $O(W)$按顺序每 $\sqrt{n}$ 个数分一块，块状链表保证加删点后每个块长不变即可。 $O(1)$ 单点删除，均摊 $O(1)$ 查某数前驱，值域 $O(n)$维护下每个数的前驱与这个数是否仍存在，不存在就继续往前跳，每个数被删只会改变 1 个数的前驱，故均摊 $O(1)$。（没发现怎么搞单点加入） $O(\sqrt{n})$ 单点加删，均摊 $O(1)$ 查某数前驱，值域 $O(n)$对值域分块，对每一块维护这一块之前有数的第一块，块内每个数维护块内前驱。加入删除暴力重构该块内部关系与该块与其他块之间关系。 至于能不能做到两种操作均 $O(1)$，我也不知道。 $O(\log W)$ 全体加值，$O(\log W)$ 查与某数异或所得最值，值域 $O(W)$一棵 trie 搞定，细节可以现场推。（记这个是因为某次把全体加值当成了两个log的） 树对每个节点最大化其子树外大小 $O(1)$ 点集的价值假如我们可以复杂度较优地维护节点的集合，并支持加入节点与求出节点集合中价值最大的点集，则可以先对全树求出价值最大的点集。容易发现只有价值最大的点集中的 $O(1)$ 个节点到根的路径的答案不确定。 对于一条从根出发的路径，显然可以再次维护节点集合，在 $O(n)$ 次加入后得出该路径上每个节点的答案。 其他小东西一些和为 $n$ 的非负整数中，不小于 $\sqrt{n}$ 的最多 $\sqrt{n}$ 个。 $\sum\limits_{x\cdot y\le n} 1 = O(n\log n)$]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>log数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成函数学习笔记(2)]]></title>
    <url>%2Fblog%2F%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%2F</url>
    <content type="text"><![CDATA[坑]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>生成函数</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[果然我的正则表达式写错了]]></title>
    <url>%2Fblog%2F20200802%2F</url>
    <content type="text"><![CDATA[Q：为什么玩春物哏，你不是还没看吗？A：因为我整这玩意就是为了下载春物啊…… 没错，为了在 wenku8 上下载全篇小说，这个人用 C++ 写了个小脚本。 甚至这人不会多线程，下载只会用curl。 然后下载速度巨慢，爬爬爬。 我们姑且不提某个已经完善然而只能下epub的下载器。 wenku8 除了无版权小说的插图下载以外都被人研究透彻了。现在下载无版权小说插图还是只能跑几十万次请求。 已解决问题正则表达式从不会到不会有人说用正则表达式徒增负担，但没正则我更不会写。 于是 30min 修炼正则表达式基础，玩 RegExr（顺带一提这网站在今天下午证书过期了，真是够巧的）。 curl从不会到略懂啊这个东西好像还真是学学就行。 大概就主要看了这一篇。 在C++中实现编码互转至今不会，所以脚本中完全没有关于这个的。 code过程经历太多，只留下这份代码来表示我的付出终于有了些回报。 编译后运行，输入文章 id 即可观察到它慢慢爬爬爬。 顺带一提由于上面说的原因不能下载无版权小说的插图。 命名格式不规范警告.webp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//author: Okazaki Yumemi//v0.0.1//c++11#include&lt;bits/stdc++.h&gt;using namespace std;inline string IntToString(const int &amp;x)&#123; if(x &lt; 0) return "-" + IntToString(-x); if(x &lt; 10) return string(1, char(x ^ 48)); return IntToString(x / 10) + char((x % 10) ^ 48);&#125;inline int StringToInt(const string &amp;x)&#123; const int &amp;len = x.length(); assert(isdigit((char)x[len - 1])); if(len == 1)&#123; return (char)x[0] ^ 48; &#125; return StringToInt(x.substr(0, len - 1)) * 10 + ((char)x[len - 1] ^ 48);&#125;const regex ChapterPattern("href=\"\\d&#123;1,9&#125;.htm\""), VolumePattern("colspan=\"4\""), IllustPattern("src=\"http://picture.wenku8.com/pictures/\\d&#123;1,9&#125;/\\d&#123;1,9&#125;/\\d&#123;1,9&#125;/\\d&#123;1,9&#125;.(jpg|png)\""), IllustNamePattern("\\d&#123;1,9&#125;.(jpg|png)");typedef string::const_iterator iter;ifstream Origin;string Contents;smatch ChapterResult, VolumeResult, VolumeNextResult;string BasicUrl, ArticleName;void IllustDownload(const string &amp;VolumeName)&#123; ifstream IllustOrigin(".\\illust.htm"); string IllustContents((istreambuf_iterator&lt;char&gt;(IllustOrigin)), istreambuf_iterator&lt;char&gt;()); smatch IllustResult, FileNameResult; iter IllustBegin = IllustContents.begin(), IllustEnd = IllustContents.end(); while(regex_search(IllustBegin, IllustEnd, IllustResult, IllustPattern))&#123; string IllustGet(IllustResult[0], 5, IllustResult[0].length() - 6); regex_search(iter(IllustGet.begin()), iter(IllustGet.end()), FileNameResult, IllustNamePattern); string DownloadIllust = "curl -o .\\" + VolumeName + "\\" + string(FileNameResult[0]) + " " + IllustGet; // cout &lt;&lt; DownloadIllust &lt;&lt; "\n"; system(DownloadIllust.c_str()); // puts(DownloadIllust.c_str()); IllustBegin = IllustResult[0].second; &#125;&#125;void ArticleInit()&#123; int ArticleId; puts("Article id:"); // scanf("%d", &amp;ArticleId); cin &gt;&gt; ArticleId; ArticleName = IntToString(ArticleId); BasicUrl = "https://www.wenku8.net/novel/" + IntToString(ArticleId / 1000) + "/" + ArticleName + "/"; // string ArticleDescriptionDownload = "curl -v " + BasicUrl + "index.htm &gt; origin.htm"; string ArticleDescriptionDownload = "curl " + BasicUrl + "index.htm &gt; origin.htm"; // system("rm origin.htm"); system(ArticleDescriptionDownload.c_str());&#125;void ArticleDownload()&#123; Origin = ifstream(".\\origin.htm"); Contents = string((istreambuf_iterator&lt;char&gt;(Origin)), istreambuf_iterator&lt;char&gt;()); int VolumeNow = 0; iter VolumeIterBegin = Contents.begin(), VolumeIterEnd = Contents.end(); iter ChapterIterBegin, ChapterIterEnd; VolumeIterBegin = regex_search(VolumeIterBegin, VolumeIterEnd, VolumeNextResult, VolumePattern) ? VolumeNextResult[0].second : VolumeIterEnd; while(VolumeIterBegin &lt; VolumeIterEnd)&#123; ++VolumeNow; string VolumeName = IntToString(VolumeNow); // printf("Vol: %d\n", VolumeNow); string MkVolumeDir = "mkdir " + VolumeName; system(MkVolumeDir.c_str()); VolumeResult = VolumeNextResult; bool LastVolume = !regex_search(VolumeIterBegin, VolumeIterEnd, VolumeNextResult, VolumePattern); ChapterIterBegin = VolumeIterBegin; VolumeIterBegin = ChapterIterEnd = LastVolume ? VolumeIterEnd : VolumeNextResult[0].second; string ChapterGet, UrlName; while(regex_search(ChapterIterBegin, ChapterIterEnd, ChapterResult, ChapterPattern))&#123; ChapterGet = string(ChapterResult[0], 6, ChapterResult[0].length() - 11); UrlName = IntToString(StringToInt(ChapterGet) - 1); // cout &lt;&lt; UrlName &lt;&lt; "\n"; string DownloadUTF8 = "curl -o \".\\" + VolumeName + "\\" + ChapterGet + " utf8.txt\" \"http://dl.wenku8.com/packtxt.php?aid=" + ArticleName + "&amp;vid=" + UrlName + "&amp;charset=utf8\""; string DownloadGBK = "curl -o \".\\" + VolumeName + "\\" + ChapterGet + " gbk.txt\" \"http://dl.wenku8.com/packtxt.php?aid=" + ArticleName + "&amp;vid=" + UrlName + "&amp;charset=gbk\""; string DownloadBIG5 = "curl -o \".\\" + VolumeName + "\\" + ChapterGet + " big5.txt\" \"http://dl.wenku8.com/packtxt.php?aid=" + ArticleName + "&amp;vid=" + UrlName + "&amp;charset=big5\""; system(DownloadUTF8.c_str()); system(DownloadGBK.c_str()); system(DownloadBIG5.c_str()); // puts(DownloadUTF8.c_str()); // puts(DownloadGBK.c_str()); // puts(DownloadBIG5.c_str()); ChapterIterBegin = ChapterResult[0].second; &#125; // system("rm illust.htm"); // string DownloadIllust = "curl -v " + BasicUrl + ChapterGet + ".htm &gt; illust.htm"; string DownloadIllust = "curl " + BasicUrl + ChapterGet + ".htm &gt; illust.htm"; system(DownloadIllust.c_str()); IllustDownload(VolumeName); // cout &lt;&lt; DownloadIllust &lt;&lt; "\n"; &#125;&#125;int main()&#123; ArticleInit(); ArticleDownload(); return 0;&#125; 未解决多线程下载不会，咕了。 部分文章的vid非章节号减去1正解也许是章节号 -1,0,+1 都有可能。 这个下次来修。 断点续传偶尔来个网不稳就会出现 Time Out，被迫全部重下。 所以啥时候写个断点续传啊（]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmder初探]]></title>
    <url>%2Fblog%2Fcmder%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[我，一直有个梦想，就是在 Windows 下摆脱 cmd。 终于我这一天被它弄得心态崩溃，整了一个 cmder 来玩。 这啥这里有个详细的初步介绍。 好吧，这大概是个 Win 下的可移植的终端的整合包，让你随身携带命令别名、颜色主题之类的。 然后这里主要用来记录使用 cmder 遇到的一些问题。 λ很炫，但也很屑由于 cmder 将λ作为命令提示符，稍微上下键查看下前后的命令就会多出来一个无法删除的符号，令人谔谔。 于是vendor\clink.lua里面把某一行（因版本不同而不同，行开头是local cmder_prompt =）中的{lamb}改为$即可解决 cmd 的命令提示符问题。 bash 的命令提示符就麻烦些，要在vendor\git-for-windows\etc\profile.d\git-prompt.sh把某一行PS1=&quot;$PS1&quot;&#39;λ &#39; # prompt: always λ改为PS1=&quot;$PS1&quot;&#39;$ &#39; # prompt: always $就好了。 输入中文光标出问题若使用的是 Git，在vendor\profile.ps1里找到下面这一行： 1Microsoft.PowerShell.Utility\Write-Host &quot;`nλ &quot; -NoNewLine -ForegroundColor &quot;DarkGray&quot; λ改成$就好了。 隐藏 history正如 Linux 中国的这篇博客，Linux 下可以方便地隐藏 bash 记录。那么 Cmder 的 cmd，以及 git for windows 呢？ cmd 隐藏 historycmd 的 history 都在config\.history里，可以直接看到自己的history。 然后进config\settings，不难找到history_file_lines的行，是历史记录的保存条数。下面的history_ignore_space是一个bool变量，为1时可以通过在命令前加上一个空格（）来避免命令被加入history。 git for windows 隐藏 historygit for windows 的历史都在~\.bash_history里。在同一目录下，还能看见.bash_profile，即全局配置文件。 在里面塞进去一行export HISTCONTROL=ignorespace，即可将通过命令前加上来避免命令被加入history。 实际上，HISTCONTROL有以下选项： 选项 效果 ignoredup 默认，忽略重复命令 ignorespace 忽略所有开头的命令 ignoreboth ignoredups和ignorespace的组合 erasedups 删除重复命令]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Vim里摸爬滚打]]></title>
    <url>%2Fblog%2F%E5%9C%A8Vim%E9%87%8C%E6%91%B8%E7%88%AC%E6%BB%9A%E6%89%93%2F</url>
    <content type="text"><![CDATA[你校曾经全是 Emacs 党，直到近两年出现了我这个用 Vim 的沙雕，和某个进队的 Gedit 神必壬。 至于为什么使用 Vim，一方面是想改善你校只有 Emacs 人的环境，一方面是想找点乐子。 于是开始看简明 Vim 练级攻略，顺便把基本操作扔到自己博客里。 简易使用安装 Vim 并启动后在 Normal 模式下，这个模式下所有的键就是功能键。 注意&lt;Ctrl&gt;-λ我会写成C-λ，以:开始的命令需要回车执行，&lt;n&gt;表示该处应输入一个数。 从 Normal 模式转至 Insert 模式 i：在光标前插入。a：在光标后插入。o/O：在当前行后/前插入一个新行并将光标跳到行头处。 删除字符 &lt;delete&gt;：真忘了怎么删就 delete 键。x：删除当前光标所在位置的一个字符。 复制粘贴 dd：删除当前行，并存入剪贴板里。p/P：在当前位置之后/前粘贴。yy：拷贝当前行。 怎么从外部剪贴板粘贴或复制到外部剪贴板呢？目前记住&quot;+p和&quot;+y就够了。 其实选中一部分内容后，y就是复制，d就是删除。 撤销恢复 u：Undo.&lt;C-r&gt;：Redo. 打开/保存/退出/改变文件 :e &lt;path/to/file&gt;：打开一个文件。:w：存盘。:saveas &lt;path/to/file&gt;：将当前文件另存为&lt;path/to/file&gt;。ZZ/:wq：保存并退出。:x：保存（仅在需要时）并退出。:q：退出，若选择不保存则需后附!强制执行（即命令为:q!），强制退出所有的文件可以使用:qa!。:bn/:bp：若打开了多个文件，使用其来切换到上/下一个文件。 移动光标 所谓 blank 字符，就是空格、tab、换行等。 hjkl：向左下上右移动光标。0：到行头。^：到本行第一个不是 blank 字符的位置。$：到本行行尾。g_：到本行最后一个不是 blank 字符的位置。:&lt;n&gt;：到第&lt;n&gt;行。 自动补全 &lt;C-n&gt;：体验不算太好，也许我没找到真正的使用方法（ 选择 v：选择一段。&lt;Shift-v&gt;：按行选择。 一些基本配置Vim 安装目录和用户主目录下有.vimrc，那是配置文件。 设置编码123set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936set termencoding=utf-8set encoding=utf-8 显示行号1set number nu是缩写。 突出显示当前行1set cursorline cul是缩写。 突出显示当前列1set cursorcolumn cuc是缩写。 启用鼠标123set mouse=aset selection=exclusiveset selectmode=mouse,key 不过其实没啥人愿意用鼠标，毕竟大部分人都是为了解放鼠标才来玩 Vim 的（ 缩进与 tab以下分别为设置将输入的 tab 转为空格、设置 tab 长度为 4 空格、设置自动缩进长度为 4 空格、继承前一行的缩进方式、 1234set expandtabset tabstop=4set shiftwidth=4set autoindent 对于我来说，暂时已经能够在 Vim 下存活了。 顺带一提 OI-wiki 的 Vim 介绍好像更不错（]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同一局域网下文件互传]]></title>
    <url>%2Fblog%2F%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8B%E6%96%87%E4%BB%B6%E4%BA%92%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[世界上最遥远的距离，不是生与死的距离，而是明明大家都在一个局域网下，却还要用 QQ 传文件。 我一直很不理解，明明都在同一个局域网下，传个文件怎么要么 QQ 要么 u 盘，多不优雅。但是又一直安于现状，懒得麻烦。终于有一天受不了了，开始研究如何优雅地传文件。 Windows传这个其实是最简单的。 打开高级共享设置(控制面板\网络和 Internet\网络和共享中心\高级共享设置)，启用网络发现，启用文件和打印机共享，启用公用文件夹共享，使用 128 位加密帮助保护文件共享连接。密码开不开随意。 然后右键把需要共享的文件夹设为共享。如果希望所有人都可以访问，可以添加一个 Everyone 账户。 Windows收打开网络就能看到局域网内其他 Windows 设备了，点开得了。 当然直接访问该设备局域网下的 IPv4 地址也行。（Windows+R，\\url） 要输账户就用自己账户密码。 Mac收打开 Finder，Command+K，smb://url。 Linux收mount 挂载由于需求不大，个人只用这个。 1sudo mount -t cifs -o username=&lt;username&gt;,password=&lt;password&gt; //&lt;url&gt;/&lt;folder&gt; &lt;folder&gt; 啊不过每次重新开机都要重新挂载。 samba装个 samba，然后随便搞（确信） ssh大家都会（确信） Android传我发现一个叫File Explorer的软件非常好用。 FTP服务器的选项会在当前局域网开启一个ftp服务器，然后就可以文件互传了。下面的加号里面也可以挂载各种其他协议。当然优秀的文件管理功能就不提了。 Mac和Linux传暂时没有需求，有时间再来研究。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020省选游]]></title>
    <url>%2Fblog%2F20200627%2F</url>
    <content type="text"><![CDATA[今年咋是联考啊。 没有停课的日子除了最后一周，都只占用下午下课后与晚上的时间。我寻思倒不如多整点停课，划走晚上算什么嘛。 稳定每天一套模拟赛，每天被吊打。 学会了多项式的卡常技巧。 终于停课了才发现 0202 年了你校还有一个机房是 32 位 win。 咋只剩一周了。 根据惯例（¿）最后一周不会天天有模拟赛。 信心场也打得和屎一样。没救了啊。 想复习点分、串串、网络流、数论、计算几何。算了先写个 LCT 吧。 各种模板题写挂，为啥码力退步巨大多，我人傻了。 随便学了学 k-D Tree，SAM。 考前补知识点简直是女娲补天。 奶一口都不会考算了。 最后一天你校留生工作傻逼，初三自招壬填报志愿把我们赶来赶去。 最后到了「数学研究室」，其实就是颓废室啦。大量无系统的机，几台设了密码的机。有个老哥密码提示「好啊！来啊！」，输入114514进去了。 于是试图在某无系统电脑装个 UBuntu 18.04，然而失败。 就这样白费了一早上。 下午机房的人都开始颓。我也想颓，然而还在复习（预习）知识点，算了。 晚上受不了了开始看神仙扫雷。 走之前打印了准考证，和几个板子。试图在宿舍看看，然而还是睡觉好。 商店里冰火人在问问题开场 1min 输奇怪的密码，10min 把题看了一遍。怎么这么 CSP2019 day 1。 icefire 看起来就是区间加减和维护一个非严格单峰函数的右峰。 $Q\le 2\times 10^6$，-lm。怎么省选还考卡常的，差评。 二分？好像我会 $O(Q\log^2 Q)$。然而只有 60 分。 三个.cpp开好了，测一些输入输出，发现文操错了： 12freopen(".in", "r", stdin);freopen(".out", "w", stdin); 怎么俩stdin，赶紧改。 于是开始看 problem。草怎么模数不是质数，昨天谁奶的来着。 $$\sum\limits_{i = 0}^{n} x^i \binom{n}{i} = (x + 1)^n$$ 开始推。 $$\begin{aligned}S_m &amp;=\sum\limits_{i = 0}^{n} i^{\underline{m}} k^i \binom{n}{i}\\ &amp;=\sum\limits_{i = m}^{n}\dfrac{n!}{(i - m)!(n - i)!}\cdot k^i\\ &amp;=n^{\underline{m}} k^m\sum\limits_{i = 0}^{n - m} \binom{n - m}{i} k^i\\ &amp;=n^{\underline{m}} k^m (k + 1)^{n - m}\end{aligned}$$ 想了想 $n^{\underline{m}}$ 按 $m$ 从小到大计算可以 $O(m^2)$ 求出所有要用的。好啊，只要把 $f$ 转下降幂多项式就可以 $O(m^2)$ 了。 如何转下降幂？ 设 $f(x) = \sum\limits_{i = 0}^{m} b_i x^{\underline{i}}$。 假如我知道了 $b_i$($i &lt; x$)，那可以求出 $x!b_x$，不妨设 $c_x = x!b_x$。发现 $x^{\underline{i}}b_i = \dfrac{x^{\underline{i}}}{i!}c_i$。 假如我可以 $O(m^2)$ 处理 $\dfrac{x^{\underline{i}}}{i!}$($x, i\le m$)和 $\dfrac{n^{\underline{i}}}{i!}$($i\le m$)岂不做完了？ 后面那个我会！直接搞 $m$ 个数，每次要除一个数的时候就遍历这 $m$ 个数除可以除的，直到把这个数除到 $1$，$O(m^2)$。 前面那个，乘的数和除的数都 $O(m)$ 有啥用？只能 $O(m^3)$？没这部分分啊！ 自闭了，我也不知道浪费了多久。 随手写下一个式子：$\dfrac{(x + 1)^{\underline{i}}}{i!} - \dfrac{x^{\underline{i}}}{i!} = \dfrac{x^{\underline{i - 1}}}{(i - 1)!}$ 哦 $\dfrac{x^{\underline{i}}}{i!} = \dbinom{x}{i}$ 啊，那没事了。 于是又写了 10min 走人，写完都十一点半了。 自闭的途中试图写 shop 的最低档暴力，未果。想了想 icefire，还是只会俩 $\log$，人没了。 没办法只能写。 瞎搞过了第一个样例，第二个死活过不去。十二点三十了，我觉得我在冒汗，头脑也已经将近停止转动了。 全机房好像只剩我的键盘在响。 看了看自己的写法，发现二分的时候没有取到温度最大的。 又补了一个二分。补的时候监考员已经表示只剩十分钟了。 距离考试结束只剩几分钟，过了第二个样例。 认真看了看感觉没错，最后三分钟啥都没干，考试结束了。 大概 60 + 100 + 0 罢。 出考场一想，icefire 那个东西好像完全可以直接树状数组上二分，省掉一个 $\log$。 也会了 shop 的 10 分暴力。 还是考场降智啊。 顺便用自己傻瓜的 problem 的心路历程逗笑了整个机房。 明明我昨晚刚看过斯特林数，结果 problem 推导完全没用上。 某神仙拿草稿纸在场上写游记结果草稿纸回收了，草。 吃中午饭大家疯狂奶明天考啥。毕竟今天没串串没计数没树。 下午在「数学研究室」划水划了一下午，发现テトリス(Tetris)底力下降巨大多。 晚上在 32 位机房又划水划了一晚上。 作业是在树上传递信号反正 CSP 成绩和昨天 icefire 笑话已经决定我进不了 E 的事实，今天决定随便考。 transfer 看起来是个 $O(m2^m)$ 之类的，然而我想了 20min 只会阶乘做法。 count 看起来暴力分好足。 第一个包 10min，第二个包 3min。 矩阵树定理是啥来着……行列式怎么算来着…… 于是成功在第三个包浪费巨久。 等等第四个包怎么搞啊，怎么求必须选某条边的树的个数啊！！！ 于是只拿了前三个包跑路了。 tree 一看就是个工业题，大概要维护一个数据结构支持： 插入一个数 一个结构内全加 1 求一个结构内的异或和 合并两个结构 这不是 ynoi trick 吗，反正就 Trie 合并完事。 于是敲了 80min 左右搞出来了。 数组卡紧开，反正值域到就完事了。(flag) 还有大量时间搞 transfer。 先把第一个包拿了。 剩下 40min，找个暴力拍拍拍。 $5\times 10^4$ 两份代码都跑得飞快，$5\times 10^5$ 两份代码都跑不出来。 怎么回事啊！ $1\times 10^5$ 也能跑。$2\times 10^5$ 也能跑。 自闭了，直到考试结束都不知道发生了啥。 一出来发现 transfer 可以把边的贡献拆在点上，然后随便 $O(m^2 2^m)$。 发现 tree 只开了 $2^{19}$，凉了。 发现 count 第四个包只要算全图生成树个数和去掉某条边之后生成树个数，一减就是包含某条边的生成树个数。 又降智了。预估 30 + 80 + 50。 两天串串没考，计数没考，奇怪的数据结构没考，计算几何没考。我怀疑我来的是 CSP 2019 Round 2。 一上你谷看到 lxl 发的听说省选考了Ynoi题一样的trick，想到考场上自己好像第一反应也是这个。 滚回文化课考完两天出分了。 类型 icefire problem shop transfer tree count 实际得分 60 100 0 30 35 50 考场上会，但是写挂了 0 0 0 0 65 0 出了考场不久会了 40 0 10 30~40 0 20 再肝多久也搞不出来 0 0 90 10 0 0~30 考场上降智（即表中第三行）是主要丢分点。 至于写挂的 65 分…… tree 暴毙是因为它看起来开了 $2^{19}$ 实际上只开了 $2^{18}$。（实际上是被某人奶死的（确信）） 算是买了个「值域要仔细看」的教训吧。 并且考场造数据的时候，值域可以尽量开到上限（比如在 $[\dfrac{1}{2}W_{max}, W_{max}]$ 之间随机而不要在 $[1, W_{max}]$ 随，或者直接测几个全开 $W_{max}$ 的数据）。如果这么干了，考场上是不是也能救回来那 65 呢。 发现考场我不愿意去洗手间，其实 4.5h 的比赛去一去转换一下思路也许确实能一定程度上避免降智吧。 感觉睡好确实挺重要的，精神状态比 CSP 好太多了。 距离中考只剩一个月。 暂别。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k-D Tree学习笔记]]></title>
    <url>%2Fblog%2Fk-D-Tree%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[某人奶了一口省选会考，于是认真学了学。 形态k-D Tree 是一棵二叉搜索树，每个结点都对应 $k$ 维空间中的一个点，每个子树中的点都在且都仅在一个 $k$ 维超长方体内。 构建假设已知 $k$ 维空间中的 $n$ 个互不相同的点的坐标，要将其构建为一棵 k-D Tree。 当前超长方体中只有一个点时直接返回该点。 选择一个维度与该维度上的一个切割点，将当前超长方体按这个维度及这个切割点分为两个超长方体。 将选择的切割点作为该子树的根，递归处理分出的两个超长方体。 容易发现，对于步骤 2，每次切割点选为该维度上的中位数，树高可以在 $O(\log n)$。 如何寻找中位数？可以使用类似快速排序的方法，并且每次只递归包含中位数的一侧，对于 $n$ 个元素的序列期望时间复杂度即为 $O(n)$。（可用algorithm库中的nth_element()实现） 每次选什么维度来割？理论上应当每次选方差最大的维度割常数应当最小，然而算法竞赛中较常用且方便的写法是直接轮流按每一维割。 插入与删除点集可变，可以利用替罪羊树不平衡重构的方法把树高稳定在 $O(\log n)$。 然而实验证明定期整树重构通常来说常数更小。 查询超长方体若该结点完全被包含于超长方体内，或完全与其无交可直接返回。 否则应递归两边。 可以证明复杂度最坏为 $O(n^{1-\frac{1}{k}})$。 习题[Luogu 4148]简单题 初值全为 0 的 $n\times n$ 二维矩阵上， $q$ 个操作： 单点修改。 矩形查询和。 强制在线，内存限制20M，答案及过程量均int范围内。$n\le 5\times 10^5, q\le 2\times 10^5$。空间卡树套树，强制在线卡 CDQ 分治，于是只能 KDT。 不要不平衡重构，定期重构常数更小。 写写写，写就完事了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define FORit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b) + 1; i != ed_##i; ++i)#define ROFit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b)-1; i != ed_##i; --i)#define GO(x, p, e, i, v) for (register int i = p[x].head, v; i; i = e[i].link)#define MEM(x, v) memset(x, v, sizeof(x))#define fir first#define sec second#define pq priority_queue#define PB push_back#define MP make_pairtypedef long long LL;typedef double DB;typedef pair&lt;int, int&gt; PII;#define Templ(T) template &lt;typename T&gt;inline int read() &#123; reg int ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) f ^= (c == '-'), c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define using_modconst int mod = 998244353;#ifdef using_modinline void inc(int &amp;x, const int &amp;y) &#123; x += y; if (x &gt;= mod) x -= mod; &#125;inline void dec(int &amp;x, const int &amp;y) &#123; x -= y; if (x &lt; 0) x += mod; &#125;inline int ksm(int x, LL y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = 1ll * x * x % mod) if (y &amp; 1) res = 1ll * res * x % mod; return res;&#125;inline int qmo(const int &amp;x) &#123; return x + ((x &gt;&gt; 31) ? mod : 0); &#125;#endifTempl(_Tp) inline _Tp gcd(_Tp x, _Tp y) &#123; return y ? gcd(y, x % y) : x; &#125;#define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout)#define PBTXDY&#125; // namespace my_stdusing namespace my_std;const int N = 200010;struct Node&#123; int e[2][2], b[2], c[2], val, sum, siz;&#125;;namespace KDT&#123;Node a[N];static const DB alpha = 0.75;int ldr[N], ccnt, root;static int d_d;inline bool c_d(const Node &amp;l, const Node &amp;r)&#123; return l.b[d_d] != r.b[d_d] ? l.b[d_d] &lt; r.b[d_d] : l.b[d_d ^ 1] &lt; r.b[d_d ^ 1];&#125;#define lc a[t].c[0]#define rc a[t].c[1]inline void Print(const int &amp;t)&#123; printf("Node[%d]: --- &lt;%d, %d&gt;\n", t, lc, rc); printf("[%d, %d, %d], [%d, %d, %d], %d, %d, %d\n", a[t].e[0][0], a[t].b[0], a[t].e[0][1], a[t].e[1][0], a[t].b[1], a[t].e[1][1], a[t].val, a[t].sum, a[t].siz);&#125;inline void PushUp(const int &amp;t)&#123; a[t].siz = a[lc].siz + a[rc].siz + 1; a[t].sum = a[lc].sum + a[rc].sum + a[t].val; if(lc)&#123; chkmin(a[t].e[0][0], a[lc].e[0][0]); chkmax(a[t].e[0][1], a[lc].e[0][1]); chkmin(a[t].e[1][0], a[lc].e[1][0]); chkmax(a[t].e[1][1], a[lc].e[1][1]); &#125; if(rc)&#123; chkmin(a[t].e[0][0], a[rc].e[0][0]); chkmax(a[t].e[0][1], a[rc].e[0][1]); chkmin(a[t].e[1][0], a[rc].e[1][0]); chkmax(a[t].e[1][1], a[rc].e[1][1]); &#125;&#125;inline bool CanRbu(const int &amp;t)&#123; return alpha * a[t].siz &lt;= (DB)max(a[lc].siz, a[rc].siz);&#125;inline void Build(const int &amp;l, const int &amp;r, const int &amp;d)&#123; if(l &gt; r) return; const int t = (l + r) &gt;&gt; 1; d_d = d, nth_element(a + l, a + t, a + r + 1, c_d); a[t].e[0][0] = a[t].e[0][1] = a[t].b[0]; a[t].e[1][0] = a[t].e[1][1] = a[t].b[1]; a[t].siz = 1, a[t].sum = a[t].val; Build(l, t - 1, d ^ 1), Build(t + 1, r, d ^ 1); lc = l &gt; t - 1 ? 0 : (l + t - 1) &gt;&gt; 1; rc = t + 1 &gt; r ? 0 : (t + r + 1) &gt;&gt; 1; return PushUp(t);&#125;//inline void Flatten(int &amp;ldc, const int &amp;t)&#123;// if(!t) return;// Flatten(ldc, lc);// ldr[ldc++] = t;// Flatten(ldc, rc);//&#125;//inline int Build(const int &amp;l, const int &amp;r, const int &amp;d)&#123;// if(l &gt;= r) return 0;// const int mid = (l + r) &gt;&gt; 1;// d_d = d, nth_element(ldr + l, ldr + mid, ldr + r, c_d);// const int t = ldr[mid];// lc = Build(l, mid, d ^ 1), rc = Build(mid + 1, r, d ^ 1);// return PushUp(t), t;//&#125;//inline void Rebuild(int &amp;t, const int &amp;d)&#123;//// printf("Rebuild: %d\n", t);// int ldc = 0;// Flatten(ldc, t);// t = Build(0, ldc, d);//&#125;inline void Insert(int &amp;t, const Node &amp;v, const int &amp;d)&#123; if(!t)&#123; t = ++ccnt; a[t] = v; a[t].e[0][0] = a[t].e[0][1] = a[t].b[0]; a[t].e[1][0] = a[t].e[1][1] = a[t].b[1]; return; &#125; if(v.b[0] == a[t].b[0] &amp;&amp; v.b[1] == a[t].b[1])&#123; a[t].val += v.val; a[t].sum += v.sum; return; &#125; if(v.b[d] &lt;= a[t].b[d]) Insert(lc, v, d ^ 1); else Insert(rc, v, d ^ 1); PushUp(t);// if(CanRbu(t)) Rebuild(t, d);&#125;inline int Query(const int &amp;t, const Node &amp;v)&#123; if(!t) return 0;// Print(t); if(v.e[0][0] &lt;= a[t].e[0][0] &amp;&amp; a[t].e[0][1] &lt;= v.e[0][1] &amp;&amp; v.e[1][0] &lt;= a[t].e[1][0] &amp;&amp; a[t].e[1][1] &lt;= v.e[1][1])&#123; return a[t].sum; &#125; if(v.e[0][0] &gt; a[t].e[0][1] || a[t].e[0][0] &gt; v.e[0][1] || v.e[1][0] &gt; a[t].e[1][1] || a[t].e[1][0] &gt; v.e[1][1])&#123; return 0; &#125; int res = 0; if(v.e[0][0] &lt;= a[t].b[0] &amp;&amp; a[t].b[0] &lt;= v.e[0][1] &amp;&amp; v.e[1][0] &lt;= a[t].b[1] &amp;&amp; a[t].b[1] &lt;= v.e[1][1])&#123; res = a[t].val; &#125; return res + Query(lc, v) + Query(rc, v);&#125;#undef lc#undef rc&#125;int n;int main() &#123; n = read(); Rint opt, lst = 0, tot = 0; reg const int blo = 6666; reg Node v; v.siz = 1, v.c[0] = v.c[1] = 0; while(1)&#123; opt = read(); if(opt == 3) break; if(opt == 1)&#123; ++ tot; v.b[0] = read() ^ lst, v.b[1] = read() ^ lst; v.val = v.sum = read() ^ lst; KDT::Insert(KDT::root, v, 0); if(tot == blo)&#123; tot = 0; KDT::Build(1, KDT::ccnt, 0); KDT::root = (1 + KDT::ccnt) &gt;&gt; 1; &#125; &#125; else&#123; v.e[0][0] = read() ^ lst, v.e[1][0] = read() ^ lst, v.e[0][1] = read() ^ lst, v.e[1][1] = read() ^ lst;// printf("Qn: [%d, %d], [%d, %d]\n",// v.e[0][0], v.e[0][1], v.e[1][0], v.e[1][1]); printf("%d\n", lst = KDT::Query(KDT::root, v)); &#125; &#125; return 0;&#125; 参考资料OI Wiki]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KDT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「十二省联考2019」字符串问题]]></title>
    <url>%2Fblog%2F%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[重工业，，， 题意简述给定一个字符串 $S$，再给定 $n_A$ 个 A 类串和 $n_B$ 个 B 类串（均为 $S$ 的字串）。定义 A 类串的权值为该串长，B 类串的权值为 0。 将这些字串抽象为点，给定 $m$ 条 A 类连向 B 类的边。定义一个 B 类串向某个 A 类串连边当且仅当其为该 A 类串的一个前缀。 求一条最长的路径（路径长度定义为路径上经过所有点的权值和），需判断无解。$|S|, n_A, n_B, m\le 2\times 10^5$。 [LOJ 3049] [Luogu 5284] 主要思路由于不会 SAM，此处只讲 SA 做法。 假设 $x$ 为 $y$ 的前缀，那么 $x$ 的字典序必定小于 $y$，且 $\operatorname{lcp}(x, y) = |x|$。 于是只需要把 A 串和 B 串一起按字典序排好序，然后对每个 B 串二分一下它为前缀的区间，线段树优化建图，拓扑排序，就喜提 $O(n\log n)$。 怎么按字典序排序？对于俩串，lcp 为较短的，则短的排在长的前面；lcp 比最短的还短，直接按SA::rk[]排即可。 参考代码注意细节，比如 B 串应该在有相同 A 串时居于前面。 不知道为啥常数巨大，可能我写丑了？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define FORit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b) + 1; i != ed_##i; ++i)#define ROFit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b)-1; i != ed_##i; --i)#define GO(x, p, e, i, v) for (register int i = p[x].head, v; i; i = e[i].link)#define fir first#define sec second#define pq priority_queue#define MP make_pairtypedef long long LL;typedef double DB;typedef pair&lt;int, int&gt; PII;#define Templ(T) template &lt;typename T&gt;inline int read() &#123; reg int ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) f ^= (c == '-'), c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define using_modconst int mod = 998244353;#ifdef using_modinline void inc(int &amp;x, const int &amp;y) &#123; x += y; if (x &gt;= mod) x -= mod; &#125;inline void dec(int &amp;x, const int &amp;y) &#123; x -= y; if (x &lt; 0) x += mod; &#125;inline int ksm(int x, LL y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = 1ll * x * x % mod) if (y &amp; 1) res = 1ll * res * x % mod; return res;&#125;#endifTempl(_Tp) inline _Tp gcd(_Tp x, _Tp y) &#123; return y ? gcd(y, x % y) : x; &#125;#define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout)#define PBTXDY&#125; // namespace my_stdusing namespace my_std;const int N = 200010;int l2g[N];inline void init()&#123; FOR(i, 2, 200000) l2g[i] = l2g[i &gt;&gt; 1] + 1;&#125;int n, nA, nB, m;#define CLR(x) memset(x, 0, sizeof(x))char str[N];namespace SA&#123;int sa[N], rk[N], oldrk[N &lt;&lt; 1], cnt[N], px[N], id[N], ht[N];int st[20][N];inline int cmp(const int &amp;x, const int &amp;y, const int &amp;w)&#123; return oldrk[x] == oldrk[y] &amp;&amp; oldrk[x + w] == oldrk[y + w];&#125;inline void build()&#123; CLR(sa), CLR(rk), CLR(oldrk), CLR(cnt), CLR(px), CLR(id); CLR(ht), CLR(st); Rint m = 127, p, w; FOR(i, 1, n) ++cnt[rk[i] = str[i]]; FOR(i, 1, m) cnt[i] += cnt[i - 1]; ROF(i, n, 1) sa[cnt[rk[i]]--] = i; for(w = 1; p &lt; n; w &lt;&lt;= 1, m = p)&#123; p = 0; ROF(i, n, n - w + 1) id[++p] = i; FOR(i, 1, n) if(sa[i] &gt; w) id[++p] = sa[i] - w; memset(cnt, 0, sizeof(cnt)); FOR(i, 1, n) ++cnt[px[i] = rk[id[i]]]; FOR(i, 1, m) cnt[i] += cnt[i - 1]; ROF(i, n, 1) sa[cnt[px[i]]--] = id[i]; p = 0; memcpy(oldrk, rk, sizeof(rk)); FOR(i, 1, n)&#123; rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p; &#125; &#125; //build sa[], rk[] p = 0; FOR(i, 1, n)&#123; if(p) --p; while(str[i + p] == str[sa[rk[i] - 1] + p]) ++p; ht[rk[i]] = p; &#125; //build ht[] //ht[i] = lcp(sa[i], sa[i - 1]) FOR(i, 1, n) st[0][i] = ht[i]; FOR(i, 1, l2g[n])&#123; FOR(j, 1, n - (1 &lt;&lt; i) + 1)&#123; st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 &lt;&lt; (i - 1))]); &#125; &#125;// FOR(i, 1, n)&#123;// FOR(j, sa[i], n) putchar(str[j]);// putchar('\n');// &#125;&#125;inline int st_q(Rint x, Rint y)&#123; Rint k = l2g[y - x + 1]; y -= (1 &lt;&lt; k) - 1; return min(st[k][x], st[k][y]);&#125;inline int lcp(Rint x, Rint y)&#123; if(x == y) return n - x + 1; x = rk[x], y = rk[y]; if(x &gt; y) swap(x, y); return st_q(x + 1, y);&#125;&#125;struct Sub_str&#123; int p, len, id, rk; inline bool operator &lt;(const Sub_str &amp;x)const&#123; if(SA::lcp(p, x.p) &gt;= min(len, x.len)) return len == x.len ? rk &lt; x.rk : len &lt; x.len; else return SA::rk[p] &lt; SA::rk[x.p]; &#125;&#125;dt[N &lt;&lt; 1];int a_rk[N], b_l[N], b_r[N], a_p[N], b_id[N], a_len[N];inline void build_sub()&#123; nA = read(); FOR(i, 1, nA)&#123; dt[i].p = read(); a_len[i] = dt[i].len = read() - dt[i].p + 1; dt[i].id = i, dt[i].rk = 1; &#125; nB = read(); FOR(i, nA + 1, nA + nB)&#123; dt[i].p = read(), dt[i].len = read() - dt[i].p + 1; dt[i].id = i, dt[i].rk = 0; &#125; // printf("nA, nB: %d, %d\n", nA, nB); sort(dt + 1, dt + nA + nB + 1); // FOR(i, 1, nA + nB)&#123; // printf("%d: %c -- ", dt[i].id, dt[i].id &lt;= nA ? 'A' : 'B'); // FOR(j, dt[i].p, dt[i].p + dt[i].len - 1) putchar(str[j]); // putchar('\n'); // if(dt[i].id &gt; nA)&#123; // FOR(j, 1, nA + nB)&#123; // if(i != j &amp;&amp; SA::lcp(dt[j].p, dt[i].p) &gt;= dt[i].len) printf("%d ", dt[j].id); // &#125; // puts(""); // &#125; // &#125; Rint cA = nA; // dt[nA + nB + 1].rk = dt[nA + nB + 2].rk = cA; ROF(i, nA + nB, 1)&#123; if(dt[i].id &lt;= nA)&#123; dt[i].rk = a_rk[dt[i].id] = cA--; &#125; else&#123; dt[i].rk = cA; // b_l[dt[i].id - nA] = cA + 1; // Rint j = i + 1; // while(SA::lcp(dt[j].p, dt[i].p) &gt;= dt[i].len) ++j; // b_r[dt[i].id - nA] = dt[j - 1].rk; // printf("b[%d]: %d -- [%d, %d]\n", dt[i].id, dt[j - 1].id, b_l[dt[i].id - nA], b_r[dt[i].id - nA]); b_l[dt[i].id - nA] = cA + 1; Rint l = i + 1, r = nA + nB + 1, mid = (l + r) &gt;&gt; 1; while(l &lt; r)&#123; if(SA::lcp(dt[mid].p, dt[i].p) &gt;= dt[i].len)&#123; l = mid + 1; &#125; else r = mid; mid = (l + r) &gt;&gt; 1; &#125; --mid; // if(SA::lcp(dt[mid + 1].p, dt[i].p) &gt;= dt[i].len) ++mid; // if(SA::lcp(dt[mid].p, dt[i].p) &lt; dt[i].len) --mid; b_r[dt[i].id - nA] = dt[mid].rk; // printf("b[%d]: %d -- [%d, %d]\n", dt[i].id, dt[mid].id, b_l[dt[i].id - nA], b_r[dt[i].id - nA]); &#125;// printf("cA: %d\n", cA); &#125; FOR(i, 1, nA) a_p[a_rk[i]] = i; FOR(i, 1, nB) b_id[i] = i + (nA &lt;&lt; 2);// FOR(i, 1, nA) printf("a_rk[%d] = %d\n", i, a_rk[i]);// FOR(i, 1, nB) printf("b(%d): [%d, %d]\n", i, b_l[i], b_r[i]);&#125;struct Vertice&#123; int head, ind; LL val;&#125;;struct Edge&#123; int to, link;&#125;;namespace GR&#123;Vertice p[N &lt;&lt; 3];Edge e[N &lt;&lt; 4];int ecnt, tcnt;int Que[N &lt;&lt; 3];inline void A_E(const int &amp;u, const int &amp;v)&#123; e[++ecnt] = (Edge)&#123;v, p[u].head&#125;; p[u].head = ecnt, ++p[v].ind;&#125;inline void build(const int &amp;t, const int &amp;l, const int &amp;r)&#123; if(l == r)&#123; a_rk[a_p[l]] = t; p[t].val = a_len[a_p[l]]; return; &#125; reg const int mid = (l + r) &gt;&gt; 1; build(t &lt;&lt; 1, l, mid), build(t &lt;&lt; 1 | 1, mid + 1, r); A_E(t, t &lt;&lt; 1), A_E(t, t &lt;&lt; 1 | 1);&#125;inline void update(const int &amp;t, const int &amp;l, const int &amp;r, const int &amp;L, const int &amp;R, const int &amp;x)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) return A_E(x, t); reg const int mid = (l + r) &gt;&gt; 1; if(L &lt;= mid) update(t &lt;&lt; 1, l, mid, L, R, x); if(R &gt; mid) update(t &lt;&lt; 1 | 1, mid + 1, r, L, R, x);&#125;inline void build()&#123; ecnt = 0; memset(p, 0, sizeof(p)); memset(e, 0, sizeof(e)); build(1, 1, nA);// FOR(i, (nA &lt;&lt; 2) + 1, (nA &lt;&lt; 2) + nB) p[i].val = 1; m = read(); Rint a_, b_; FOR(i, 1, m)&#123; a_ = read(), b_ = read(); A_E(a_rk[a_], b_id[b_]); &#125; FOR(i, 1, nB)&#123; if(b_l[i] &lt;= b_r[i])&#123; update(1, 1, nA, b_l[i], b_r[i], (nA &lt;&lt; 2) + i); &#125; &#125; tcnt = (nA &lt;&lt; 2) + nB;// FOR(u, 1, tcnt)&#123;// printf("p[%d]: %d, %d\ne[%d]: ", u, p[u].val, p[u].ind, u);// GO(u, p, e, i, v) printf("%d ", e[i].to);// puts("");// &#125;&#125;inline int Topo_sort()&#123; Rint l = 0, r = 0; FOR(i, 1, tcnt) if(!p[i].ind) Que[r++] = i; while(l &lt; r)&#123; reg const int u = Que[l++]; GO(u, p, e, i, v)&#123; v = e[i].to; --p[v].ind; if(!p[v].ind) Que[r++] = v; &#125; &#125; return r == tcnt;&#125;inline LL dp()&#123; reg LL res = 0; ROF(i, tcnt - 1, 0)&#123; reg const int u = Que[i]; reg LL mx = 0; GO(u, p, e, i, v)&#123; v = e[i].to; chkmax(mx, p[v].val); &#125; p[u].val += mx; chkmax(res, p[u].val); &#125; return res;&#125;&#125;inline void work()&#123; scanf("%s", str + 1); n = strlen(str + 1); // printf("n: %d\n", n); SA::build(); build_sub(); GR::build(); if(!GR::Topo_sort()) return puts("-1"), void(); printf("%lld\n", GR::dp());&#125;int main() &#123; init(); int esac = read(); while(esac--) work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>线段树</tag>
        <tag>后缀数组</tag>
        <tag>省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF843D」Dynamic Shortest Path]]></title>
    <url>%2Fblog%2FCF843D%2F</url>
    <content type="text"><![CDATA[题意简述[CF 843D] 给定 $n$ 个点 $m$ 条边的有向图，边带权。$q$ 个操作，可能是求目前 $1$ 到 $u$ 的最短路或是将 $c$ 条边的权加 $1$。 $n, m\le 10^5, q\le 2000, \sum c\le 10^6$。 主要思路$q$ 这么小，看起来像是 $O(nq)$。 先跑一遍 Dijkstra 来取得 $\langle dis_i\rangle$，表示 $1$ 到 $i$ 的最短路长度。 每次修改边权， $1$ 到任意其他点的距离比原先都不降。 那么求增量 $\langle f_i\rangle$。设 $e(u, v)$ 表示 $u, v$ 之间连边，$w(u, v)$ 表示 $u, v$ 之间边的边权。 显然对于点 $v$ 有 $f_v = \min\limits_{e(u, v)}(dis_u + f_u + w(u, v) - dis_v)$。 增量有上限 $c$，所以可以直接用桶 $O(n + m)$ bfs 做。 总时间复杂度 $O(n\log n + m + (n + m)q)$。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define FORit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b) + 1; i != ed_##i; ++i)#define ROFit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b)-1; i != ed_##i; --i)#define GO(x, p, e, i, v) for (register int i = p[x].head, v; i; i = e[i].link)#define MEM(x, v) memset(x, v, sizeof(x))#define fir first#define sec second#define MP make_pairtypedef long long LL;typedef double DB;typedef pair&lt;int, int&gt; PII;typedef pair&lt;LL, int&gt; PLLI;#define Templ(T) template &lt;typename T&gt;inline int read() &#123; reg int ans = 0; reg char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define using_modconst int mod = 998244353;#ifdef using_modinline void inc(int &amp;x, const int &amp;y) &#123; x += y; if (x &gt;= mod) x -= mod; &#125;inline void dec(int &amp;x, const int &amp;y) &#123; x -= y; if (x &lt; 0) x += mod; &#125;inline int ksm(int x, LL y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = 1ll * x * x % mod) if (y &amp; 1) res = 1ll * res * x % mod; return res;&#125;#endifTempl(_Tp) inline _Tp gcd(_Tp x, _Tp y) &#123; return y ? gcd(y, x % y) : x; &#125;#define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout)#define PBTXDY&#125; // namespace my_stdusing namespace my_std;const int N = 100010;#define inf (0x3f3f3f3f3f3f3f3fll)struct Vertice&#123; int head;&#125;p[N];struct Edge&#123; int link, to, wgh;&#125;e[N];LL dis[N], f[N];int vis[N];static int ecnt;inline void A_E(const int &amp;u, const int &amp;v, const int &amp;w)&#123; e[++ecnt] = (Edge)&#123;p[u].head, v, w&#125;; p[u].head = ecnt;&#125;int n, m, q;priority_queue&lt;PLLI&gt; pq;inline void dijkstra()&#123; memset(dis + 1, 0x3f, sizeof(LL) * n); memset(vis + 1, 0, sizeof(int) * n); dis[1] = 0; pq.push(MP(0, 1)); Rint u; while(!pq.empty())&#123; u = pq.top().sec, pq.pop(); if(vis[u]) continue; vis[u] = 1; GO(u, p, e, i, v)&#123; v = e[i].to; if(chkmin(dis[v], dis[u] + e[i].wgh))&#123; pq.push(MP(-dis[v], v)); &#125; &#125; &#125;&#125;queue&lt;int&gt; bar[N];inline void bfs(const int &amp;cnt)&#123; memset(f + 1, 0x3f, sizeof(LL) * n); f[1] = 0, bar[0].push(1); reg LL lim = 0, val = 0; while(val &lt;= lim)&#123; Rint u; while(!bar[val].empty())&#123; u = bar[val].front(), bar[val].pop(); if(f[u] &lt; val) continue; GO(u, p, e, i, v)&#123; v = e[i].to; if(chkmin(f[v], f[u] + dis[u] - dis[v] + e[i].wgh))&#123; if(f[v] &lt;= cnt)&#123; bar[f[v]].push(v); chkmax(lim, f[v]); &#125; &#125; &#125; &#125; ++val; &#125; FOR(i, 2, n) dis[i] = min(dis[i] + f[i], inf);&#125;int main()&#123; n = read(), m = read(), q = read(); Rint u, v, w; FOR(i, 1, m)&#123; u = read(), v = read(), w = read(); A_E(u, v, w); &#125; dijkstra(); while(q--)&#123; u = read(); if(u == 1)&#123; v = read(); printf("%lld\n", dis[v] &gt;= inf ? -1 : dis[v]); &#125; else&#123; v = read(); FOR(i, 1, v) ++e[read()].wgh; bfs(min(v, n - 1)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1364E」X-OR]]></title>
    <url>%2Fblog%2FCF1364E%2F</url>
    <content type="text"><![CDATA[手造 rand 太烂，换成mt19937过了。 题意简述[CF 1364E] 你需要猜一个 $0$ 到 $n - 1$ 的排列 $\langle a_n\rangle$，每次可以询问二元组 $(x, y)$($x\neq y$) ，表示询问 $a_x | a_y$ 的值，其中 $|$ 为按位或。 $3\le n\le 2048$，询问次数不能超过 $4269$ 次。 主要思路本题有许多做法，下面放送本人认为最妙的一种方法。 假设现在有两个可能是 0 的位置 $x$ 与 $y$，设 $A(x, y) = a_x | a_y$。 考虑现在新加入一个可能是 0 的位置 $z$，如何排除一个呢？ 如果 $A(z, y) &lt; A(x, y)$，则 $x &gt; 0$，否则 $A(x, y) = y \le A(z, y)$ 矛盾。 如果 $A(z, y) &gt; A(x, y)$，则同理 $z &gt; 0$。 如果 $A(z, y) = A(x, y)$，则 $y &gt; 0$，否则 $A(z, y) = z = x = A(x, y)$ 非排列。 每个数都会被查询 1 次，并且如果出现上述最后一种情况，还应额外查询 $(x, z)$。 然后就得到了两个可能是 0 的位置。如何确定哪个是 0？随机一个 $d$，询问 $(x, d)$ 与 $(y, d)$ 直到二者答案不同，小的那个即为 0。 最后再让每个数都与 0 询问一次来获得整个排列。 明明有比 $2n$ 多的查询次数，为什么总次数是正确的？容易证明当我们按随机顺序判断每个数是否可能为 0 时，出现最后一种状况的概率极小。同样地，判断最后两个数哪个是 0 时，期望询问次数也不大。有兴趣的读者可以自己尝试证明。 由此可见，利用随机算法获取优秀的复杂度是解题的常用技巧之一。在数据结构中，典型的示例是随机堆。 参考代码注意找到两个可能是 0 的位置也要随机顺序，否则可能导致最后一种情况过多导致询问次数超限。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;#define reg registertypedef pair&lt;int, int&gt; PII;#define MP(x, y) make_pair(x, y)inline int read() &#123; reg int ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) f ^= (c == '-'), c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;inline int chkmin(int &amp;x, const int &amp;y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;inline int chkmax(int &amp;x, const int &amp;y) &#123; return x &lt; y ? x = y, 1 : 0; &#125; #define F_O fflush(stdout)mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());const int N = 2050;int n, dd[N], p[N];//睦月、如月、弥生、卯月、皐月、水無月、文月、葉月、長月、神無月、霜月、師走map&lt;PII, int&gt; Q; inline int query(const int &amp;x, const int &amp;y)&#123; if(Q.count(MP(x, y))) return Q[MP(x, y)]; printf("? %d %d\n", x, y), F_O; return Q[MP(x, y)] = Q[MP(y, x)] = read();&#125;inline int rnd(const int &amp;lim)&#123; return mt() % lim;&#125; int main() &#123; n = read(); reg int mutsuki, kisaragi, yayoi; reg int uzuki, satsuki, minazuki; reg int fumizuki, hazuki, nagatsuki; reg int kannazuki, shimotsuki, shiwasu; for(kannazuki = 1; kannazuki &lt;= n; ++kannazuki)&#123; p[kannazuki] = kannazuki; &#125; for(shimotsuki = 1; shimotsuki &lt;= n; ++shimotsuki)&#123; swap(p[shimotsuki], p[rnd(n) + 1]); &#125; mutsuki = p[1], kisaragi = p[2], uzuki = query(p[1], p[2]); for(nagatsuki = 3; nagatsuki &lt;= n; ++nagatsuki)&#123; yayoi = p[nagatsuki]; satsuki = query(kisaragi, yayoi); if(chkmin(uzuki, satsuki))&#123; mutsuki = yayoi; &#125; else if(uzuki == satsuki)&#123; uzuki = query(mutsuki, kisaragi = yayoi); &#125; &#125; for(shiwasu = 1; shiwasu &lt;= n; ++shiwasu)&#123; swap(p[shiwasu], p[rnd(n) + 1]); &#125; fumizuki = hazuki = nagatsuki = 0; do&#123; minazuki = p[++nagatsuki]; if(minazuki == mutsuki || minazuki == kisaragi) continue; fumizuki = query(mutsuki, minazuki); hazuki = query(kisaragi, minazuki); &#125;while(fumizuki == hazuki); if(fumizuki &gt; hazuki) mutsuki = kisaragi; for(nagatsuki = 1; nagatsuki &lt;= n; ++nagatsuki)&#123; if(nagatsuki == mutsuki) continue; dd[nagatsuki] = query(nagatsuki, mutsuki); &#125; printf("! "); for(nagatsuki = 1; nagatsuki &lt;= n; ++nagatsuki)&#123; printf("%d ", dd[nagatsuki]); &#125; puts(""), F_O; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>交互题</tag>
        <tag>随机算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式板子]]></title>
    <url>%2Fblog%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[某一天发现自己的多项式板子好像全机房最慢唉。 于是找了些博客来学习卡常。 然后喜提目前全机房最快。 如何卡常取模优化众所周知 C++ 取模慢得出奇，想优化常数，自然而然想到在取模上下工夫。 曾经为了避免加减取模写了这样的东西： 123const int mod = 998244353;inline void inc(int &amp;x, const int &amp;y)&#123;if((x += y) &gt;= mod) x -= mod;&#125;inline void dec(int &amp;x, const int &amp;y)&#123;if((x -= y) &lt; 0) x += mod;&#125; 后来发现加一加减一减比一比也挺慢，于是就有了这样的东西： 12const int mod = 998244353;inline int qmo(const int &amp;x)&#123;return x + ((x &gt;&gt; 31) &amp; mod);&#125; 大概就是用了下对int型右移 31 位会使其全部变成符号位的性质。 预处理原根每次还要根据长度重新处理蝴蝶变换的数组？这里要做大量的乘法和取模，不如直接一次处理出来优化常数。 预处理要 $O(n\log n)$？长度总是 2 的次幂，完全可以只用 $O(n)$。 清空与移动数组memset与memcpy无论是否在-O2下都有优秀的表现。 DFT时使用64位无符号整数稍微算算，发现在模数是int范围内是不会爆unsigned long long的。 无符号整数在做加减乘的时候会稍微快一些。 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)typedef unsigned int u32;typedef long long i64;typedef unsigned long long u64;#define Templ(T) template &lt;typename T&gt;#ifdef LOCAL#define gcr() getchar()#define pcr(x) putchar(x)#define F_In void()#define F_Out void()#elsestatic char InB[1 &lt;&lt; 24], *In_s = InB;static char OutB[1 &lt;&lt; 24], *Out_s = OutB;#define gcr() (*In_s ++)#define pcr(x) (*Out_s ++ = x)#define F_In (fread(InB, 1, 1 &lt;&lt; 24, stdin))#define F_Out (fwrite(OutB, 1, Out_s - OutB, stdout), Out_s = OutB)#endifinline int read() &#123; // reg int ans = 0, f = 1; reg int ans = 0; reg char c = gcr(); // while (!isdigit(c)) f ^= (c == '-'), c = gcr(); while (!isdigit(c)) c = gcr(); for (; isdigit(c); c = gcr()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); // return f ? ans : -ans; return ans;&#125;Templ(T) inline void write(T x)&#123; static char sta[20]; reg char *t = sta; // if(x &lt; 0) return pcr('-'), write(-x); do&#123; *++t = (x % 10) ^ 48, x /= 10; &#125;while(x); while(t != sta) pcr(*t--);&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define using_modconst int mod = 998244353;#ifdef using_modinline void inc(int &amp;x, const int &amp;y) &#123; if ((x += y) &gt;= mod) x -= mod; &#125;inline void dec(int &amp;x, const int &amp;y) &#123; if ((x -= y) &lt; 0) x += mod; &#125;inline int ksm(int x, int y) &#123; reg int res = 1; for (; y; y &gt;&gt;= 1, x = 1ll * x * x % mod) if (y &amp; 1) res = 1ll * res * x % mod; return res;&#125;inline int qmo(const int &amp;x)&#123; return x + ((x &gt;&gt; 31) &amp; mod); &#125;#endif&#125; // namespace my_stdusing namespace my_std;#define swap(x, y) (x ^= y ^= x ^= y)// const int N = 270010;const int N = 2100010;int LMT = 1;int rev[N], omg[N], inv[N];int l2g[N];inline void init(const int &amp;n)&#123; inv[1] = 1; FOR(i, 2, n) inv[i] = (i64)(mod - mod / i) * inv[mod % i] % mod; l2g[1] = 0; FOR(i, 2, n &lt;&lt; 1)&#123; l2g[i] = l2g[i &gt;&gt; 1] + 1; &#125;&#125;inline int get_len(const int &amp;n)&#123; return 1 &lt;&lt; (l2g[n] + 1);&#125;inline void poly_init(const int &amp;n)&#123; Rint l = 0; while(LMT &lt;= n) LMT &lt;&lt;= 1, ++ l; FOR(i, 1, LMT - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)); reg const int t = ksm(3, (mod - 1) &gt;&gt; l); omg[LMT &gt;&gt; 1] = 1; FOR(i, (LMT &gt;&gt; 1) + 1, LMT - 1) omg[i] = (i64)omg[i - 1] * t % mod; ROF(i, (LMT &gt;&gt; 1) - 1, 1) omg[i] = omg[i &lt;&lt; 1]; LMT = l;&#125;inline void DFT(int *a, const int &amp;n)&#123; // static i64 tmp[N]; static u64 tmp[N]; reg const int fix = LMT - l2g[n]; Rint t; FOR(i, 0, n - 1) tmp[i] = a[rev[i] &gt;&gt; fix]; for(Rint i = 1; i &lt; n; i &lt;&lt;= 1)&#123; for(Rint j = 0; j &lt; n; j += i &lt;&lt; 1)&#123; FOR(k, j, j + i - 1)&#123; t = tmp[i + k] * omg[i + k - j] % mod; // tmp[i + k] = qmo(tmp[k] - t); // tmp[k] = qmo(tmp[k] - mod + t); tmp[i + k] = tmp[k] + mod - t; tmp[k] += t; &#125; &#125; &#125; FOR(i, 0, n - 1) a[i] = tmp[i] % mod;&#125;inline void IDFT(int *a, const int &amp;n)&#123; reverse(a + 1, a + n); DFT(a, n); reg const int bk = mod - (mod - 1) / n; FOR(i, 0, n - 1) a[i] = (i64)a[i] * bk % mod;&#125;//c &lt;- a * binline void poly_mul(int *a, int *b, int *c, const int &amp;deg)&#123; static int tmp1[N], tmp2[N]; reg const int len = get_len(deg); memcpy(tmp1, a, sizeof(int) * len), memcpy(tmp2, b, sizeof(int) * len); DFT(tmp1, len), DFT(tmp2, len); FOR(i, 0, len - 1) c[i] = (i64)tmp1[i] * tmp2[i] % mod; IDFT(c, len); memset(c + deg, 0, sizeof(int) * (len - deg));&#125;//b &lt;- a ^ (-1)inline void poly_inv(int *a, int *b, const int &amp;deg)&#123; static int tmp[N]; if(deg == 1)&#123; b[0] = ksm(a[0], mod - 2); return; &#125; poly_inv(a, b, (deg + 1) &gt;&gt; 1); reg const int len = get_len(deg &lt;&lt; 1); memcpy(tmp, a, sizeof(int) * deg); memset(tmp + deg, 0, sizeof(int) * (len - deg)); DFT(b, len), DFT(tmp, len); FOR(i, 0, len - 1)&#123; b[i] = (i64)qmo(2 - (i64)b[i] * tmp[i] % mod) * b[i] % mod; &#125; IDFT(b, len); memset(b + deg, 0, sizeof(int) * (len - deg));&#125;//b(x) &lt;- \d a(x) / \d xinline void poly_der(int *a, int *b, const int &amp;deg)&#123; FOR(i, 0, deg - 2) b[i] = (i64)a[i + 1] * (i + 1) % mod; b[deg - 1] = 0;&#125;//b(x) &lt;- \int a(x) \d xinline void poly_int(int *a, int *b, const int &amp;deg)&#123; FOR(i, 1, deg - 1) b[i] = (i64)a[i - 1] * inv[i] % mod; b[0] = 0;&#125;//b &lt;- \ln ainline void poly_ln(int *a, int *b, const int &amp;deg)&#123; static int tmp[N]; poly_inv(a, tmp, deg); poly_der(a, b, deg); reg const int len = get_len(deg &lt;&lt; 1); DFT(b, len), DFT(tmp, len); FOR(i, 0, len - 1) tmp[i] = (i64)tmp[i] * b[i] % mod; IDFT(tmp, len); poly_int(tmp, b, deg); memset(b + deg, 0, sizeof(int) * (len - deg)); memset(tmp, 0, sizeof(int) * len);&#125;//b &lt;- \exp ainline void poly_exp(int *a, int *b, const int &amp;deg)&#123; static int tmp[N]; if(deg == 1)&#123; b[0] = 1; return; &#125; poly_exp(a, b, (deg + 1) &gt;&gt; 1); poly_ln(b, tmp, deg); reg const int len = get_len(deg &lt;&lt; 1); FOR(i, 0, len - 1)&#123; if(i &lt; deg) tmp[i] = qmo(a[i] - tmp[i]); else tmp[i] = 0; &#125; ++tmp[0]; DFT(b, len), DFT(tmp, len); FOR(i, 0, len - 1)&#123; b[i] = (i64)tmp[i] * b[i] % mod; &#125; IDFT(b, len); memset(b + deg, 0, sizeof(int) * (len - deg)); memset(tmp + deg, 0, sizeof(int) * (len - deg));&#125;int main() &#123; F_In; F_Out; return 0;&#125; 即使在你谷巨慢的评测机下都能够跑过机房其他人在你谷评测机还没那么慢的时候跑的 exp 。 参考资料yurzhang’s blog]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>卡常</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2011」竞赛实验班]]></title>
    <url>%2Fblog%2FYnoi2011-%E7%AB%9E%E8%B5%9B%E5%AE%9E%E9%AA%8C%E7%8F%AD%2F</url>
    <content type="text"><![CDATA[算是 Ynoi 里面较简单和套路的一题吧。 题意简述给定一个初始长为 $n$ 的数组 $A$ ，有 $m$ 个操作： 在末尾加入 $x$。 求 $\sum\limits_{i=l}^{r} A_i$。 将整个数组异或上 $x$。 将整个数组排序。 $n, m\le 10^5, 0\le x, a_i \le 10^9$，不必强制在线。 [Luogu 5312] 主要思路没有操作 1 的话大家都会，只要建棵 Trie 就能 $O(\log^2 W)$ 求最小的 $k$ 个数的和。（$O(W)$ 为值域） 大概就是每个点 $O(\log W)$ 空间存一下子树内每一位分别为 $1$ 的数的个数。 那么现在加上在末尾插入的操作，显然整个数列是前面一段有序的和后面一段无序的。无序的显然可以直接前缀和一下，$O(\log W)$ 求出某一段的和。 如果需要排序整个序列，就把前缀和清零一下，然后把每个未排序的数扔到 Trie 里去，单次 $O(\log^2 W)$。每个数只会进入 Trie 一次，故总复杂度 $O((n + m) \log^2 W)$ 。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define FORit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b) + 1; i != ed_##i; ++i)#define ROFit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b)-1; i != ed_##i; --i)#define GO(x, p, e, i, v) for (register int i = p[x].head, v; i; i = e[i].link)#define MEM(x, v) memset(x, v, sizeof(x))#define fir first#define sec second#define pq priority_queue#define MP make_pairtypedef long long LL;typedef double DB;typedef pair&lt;int, int&gt; PII;#define Templ(T) template &lt;typename T&gt;static char InB[1 &lt;&lt; 21], *In_s = InB, *In_t = InB;static char OutB[1 &lt;&lt; 21], *Out_s = OutB;inline void FGO()&#123; fwrite(OutB, 1, Out_s - OutB, stdout), Out_s = OutB; return;&#125;inline char gcr()&#123; if(In_s == In_t)&#123; In_t = (In_s = InB) + fread(InB, 1, 1 &lt;&lt; 21, stdin); if(In_s == In_t) return EOF; &#125; return *In_s ++;&#125;inline void pcr(const char &amp;c)&#123; if(Out_s - OutB == 1 &lt;&lt; 21) fwrite(OutB, 1, 1 &lt;&lt; 21, stdout), Out_s = OutB; *Out_s ++ = c;&#125;inline int read() &#123; reg int ans = 0; reg char c = gcr(); while (!isdigit(c)) c = gcr(); for (; isdigit(c); c = gcr()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return ans;&#125;inline void write(LL x)&#123; static int sta[12]; if(x &lt; 0) return pcr('-'), write(-x); Rint top = 0; do&#123; sta[top ++] = x % 10, x /= 10; &#125;while(x); while(top) pcr(sta[-- top] ^ 48);&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define using_modconst int mod = 998244353;#ifdef using_modinline void inc(int &amp;x, const int &amp;y) &#123; x += y; if (x &gt;= mod) x -= mod; &#125;inline void dec(int &amp;x, const int &amp;y) &#123; x -= y; if (x &lt; 0) x += mod; &#125;inline int ksm(int x, LL y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = 1ll * x * x % mod) if (y &amp; 1) res = 1ll * res * x % mod; return res;&#125;#endifTempl(_Tp) inline _Tp gcd(_Tp x, _Tp y) &#123; return y ? gcd(y, x % y) : x; &#125;#define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout)&#125; // namespace my_stdusing namespace my_std;const int N = 200020, M = 31, NM = 33;int n, m, sn;//sn: sorted_lengthLL sn_q;int a[N], pre[N][NM];//pre[p][k]: 现在未排序段到第 p 个数中有多少个第 k 位为 1 的数int ch[N &lt;&lt; 5][2], cnt[N &lt;&lt; 5][NM], siz[N &lt;&lt; 5], node_cnt = 1;//cnt[u][k]: 节点 u 子树内有多少个第 k 位为 1 的数int rev[NM], xr;//rev[i]: （对 trie）第 i 位是否交换; xr: 整个序列被 xor 的值//trie 应按位从大到小操作inline LL soq(int p)&#123;//sorted_query if(!p) return 0; reg LL res = 0; Rint v = 0, u = 1; ROF(k, M - 1, 0)&#123; if(p &lt;= siz[ch[u][rev[k]]])&#123; u = ch[u][rev[k]], v |= rev[k] &lt;&lt; k; &#125;//没有该位置为 1 的数 else&#123; Rint id = ch[u][rev[k]], tmp; p -= siz[id]; FOR(t, 0, M - 1)&#123; tmp = cnt[id][t]; res += (LL)(((xr &gt;&gt; t) &amp; 1) ? siz[id] - tmp : tmp) &lt;&lt; t; &#125; u = ch[u][rev[k] ^ 1]; v |= (rev[k] ^ 1) &lt;&lt; k; &#125; &#125; //最后剩下的都是 v return res + (LL)p * (v ^ xr);&#125;inline LL scq(int l, int r)&#123;//scattered_query Rint len = r - l + 1, tmp; reg LL res = 0; FOR(k, 0, M - 1)&#123; tmp = pre[r][k] - pre[l - 1][k]; res += (LL)(((xr &gt;&gt; k) &amp; 1) ? len - tmp : tmp) &lt;&lt; k; &#125; return res;&#125;inline LL query(int l, int r)&#123; if(r &lt;= sn) return soq(r) - soq(l - 1); if(l &gt; sn) return scq(l, r); return soq(sn) - soq(l - 1) + scq(sn + 1, r);&#125;inline void insert(int x)&#123; ++ siz[1]; FOR(t, 0, M - 1) cnt[1][t] += (x &gt;&gt; t) &amp; 1; Rint u = 1, d; ROF(k, M - 1, 0)&#123; d = (x &gt;&gt; k) &amp; 1; u = ch[u][d] ? ch[u][d] : ch[u][d] = ++ node_cnt; ++ siz[u]; FOR(t, 0, M - 1) cnt[u][t] += (x &gt;&gt; t) &amp; 1; &#125; return;&#125;int main()&#123; n = read(), sn = 0; FOR(i, 1, n)&#123; a[i] = read(); FOR(k, 0, M - 1) pre[i][k] = pre[i - 1][k] + ((a[i] &gt;&gt; k) &amp; 1); &#125; m = read(); Rint sta, l, r; while(m --)&#123; sta = read(); if(sta == 1)&#123; a[++ n] = read() ^ xr; FOR(k, 0, M - 1) pre[n][k] = pre[n - 1][k] + ((a[n] &gt;&gt; k) &amp; 1); &#125;else if(sta == 2)&#123; l = read(), r = read(); // printf("%lld\n", query(l, r)); write(query(l, r)), pcr('\n'); &#125;else if(sta == 3)&#123; l = read(), xr ^= l; &#125;else if(sta == 4)&#123; while(sn &lt; n) insert(a[++ sn]); FOR(k, 0, M - 1) rev[k] = (xr &gt;&gt; k) &amp; 1; FOR(k, 0, M - 1) pre[n][k] = 0; sn_q = soq(sn); &#125; &#125; return FGO(), 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Ynoi</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2010」y-fast trie]]></title>
    <url>%2Fblog%2FYnoi2010-y-fast-trie%2F</url>
    <content type="text"><![CDATA[我谔谔，被卡常力，，， 题意简述给定一个数 $C$ ，维护一个集合 $S$，支持 $n$ 次操作，操作是加入或删除一个数 $x$。 每次操作结束后求集合中两个数的和模 $C$ 的最大值，强制在线。 $n\le 5\times 10^5$。 [Luogu 6105] 主要思路首先把数都模 $C$，然后答案只有可能是两数的和或两数的和减去 $C$。 后者直接把两个最大的数拎出来求一下得了，非常好搞。 考虑前者如何处理。 再把这里的答案分成两个相等数和两个不等数，前者显然也随便做。 对于每个 $x\in S$，容易找到 $y\in S, y\neq x$ 使得对于 $x$ 答案最优（即 $x + y$ 最接近 $C$）。 试图对每个 $x\in S$ 维护一个匹配 $(x, y)$。 此时发现删除 $x$ 不好删，万一有一大堆数的最优匹配都是 $x$ 呢？复杂度退化。 于是考虑令每个数只在一个匹配中，即令匹配为双向的。这样复杂度可以保证，那么正确性呢？ 考虑 $(y, z)$ 为匹配，此时加入 $x$，其最优匹配为 $y$ 且 $x &gt; z$。此时若 $x$ 不删去，$z$ 永远不能成为 $y$ 的最优解。 所以每次删除数对其匹配更新一下即可保证正确性。 复杂度 $O(n\log n)$。 参考代码比较卡常，搞了好久才过，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define FORit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b) + 1; i != ed_##i; ++i)#define ROFit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b)-1; i != ed_##i; --i)#define GO(x, p, e, i, v) for (register int i = p[x].head, v; i; i = e[i].link)#define MEM(x, v) memset(x, v, sizeof(x))#define fir first#define sec second#define Templ(T) template &lt;typename T&gt;static char InB[1 &lt;&lt; 23], *In_s = InB, *In_t = InB;static char OutB[1 &lt;&lt; 23], *Out_s = OutB;inline void FGO()&#123; fwrite(OutB, 1, Out_s - OutB, stdout), Out_s = OutB; return;&#125;inline void FGI()&#123; In_t = (In_s = InB) + fread(InB, 1, 1 &lt;&lt; 23, stdin); return;&#125;inline char gcr()&#123; // if(In_s == In_t)&#123; // In_t = (In_s = InB) + fread(InB, 1, 1 &lt;&lt; 23, stdin); // if(In_s == In_t) return EOF; // &#125; return *In_s ++;&#125;inline void pcr(const char &amp;c)&#123; // if(Out_s - OutB == 1 &lt;&lt; 23) fwrite(OutB, 1, 1 &lt;&lt; 23, stdout), Out_s = OutB; *Out_s ++ = c;&#125;inline int read() &#123; reg int ans = 0; reg char c = gcr(); while (!isdigit(c)) c = gcr(); for (; isdigit(c); c = gcr()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return ans;&#125;inline void write(int x)&#123; static int sta[12]; if(x &lt; 0) return pcr('-'), write(-x); Rint top = 0; do&#123; sta[top ++] = x % 10, x /= 10; &#125;while(x); while(top) pcr(sta[-- top] ^ 48);&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define PBTXDY&#125; // namespace my_stdusing namespace my_std;typedef map&lt;int, int&gt;::iterator m_it;typedef multiset&lt;int&gt;::iterator ms_it;int n, C, siz;map&lt;int, int&gt; cnt;unordered_map&lt;int, int&gt; pr;multiset&lt;int&gt; df;set&lt;int&gt; sm;inline int match(int x)&#123; reg m_it it = --cnt.lower_bound(C - x); if(it-&gt;fir == x) --it; return it-&gt;fir;&#125;inline void init(int x)&#123; Rint y = match(x), z; if(y == -1) return; if(pr.count(y))&#123; z = pr[y]; if(z &lt; x)&#123; pr.erase(z), pr[x] = y, pr[y] = x; df.erase(df.find(z + y)), df.insert(x + y); //把 z 从匹配中删去 &#125; &#125; else&#123; pr[y] = x, pr[x] = y; df.insert(x + y); &#125; return;&#125;inline void add(int x)&#123; Rint cnt_ = ++ cnt[x]; if(cnt_ == 1) return init(x);//第一次出现 if(cnt_ == 2 &amp;&amp; 2 * x &lt; C) sm.insert(2 * x);&#125;inline void del(int x)&#123; Rint cnt_ = -- cnt[x]; if(!cnt_)&#123; cnt.erase(x); Rint y; if(pr.count(x))&#123; y = pr[x]; pr.erase(y), pr.erase(x); df.erase(df.find(x + y)), init(y); //把整个匹配都删了，再把 y 加回去 &#125; return; &#125; if(cnt_ == 1 &amp;&amp; 2 * x &lt; C) sm.erase(2 * x);&#125;inline int query()&#123; Rint ans = 0; reg m_it it = --cnt.end(); ans = (it-&gt;sec &gt; 1) ? 2 * it-&gt;fir % C : (it-&gt;fir + (--it)-&gt;fir) % C; if(!sm.empty()) chkmax(ans, *(--sm.end())); if(!df.empty()) chkmax(ans, *(--df.end())); return ans;&#125;int main() &#123; FGI(); cnt[-1] = 1; n = read(), C = read(); Rint opt, x, lastans = 0; while(n --)&#123; opt = read(), x = (read() ^ lastans) % C; opt == 1 ? (add(x), ++siz) : (del(x), --siz); // if(siz &gt; 1) printf("%d\n", lastans = query()); // else puts("EE"), lastans = 0; if(siz &gt; 1) write(lastans = query()); else pcr('E'), pcr('E'), lastans = 0; pcr('\n'); &#125;//我谔谔，，， return FGO(), 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Ynoi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调和专题]]></title>
    <url>%2Fblog%2F%E8%B0%83%E5%92%8C%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[调和太有意思了，所以就有了这篇博客。 基本定义调和点列【定义1.1】对于线段 $AB$ 的内分点 $C$ 和外分点 $D$，若满足 $\dfrac{AC}{BC}=\dfrac{AD}{BD}$，即内分比等于外分比，则称点 $C, D$ 调和分割线段 $AB$，或者点 $A, B, C, D$ 为调和点列。 若直线 $l$ 上，点 $C, D$ 调和分割线段 $AB$，$M$ 为 $AB$ 中点，则有： 【性质1.1】点 $A, B$ 调和分割线段 $CD$。 【性质1.2】$\dfrac{1}{AC} + \dfrac{1}{AD} = \dfrac{2}{AB}$。 【性质1.3】$AB\cdot CD = 2AD\cdot BC$。 【性质1.4】$CA\cdot CB = CM\cdot CD$，$DA\cdot DB = DM\cdot DC$。 【性质1.5】$MA^2 = MB^2 = MC\cdot MD$。这说明，任意做过点 $C, D$ 的 $\odot \Gamma$ 及与直线 $l$ 相切于点 $B$ 的 $\odot O$，则点 $M$ 对 $\odot \Gamma, \odot O$ 的幂相等，即其在 $\odot \Gamma, \odot O$ 的根轴上。 证明非常显然。 【性质1.6】如下图，$\triangle{ABC}$ 的内切圆 $\odot I$ 与三边分别切于 $D, E, F$，直线 $EF, BC$ 交于点 $P$，则 $B, C, D, P$ 成调和点列。 证明： 对 $\triangle{ABC}$ 及其截线 $FEP$ 用 Menelaus 定理得$\dfrac{AF}{FB}\cdot\dfrac{BP}{PC}\cdot\dfrac{CE}{EA} = 1$。又 $AE = AF, BF = BD, CE = CD$，故 $\dfrac{BD}{DC} = \dfrac{BP}{PC}$，根据【定义1.1】$B, C, D, P$ 成调和点列。 调和线束【定义2.1】若一条直线上的点 $A, B, C, D$ 为一组调和点列，点 $P$ 不在直线上，连接 $PA, PB, PC, PD$，则 $PA, PB, PC, PD$ 为一组调和线束。 【性质2.1】对于直线 $l$ 上顺序四点 $A, C, B, D$ 与直线 $l$ 外一点 $P$，则 $\dfrac{\sin\angle{APC}}{\sin\angle{BPC}}=\dfrac{\sin\angle{APD}}{\sin\angle{BPD}}$ 等价于 $A, B, C, D$ 成调和点列。 证明： $A, B, C, D$ 成调和点列 $\iff \dfrac{AC}{BC} = \dfrac{AD}{BD}$而 $\dfrac{AC}{BC} = \dfrac{PA\sin\angle{APC}}{PB\sin\angle{BPC}}, \dfrac{AD}{BD} = \dfrac{PA\sin\angle{APD}}{PB\sin\angle{BPD}}$故 $\dfrac{\sin\angle{APC}}{\sin\angle{BPC}}=\dfrac{\sin\angle{APD}}{\sin\angle{BPD}}\iff\dfrac{AC}{BC} = \dfrac{AD}{BD}$，证毕。 在一些地方【性质2.1】被作为调和线束的定义，但本处我们用调和点列来定义调和线束。 【性质2.2】对于调和点列 $PA, PB, PC, PD$，作不过 $P$ 的另一直线截该调和点列于点 $A’, B’, C’, D’$，则 $A’, B’, C’, D’$ 也为调和点列。 观察到【性质2.1】仅与 $PA, PB, PC, PD$ 四条直线间夹角有关而与直线 $l$ 的选取无关，故显然正确。 【性质2.3】对于直线 $l$ 上顺次四点 $A, C, B, D$ 及直线 $l$ 外一点 $P$，以下四个条件中任意两个可推出另外两个： $A, B, C, D$ 成调和点列； $CP\perp PD$； $PC$ 平分 $\angle{APB}$； $PD$ 平分 $\angle{APB}$ 外角。 证明： 均较显然，以下仅给出1,2推3,4及3,4推1,2的证明。 1,2推3,4: 由1,2知 $\dfrac{\sin\angle{APC}}{\sin\angle{BPC}}=\dfrac{\sin\angle{APD}}{\sin\angle{BPD}} = \dfrac{\sin(\frac{\pi}{2}+\angle{APC})}{\sin(\frac{\pi}{2}-\angle{BPC})}=\dfrac{\cos\angle{APC}}{\cos\angle{BPC}}$，易得3,4。 3,4推1,2: 2显然成立。由3知 $\dfrac{AC}{BC}=\dfrac{S_{\triangle{APC}}}{S_{\triangle{BPC}}}=\dfrac{AP}{BP}$由4知 $\dfrac{AD}{BD}=\dfrac{S_{\triangle{APD}}}{S_{\triangle{BPD}}}=\dfrac{AP}{BP}$故 $\dfrac{AC}{BC}=\dfrac{AD}{BD}$，得证。 调和四边形【定义3.1】设 $ABCD$ 为圆内接四边形，若满足 $AB\cdot CD = AD\cdot BC$，则称四边形 $ABCD$ 为调和四边形。 【性质3.1】$ABCD$ 为 $\odot O$ 的内接四边形，则过 $A, C$ 作切线 $PA, PC$，且 $P, B, D$ 共线为 $ABCD$ 是调和四边形的充分必要条件。 【性质3.2】$ABCD$ 为 $\odot O$ 的内接四边形，则取 $\odot O$ 上任意一点 $P$，$PA, PB, PC, PD$ 为调和线束为 $ABCD$ 是调和四边形的充分必要条件。 证明： 极点与极线设 $\odot O$ 半径为 $R$。 【定义4.1】对于不同于 $\odot O$ 的任意一点 $P$，作一直线 $l$ 通过 $P$ 的反演像 $P’$（即 $O, P, P’$ 共线且 $OP\cdot OP’ = R^2$）且垂直于射线 $OP$，则称直线 $l$ 为点 $P$ 的极线，点 $P$ 为直线 $l$ 的极点。 【性质4.1】显然，对于 $\odot O$ 外的一点 $P$，做切线 $PQ_1, PQ_2$，则 $P$ 的极线为 $Q_1Q_2$。 【性质4.2】（配极定理）若点 $A$ 的极线穿过点 $D$，则点 $D$ 的极线也穿过点 $A$，一般称 $A, D$ 互为共轭点。设 $\operatorname{cp}(A, \odot O)$ 为点 $A$ 对 $\odot O$ 的幂，则此时有 $AD^2 = \operatorname{cp}(A, \odot O) + \operatorname{cp}(D, \odot O)$。 证明： 陪位中线阿波罗尼斯圆稍微深入些的性质回到内切圆构型以下构型在内切圆基础上延伸。 【性质5.1】 如图，过点 $D$ 作 $EF$ 的垂线，垂足为 $K$，则 $DK$ 平分 $\angle{BKC}$。 证明： 由【性质1.6】与【性质2.3】既得。 【性质5.2】 在上图的基础上，$H$ 是 $\triangle{ABC}$ 垂心，则直线 $KH$ 与 $KI$ 关于直线 $KD$ 对称。 证明： 设直线 $BH, EF$ 交于 $X$，直线 $CH, EF$ 交于 $Y$。 由【性质5.1】易得 $\triangle{BFK}\sim\triangle{CEK}$由于 $BX\parallel IE, CY\parallel IF$，故 $\triangle{EIF}\sim\triangle{YHX}$且知 $\triangle{BFX}\sim\triangle{CEY}\Rightarrow\dfrac{FX}{EY}=\dfrac{BF}{CE}=\dfrac{FK}{EK}=\dfrac{FX-FK}{EY-EK}=\dfrac{KX}{KY}$则 $\triangle{EIF}\sim\triangle{YHX}$，且 $K$ 与 $K$ 是对应点，故 $\angle{FKI}=\angle{EKH}$又 $DK\perp EF$，故直线 $KH$ 与 $KI$ 关于直线 $KD$ 对称 （$I, H$ 未必在直线 $EF$ 的同一侧，但以上证明对于是否在同一侧均适用） 例题]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeChef FGTREE」Forgotten Tree 9]]></title>
    <url>%2Fblog%2FCC-FGTREE%2F</url>
    <content type="text"><![CDATA[很妙的一道交互。 [CodeChef FGTREE] 题意简述一棵 $n$ 个点的有根二叉树，树中节点编号为中序遍历中的 dfs 序。其中 $n \le 100$ 。 你可以询问不超过 $300$ 次形如 $(i, l, r)$ 的问题，表示询问 $i$ 子树内编号最小值是否为 $l$ 且最大值是否为 $r$ 。 请回答每个点的父亲的编号。 主要思路考虑按照编号从小到大尝试确定父亲。维护一个栈来存储还没有确定父亲的节点。不妨设我们已经加入到点 $x$ 。 先判断其是否在栈顶的子树中，若是则直接压入栈中；否则弹出栈顶并继续直到可压入栈中。 考虑过程中弹出的点按弹出先后为 $\langle v_m\rangle$，则弹出的点子树中的最大编号均为 $x - 1$，故 $\mathrm{fth}(v_i) = v_{i + 1}$（$v_{m + 1} = x$）。 加入所有点后，若栈非空，不难发现这些点子树中最大编号均为 $n$，故也相邻两点有父子关系。 那么在此过程中如何判断 $x$ 是否在某个点 $y$ 的子树内？可以询问 $(y, l_y, x - 1)$，若返回值为假则在子树中。而 $l_y$ 显然可以在过程中更新。 于是做完，查询次数 $O(n)$，据说可以卡满。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;#define F_O fflush(stdout)const int N = 110;class Stack&#123;private: int a[N], t;public: inline bool empty()&#123; return t == 0; &#125; inline int size()&#123; return t; &#125; inline int top()&#123; return t ? a[t - 1] : -1; &#125; inline bool pop()&#123; return t ? (-- t, 1) : 0; &#125; inline void push(int x)&#123; a[t ++] = x; &#125; inline void clear()&#123; t = 0; &#125; inline void print()&#123; puts("Stack:"); for(int i = 0; i &lt; t; ++i)&#123; printf("%d, ", a[i]); &#125; puts(""); &#125;&#125;;int n, f[N], l[N];Stack S, T;inline bool query(int x, int l, int r)&#123; printf("Q %d %d %d\n", x, l, r); F_O; char c[5]; scanf("%s", c); return *c == 'Y';&#125;inline void work()&#123; scanf("%d", &amp;n); S.clear(), T.clear(); memset(f, 0, sizeof(f)); int t; for(int x = 1; x &lt;= n; ++x) l[x] = x; for(int x = 1; x &lt;= n; ++x)&#123; while(!S.empty())&#123; t = S.top(); S.pop(); bool g = query(t, l[t], x - 1); if(!g)&#123; S.push(t); break; &#125; T.push(t); &#125; if(!T.empty())&#123; l[x] = l[T.top()]; T.push(x); t = 0; while(!T.empty())&#123; f[T.top()] = t; t = T.top(); T.pop(); &#125; &#125; S.push(x); &#125; while(!S.empty())&#123; t = S.top(); S.pop(); f[t] = S.top(); &#125; printf("A "); for(int x = 1; x &lt; n; ++x) printf("%d ", f[x]); printf("%d\n", f[n]); F_O; return;&#125;int main()&#123; int esac; scanf("%d", &amp;esac); while(esac --) work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>猜结论</tag>
        <tag>CodeChef</tag>
        <tag>交互题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF793F」Julia the snail]]></title>
    <url>%2Fblog%2FCF793F%2F</url>
    <content type="text"><![CDATA[《关于本弱智为了减小常数而手动讨论导致写错调到死这件事》 [CF 793F] 题意简述有一只蜗牛在树干上爬，有两种移动方式，沿着某根绳子向上爬，或者顺着树干往下溜。 树干高度为 $n$，有 $m$ 根绳子，第 $i$ 条连接了高度 $l_i$ 至 $r_i$，保证 $r_i$ 互不相同。 有 $q$ 次询问，每次给出两个数 $L, R$ ，问蜗牛从高度 $L$ 开始爬，只考虑被包含在 $[L, R]$ 间的绳子（即若一条绳子的区间超出询问范围即不能使用），蜗牛能够爬到的最大高度。 $1 \le n, m, q \le 10^5$ ，输入均为正整数。 主要思路$O(n\sqrt{n})$ 做法假设我们要处理右端点为 $R_0$ 的所有询问，则可以将右端点不超过 $R_0$ 的绳子按左端点降序排序，依次插入，用单调栈维护当前被绳子覆盖的区间，在 $O(n)$ 时间内解决。 则考虑回滚莫队，块长为 $\sqrt{n}$ 。我们现在试图一次处理完右端点在某个块 $b$ 中的所有询问。定义该块前最右点为 $R_0$，右端点落在该块中的绳子称为「该块中的绳子」，落在该块前的称为「已处理的绳子」。 显然对于一个从 $x$ 出发的询问，必定先沿着已处理的绳子走到最右端后，再试图沿着该块中的绳子走。所以将该块中的绳子按左端点升序排序后，能走就走即可。 $O(n\log{n})$ 做法考虑按右端点从左到右地处理每个询问。设当前处理到的右端点为 $R_0$ ，当前从 $x$ 出发的询问的答案为 $a_x$ 。 假设右端点右移一格，加入一条绳子 $[L_0, R_0 + 1]$。对于 $x &gt; L_0$，这条绳子因不在询问区间内而不会产生任何影响。对于 $x \le L_0$，若 $a_x &lt; L_0$ ，则因本来就无法碰到该线段所在位置而不会产生任何影响；而对于 $a_x \ge L_0$，有 $a_x\gets R_0 + 1$。 形式化地，相当于维护序列 $\langle a\rangle$，有两个操作： 将区间中不小于 $x$ 的数设为 $y$； 单点求值。 这不是 jiry_2 老师的线段树么。 大概就是对每个节点记录最大值与严格次大值 $fir, sec$，和一个二元的 tag $(x, y)$，即将不小于 $x$ 的数改为 $y$。 下传标记操作的时候就将儿子的 $y$ 改成自己的 $y$（由于绳子按右端点升序排序，这样显然更优），而在 $x$ 已有值时应改为较小值。 然后本人因为上传节点操作试图卡常写挂了 于是 $O(n\log n)$ 了。（复杂度证明详见 jls 原课件） 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue // #define MP make_pair typedef long long LL; typedef double DB; // typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout) #define PBTXDY&#125;using namespace my_std;struct my_pair&#123; int first, second; inline my_pair(int f = 0, int s = 0)&#123; first = f, second = s; &#125;&#125;;#define MP(a, b) my_pair(a, b)const int N = 100010, inf = 1145141919;int n, m, q;int lft[N], ans[N];vector&lt;my_pair&gt; Q[N];my_pair a[N &lt;&lt; 2], tag[N &lt;&lt; 2];inline void merge_node(int x, int y)&#123; reg my_pair res = a[y]; if(res.fir &gt; a[x].fir)&#123; a[x].sec = a[x].fir, a[x].fir = res.fir; chkmax(a[x].sec, res.sec); &#125; else if(res.fir &lt; a[x].fir)&#123; chkmax(a[x].sec, res.fir); &#125; else&#123; chkmax(a[x].sec, res.sec); &#125;&#125;inline void merge_tag(int x, int y)&#123; reg my_pair res = tag[y]; if(a[x].fir &gt;= res.sec)&#123; a[x].fir = res.fir; if(!tag[x].sec) tag[x].sec = res.sec; else chkmin(tag[x].sec, res.sec); tag[x].fir = res.fir; &#125;&#125;inline void push_up(int t)&#123; a[t] = a[t &lt;&lt; 1], merge_node(t, t &lt;&lt; 1 | 1);&#125;inline void push_down(int t)&#123; if(tag[t].fir)&#123; merge_tag(t &lt;&lt; 1, t), merge_tag(t &lt;&lt; 1 | 1, t); tag[t] = MP(0, 0); &#125; return;&#125;void build(int t, int l, int r)&#123; if(l == r) return a[t] = my_pair(l, -inf), void(); Rint mid = (l + r) &gt;&gt; 1; build(t &lt;&lt; 1, l, mid), build(t &lt;&lt; 1 | 1, mid + 1, r); return push_up(t);&#125;void update(int t, int l, int r, int L, int R, my_pair x)&#123; if(a[t].fir &lt; x.sec) return; if(L &lt;= l &amp;&amp; r &lt;= R &amp;&amp; a[t].sec &lt; x.sec) return *tag = x, merge_tag(t, 0); push_down(t); Rint mid = (l + r) &gt;&gt; 1; if(L &lt;= mid) update(t &lt;&lt; 1, l, mid, L, R, x); if(R &gt; mid) update(t &lt;&lt; 1 | 1, mid + 1, r, L, R, x); return push_up(t);&#125;int query(int t, int l, int r, int x)&#123; if(l == r) return a[t].fir; push_down(t); Rint mid = (l + r) &gt;&gt; 1; return x &lt;= mid ? query(t &lt;&lt; 1, l, mid, x) : query(t &lt;&lt; 1 | 1, mid + 1, r, x);&#125;int main()&#123; n = read(); m = read(); Rint l, r; FOR(i, 1, m)&#123; l = read(), r = read(); lft[r] = l; &#125; q = read(); FOR(i, 1, q)&#123; l = read(), r = read(); Q[r].push_back(MP(l, i)); &#125; build(1, 1, n); FOR(i, 1, n)&#123; if(lft[i]) update(1, 1, n, 1, lft[i], MP(i, lft[i])); for(my_pair &amp;x : Q[i])&#123; ans[x.sec] = query(1, 1, n, x.fir); &#125; &#125; FOR(i, 1, q) printf("%d\n", ans[i]); return 0;&#125; 参考资料Segment Tree Beats! ZigZagK 的博客]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>log数据结构</tag>
        <tag>莫队</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aria2和BT下载]]></title>
    <url>%2Fblog%2Faria2%E5%92%8CBT%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[下 gal 被屑度网盘限速了，在再次寻找对抗限速的方法时顺带搞好了 aria2 环境和 BT 下载环境。可惜没有公网 ip ，否则「下载」二字即可去掉。 然而最后也没有成功对抗限速。 aria2aria2 GitHub仓库AriaNg GitHub仓库Aria2 for Chrome 参考资料Aria2 &amp; YAAW 使用说明老王的自留地 | 关于aria2最完整的一篇悠然 | Aria2基础上手指南andforce | aria2使用教程 下载先到 releases 去下载需要的版本。 本人 windows 64 位机下解压所得如下： 123456789aria2│ aria2c.exe│ AUTHORS│ ChangeLog│ COPYING│ LICENSE.OpenSSL│ NEWS│ README.html│ README.mingw 以下所指操作位置，若未特别说明，均在 aria2 文件夹下。 创建 3 个空文件：aria2.conf, aria2.log, aria2.session，分别作为配置文件、日志文件、会话文件。 aria2.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118## &apos;#&apos;开头为注释内容, 选项都有相应的注释说明, 根据需要修改 #### 被注释的选项填写的是默认值, 建议在需要修改时再取消注释 #### 文件保存相关 ### 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置dir=./downloads/# 日志的保存路径log=./aria2.log# 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M#disk-cache=32M# 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc# 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc# falloc和trunc则需要文件系统和内核支持# NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项file-allocation=falloc# 断点续传continue=true## 下载连接相关 ### 最大同时下载任务数, 运行时可修改, 默认:5max-concurrent-downloads=4# 同一服务器连接数, 添加时可指定, 默认:1max-connection-per-server=8# 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M# 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载min-split-size=8M# 单个任务最大线程数, 添加时可指定, 默认:5split=32# 整体下载速度限制, 运行时可修改, 默认:0max-overall-download-limit=0# 单个任务下载速度限制, 默认:0max-download-limit=0# 整体上传速度限制, 运行时可修改, 默认:0max-overall-upload-limit=0# 单个任务上传速度限制, 默认:0max-upload-limit=0# 禁用IPv6, 默认:falsedisable-ipv6=true# 连接超时时间, 默认:60timeout=60# 最大重试次数, 设置为0表示不限制重试次数, 默认:5max-tries=0# 设置重试等待的秒数, 默认:0retry-wait=0## 进度保存相关 ### 从会话文件中读取下载任务input-file=./aria2.session# 在Aria2退出时保存`错误/未完成`的下载任务到会话文件save-session=./aria2.session# 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0#save-session-interval=60## RPC相关设置 ### 启用RPC, 默认:falseenable-rpc=true# 允许所有来源, 默认:falserpc-allow-origin-all=true# 允许非外部访问, 默认:falserpc-listen-all=true# 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同#event-poll=select# RPC监听端口, 端口被占用时可以修改, 默认:6800rpc-listen-port=6800# 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项#rpc-secret=&lt;TOKEN&gt;# 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-user=&lt;USER&gt;# 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-passwd=&lt;PASSWD&gt;# 是否启用 RPC 服务的 SSL/TLS 加密,# 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接#rpc-secure=true# 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,# 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥#rpc-certificate=/path/to/certificate.pem# 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件#rpc-private-key=/path/to/certificate.key## BT/PT下载相关 ### 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true#follow-torrent=true# BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999listen-port=51413# 单个种子最大连接数, 默认:55#bt-max-peers=55# 打开DHT功能, PT需要禁用, 默认:trueenable-dht=false# 打开IPv6 DHT功能, PT需要禁用#enable-dht6=false# DHT网络监听端口, 默认:6881-6999#dht-listen-port=6881-6999# 本地节点查找, PT需要禁用, 默认:false#bt-enable-lpd=false# 种子交换, PT需要禁用, 默认:trueenable-peer-exchange=false# 每个种子限速, 对少种的PT很有用, 默认:50K#bt-request-peer-speed-limit=50K# 客户端伪装, PT需要peer-id-prefix=-TR2770-user-agent=Transmission/2.77peer-agent=Transmission/2.77# 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0seed-ratio=0# 强制保存会话, 即使任务已经完成, 默认:false# 较新的版本开启后会在任务完成后依然保留.aria2文件#force-save=false# BT校验相关, 默认:true#bt-hash-check-seed=true# 继续之前的BT任务时, 无需再次校验, 默认:falsebt-seed-unverified=true# 保存磁力链接元数据为种子文件(.torrent文件), 默认:falsebt-save-metadata=true 大概的设置都在这里了。 几个重要的： dir似乎必须要有，log建议改成你的aria2.log的位置，input-file和save-session建议改成aria2.session的位置。 max-concurrent-downloads, max-connection-per-server, min-split-size, split根据需求自行修改。 你是否在上述过程中试图打开 aria2.exe ？正常情况下，应该会出现一个立即消失的命令行窗口，并且该进程立即消失。 开启 aria2.exe再创建一个文件 HideRun.vbs ，写入以下代码： 1CreateObject("WScript.Shell").Run "aria2c.exe --conf-path=aria2.conf",0 运行 HideRun.vbs ，现在应该可以找到进程 aria2.exe 了。 可是没有 GUI 啊，怎么下载啊？ 控制台可以使用 yaaw(zh-hans) 来看到自己的 aria2 状态。为了证明您的 aria2 已经正常运行，可以试着下载一个小文件。 然而界面不好看并且每次使用要打开网页太慢了（恼），所以本人换了一个 WebUI ，改成了 AriaNg 。 怕麻烦，直接在 releases 里下载了一个 all-in-one 包，解压之后打开 index.html 即可。 对我而言这个界面舒服多了。 插件自行安装即可（感觉效果不佳啊……）。 qBittorrent Q：为什么选择 qBittorrent ？A：大佬推荐的。 qbittorrent 下载官网下载所需版本即可。个人使用4.1.9。 然后相信大部分操作应该都一看就会了。 trackersngosangnewtrackon 在 工具&gt;选项&gt;BitTorrent 里添加即可。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[瞎搞Hexo博客]]></title>
    <url>%2Fblog%2F%E7%9E%8E%E6%90%9EHexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[没错我又开始瞎搞我的 blog 了。 源码问题看了 yansheng836 的 README.md （smwy）和某个 issue ，觉得自己也应该把源码一并传到 github 上。 我在 git 仓库里开了个名为 source 的 branch，本地也开了个仓库，现在每次更改之后就将源码推送到 source 。 然后每次搞完 blog 在 commit 的时候就要多写几行。 1234hexo cl &amp;&amp; hexo g &amp;&amp; hexo dgit add *git commit -m "~"git push origin master:source 不妨顺便把 .gitignore 也贴在这里： 12345678.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/.gitignore 渲染问题总有时候不想让 hexo 渲染某些 blog 里的 html 或者 md 文件。 于是可以改根目录下的 _config.yml 。 查了一下，发现只用改 skip_render 即可。 好像路径匹配用的是 glob 表达式，感觉和正则表达式有些相像，但规则简单得多。 这里就不放了，可以去阮一峰的博客学习。 隐藏博文大概知道怎么搞了，然而咕了。 怎么我老是咕啊 多地编辑经笔者尝试多地编辑后，出现了一些小问题。 不用hexo init！啊，git clone -b source &lt;my_repo&gt;之后，可以不用hexo init。 不如说不应该用，否则会多出令人烦躁的一些初始化的产物。 直接 123npm installnpm install hexo-cli -gnpm install hexo-deployer-git --save 就好了。 拯救自定义排序首先，我的自定义排序没了。 这是因为原本自定义排序是通过更改node_modules\hexo-generator-index\lib\generator.js实现的。 123456789101112131415161718192021222324252627282930313233'use strict';var pagination = require('hexo-pagination');module.exports = function(locals) &#123; var config = this.config; var posts = locals.posts.sort(config.index_generator.order_by); posts.data = posts.data.sort(function (a, b) &#123;//这里是排序 if (a.top &amp;&amp; b.top) &#123; if (a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if (a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if (!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; &#125;); var paginationDir = config.pagination_dir || 'page'; var path = config.index_generator.path || ''; return pagination(path, posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 恢复font-awesome咋 font-awesome 也没了。 尝试了各种方法，最后直接在/themes/next/_config.yml里加了下面这句： 1fontawesome: //cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css 然后现在就是在线拉取 font-awesome 了（ 拉取更新啊这个大概不用提吧。 12git fetch origin sourcegit merge origin/source]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪内切圆专题学习]]></title>
    <url>%2Fblog%2F%E4%BC%AA%E5%86%85%E5%88%87%E5%9C%86%E4%B8%93%E9%A2%98%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[这是学习纯几何吧里的伪内切圆专题之后写的一些笔记。 然而能看懂的东西不多 前置知识给定 $\triangle{ABC}$ 与其外接圆 $\odot{\Omega}$ ，$\triangle{ABC}$ 的 $A-$伪内切圆 $\odot{\omega_A}$ 分别切 $\odot{\Omega}, AC, AB$ 于点 $T, E, F$ 。$I$ 为 $\triangle{ABC}$ 内心，$N, M$ 分别为 $\overset{\LARGE{\frown}}{AB}, \overset{\LARGE{\frown}}{AC}$ 中点。$AT$ 交 $\odot{\omega_A}$ 于点 $P$ 。 有以下几个经典结论： $I, E, F$ 共线且 $EI = FI$ 。 $N, F, T$ 共线， $M, E, T$ 共线。 $\angle{BTI} = \angle{CTI}$ 。 $TBFI\sim TFPE\sim TIEC$ 。 例题A给定 $\triangle{ABC}$ 与其外接圆 $\odot{O}$ ，三个伪内切圆 $\odot{O_A}, \odot{O_B}, \odot{O_C}$ 分别切 $\odot{O}$ 于点 $T_A, T_B, T_C$ 。证明 $AT_A, BT_B, CT_C$ 共点。 A-sol只需证 $\dfrac{AT_B}{T_BC}\dfrac{CT_A}{T_AB}\dfrac{BT_C}{T_CA} = 1$ 。 不妨只看 $\dfrac{CT_A}{BT_A}$ 。 由 Mannheim 定理易证 $\triangle{BIT_A}\sim \triangle{ICT_A}$ ，即有 $\dfrac{BI^2}{CI^2} = \dfrac{BT_A}{IT_A}\times \dfrac{IT_A}{CT_A} = \dfrac{BT_A}{CT_A}$ 。 所以 $\dfrac{AT_B}{T_BC}\dfrac{CT_A}{T_AB}\dfrac{BT_C}{T_CA} = 1$ ，证毕。 B给定 $\triangle{ABC}$ 外接圆 $\odot{\Omega}$ ，过 $A$ 作 $AA^\prime\parallel BC$ 交外接圆于点 $A^\prime$ ，$L$ 为 $\overset{\LARGE{\frown}}{BAC}$ 的中点。 $\triangle{ABC}$ 内切圆 $\odot{I}$ 与 $BC$ 切于点 $D$ 。射线 $A^\prime D, LI$ 交于点 $T$，证明 $T$ 在 $\odot{\Omega}$ 上。 B-sol作 $\triangle{ABC}$ 的 $A-$伪内切圆 $\odot{\omega_A}$ ，切点分别为 $F, E, T$ 。设点 $N$ 为 $AT$ 与 $BC$ 交点。下证 $TI$ 延长线与 $\odot{\Omega}$ 交于 $L$ 为 $\overset{\LARGE{\frown}}{BAC}$ 的中点， $TD$ 延长线交 $\odot{\Omega}$ 于点 $A^\prime$ 且 $A^\prime A\parallel BC$ 。 证明 $L$ 为 $\overset{\LARGE{\frown}}{BAC}$ 中点由 Mannheim 定理，显然 $TF$ 延长线过 $\overset{\LARGE{\frown}}{AB}$ 的中点，即有 $\angle{BTF} = \dfrac{C}{2}$ 。又 $\angle{FIB} = \angle{BIA} - \dfrac{\pi}{2} = \dfrac{C}{2} = \angle{BTF}$ ，可得 $B, T, I, F$ 共圆。同理得 $C, T, I, E$ 共圆。倒角，显然有 $BFIT\sim IECT$ 。 故 $\angle{BTI} = \angle{CTI} = \dfrac{\pi - A}{2}$ ，得证。 证明 $AA^\prime\parallel BC$ 原命题等价于证明 $TL$ 为 $\angle{DTN}$ 角平分线，即 $\angle{BTD} = \angle{CTN}$。 注意到此时有 $\dfrac{BD}{CD} = \dfrac{BT\sin\angle{BTD}}{CT\sin\angle{CTD}}, \dfrac{BN}{CN} = \dfrac{BT\sin\angle{BTN}}{CT\sin\angle{CTN}}$ ，即 $\dfrac{BD}{CD}\times \dfrac{BN}{CN} = \dfrac{BT^2}{CT^2}$ 。易证上式也为为 $\angle{BTD} = \angle{CTN}$ 的充分条件。 导面积： $\dfrac{BN}{CN} = \dfrac{S_{\triangle{ABT}}}{S_{\triangle{ACT}}} = \dfrac{AB\times BT}{AC\times CT}$ 。 导边： $\dfrac{BD}{CD} = \dfrac{BI\sin\angle{BID}}{CI\sin\angle{CID}} = \dfrac{BI\sin{\frac{\pi + B}{2}}}{CI\sin\frac{\pi + C}{2}}$ 注意到 $\triangle{ABI}, \triangle{ACI}$ 中有 $\dfrac{AB}{AC} = \dfrac{BI\sin\angle{\frac{\pi + C}{2}}}{CI\sin\angle{\frac{\pi + B}{2}}}$ ，所以有 $\dfrac{BD}{CD} = \dfrac{BI^2}{CI^2}\times \dfrac{AC}{AB}$ 。 利用上一题的结论可得 $\dfrac{BD}{CD} = \dfrac{BT}{CT}\times \dfrac{AC}{AB}$ 。 $\therefore \dfrac{BD}{CD} \times \dfrac{BN}{CN} = \dfrac{BT^2}{CT^2}$ ，得证。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[庚子弥生月的瞎扯]]></title>
    <url>%2Fblog%2F20200229%2F</url>
    <content type="text"><![CDATA[我也不知道我为啥要起一个如此迷惑的标题 今年二月多了一天，但仍然没能让笔者不咕。 于是三月也咕了！ 本文中所有时间均为 UTC+8。 20200229现在是 2 月 29 日 23:59 ，目前无事发生。 20200301现在是 3 月 1 日 00:00 ，目前无事发生。 20200326下午一上课，某群突然开始传国内 github pages 被 mitm 的消息。一看，复现成功，出现巨大多「非私密连接」错误，噔噔咚。联想 25 日 RSSHub 的倒地，不安感，流了出来，，， 20200327现在是 3 月 27 日 00:30 ， github pages 还在被 mitm 。 现在是 3 月 27 日 08:00 ， github 也被 mitm 了。 草（辱骂）。 现在是 3 月 27 日 09:45 ， github 突然好了。 草（辱骂）。真就 *** 在测试？ 现在是 3 月 27 日 10:35 ， github 又被 mitm 了。 草（梅开三度） 现在是 3 月 27 日 11:00 ， 这 mitm 还换证书了。 ****（直球）。 睡了个午觉，全 好 了。 这不是在调试 *** 功能是在干啥呢¿ 草。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>计划与总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF512D」Fox and Travelling]]></title>
    <url>%2Fblog%2FCF512D%2F</url>
    <content type="text"><![CDATA[题意简述[CF 512D] 给定一张 $n$ 个点 $m$ 条边的简单无向图，每次可以选择一个度数为 $1$ 的点删除，求删去 $0, 1, \dots, n$ 个点的方案数模 $10^9 + 9$。两种方案不同当且仅当二者在某一步选择的点不同。$1\le n\le 100$ 。 主要思路在环上的点一定无法被选择，因此去除所有删不掉的点后图是一个森林。对每棵树分别计算选择 $0$ 到 $size$ 个点的答案，卷积起来即可。注意如果一个点在原图中与不可选的点之间有连边，那么它在这个连通块里一定是最后被选择的。注意以这个点为根时，在一个点的子树里的点都被选后，其自身才能被选。考虑树形 dp ，令 $f_{i, j}$ 表示在 $i$ 子树里选出 $j$ 个点的方案，转移为对子树的 $f$ 卷积。 现在考虑一个连通块在原图中即为树的情况。我们无法确定选择所有点时最后被选的点。这种情况对所有点都以其为根做一次 dp ，对于有 $i$ 个点选了的方案，会在不以这 $i$ 个点为根时都计算一次，所以对于没有选完而选了 $i$ 个点的方案，除以 $size - i$ 即可去重。 单次树上背包时间复杂度 $O(n^2)$ ，所以总时间复杂度 $O(n^3)$ 。 参考代码咕]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>dp</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类A001608数列的一些性质]]></title>
    <url>%2Fblog%2F%E7%B1%BBA001608%E6%95%B0%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%A7%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[今日上某数学课的时候有一道这样的题目： 给定数列 $a_n = a_{n - 3} + a_{n - 2}; a_0 = 3, a_1 = 0, a_2 = 2$ ，证明如果 $p$ 为质数，有 $p|a_p$ 。 这个数列是 oeis 上的 A001608。 这个问题已经有了很多种证明方法，例如B. H. Neumann and L. G. Wilson, Some Sequences like Fibonacci’s, Fibonacci Quart., 17(1), 1979, p. 83.和E. B. Escott, Problem 151, Amer. Math. Monthly, 15 (1908), 209.。这两份 pdf 的本博客链接：neumann.pdf, 151.pdf。 本处介绍一种思路较为简单的证明方法。 考虑 $a_n$ 的意义，将 $a_n$ （$n\ge 3$）作如下定义：一个长 $n$ 的环按顺序标号 $1$ 到 $n$，环上标号为 $u$ 的点有权值 $w_u$，权值为 $0$ 或 $1$ ，且每个权值为 $1$ 的点到其他权值为 $1$ 的点的最短距离为 $2$ 或 $3$ 。求方案数。 显然对于 $a_3 = 3$ 定义成立。现在我们证明对 $n &gt; 3$ 该定义成立。 我们假设标号最小的为 $1$ 的点的标号为 $x$ ，则必然有 $w_{x + 2} = 1$ 或 $w_{x + 3} = 1$ 。 若 $w_{x + 2} = 1$ ，该方案等价于删去编号为 $x + 1, x + 2$ 的点（显然删去后仍然合法），有方案数 $a_{n - 2}$ 。 若 $w_{x + 3} = 1$ ，该方案等价于删去编号为 $x + 1, x + 2, x + 3$ 的点，有方案数 $a_{n - 3}$ 。 综上，有 $a_n = a_{n - 2} + a_{n - 3}$ 。 对于一个质数 $p\ge 3$ ，因为 $p$ 不含有 $1, p$ 以外的因子，所以对于任意一种合法的方案，显然将这种方案任意旋转仍然合法。所以有 $p|a_p$ 。 显然上述证明可以推广到J. Shallit, J. P. Yamron, On linear recurrences and divisibility by primes, Fib. Quart. 22 (4) (1984) 366.（shallit2.pdf）所提到的一类数列: 给定数列 $a_n = a_{n - k + 1} + a_{n - k}; a_0 = k, a_1 = a_2 = \cdots = a_{k - 2} = 0, a_{k - 1} = k - 1$ ，对于质数 $p\ge k$ ，$p|a_p$ 。 然而这种做法无法证明类似如下的题目： 给定数列 $a_n = a_{n - 1} + a_{n - 2} + (-1)^n; a_0 = 3, a_1 = 0, a_2 = 4$ ，证明如果 $p$ 为质数，有 $p|a_p$ 。 而 neumann.pdf 中有对于任意此类型数列的证明，而本人并未看懂，故弃坑。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC028E」High Elements]]></title>
    <url>%2Fblog%2FAGC028E%2F</url>
    <content type="text"><![CDATA[前面部分参考了yyb的题解。 题意简述[AGC 028E] 给你一个 $1$ 到 $n$ 的排列 $P$ 。你需要求出一个长为 $n$ 的 01 字符串 $S$ 。构造两个序列 $X, Y$ ，按标号升序考虑每个 $P_i$ ，如果 $S_i = 0$ ，则加入 $X$ 末尾，否则加入 $Y$ 末尾。若 $X$ 与 $Y$ 的 前缀最大值个数相等，则称 $S$ 是好的。求字典序最小的好的 $S$ 。$1\le n\le 2\times 10^5$ 。 主要思路显然，可以逐位确定，只需判断给定一个 $S$ 的前缀后，合法解的存在性。 先来证明一个结论：只要合法解存在，则总有一个好的 $S$ 使得 $X, Y$ 中，至多只有一个中有前缀最大值不为 $P$ 的前缀最大值。 如果 $X$ 中存在「原本不是 $P$ 中前缀最大值，但是现在数列的前缀最大值」的数，那么对于这个数， $P$ 中在它前面的最大值被分配到了 $Y$ 中。假如对于 $Y$ 也有这样的位置，将这两个位置所在的序列调换，则交换之后两个序列的前缀最大值的个数都会减少 $1$ 。所以，经过若干次交换之后，必定能够使之多只有一个序列中有前缀最大值不为 $P$ 中前缀最大值。 不妨设 $X$ 中所有前缀最大值均为 $P$ 的前缀最大值。假设前 $i-1$ 位已经构造完毕，现在考虑第 $i$ 个元素可以放在哪个序列。设目前 $X, Y$ 中的最大值分别为 $M_X, M_Y$ ，前缀最大值个数分别为 $C_X, C_Y$ 。 设 $P$ 中标号 $[i, n]$ 的前缀最大值个数为 $Q$ ，而 $Y$ 在接下来的数列中会有 $k$ 个前缀最大值为 $P$ 的前缀最大值，则 $X$ 中会有 $Q - k$ 个。再设 $Y$ 中非 $P$ 的前缀最大值的前缀最大值的个数为 $m$ 。由于 $X, Y$ 中前缀最大值的个数相等，有以下条件：$$C_X + (Q - k) = C_Y + k + m$$化简后得到：$$2k + m = C_X + Q - C_Y$$其中右边是已知的常量。 由于在 $k &gt; 0$ 或 $m &gt; 1$ 时， $2k + m$ 可以减少 $2$ ，因此若有一个方案能够满足 $2k + m \ge C_X + Q - C_Y$ 且 $2k + m \equiv C_X + Q - C_Y \pmod{\! 2}$ ，就必然存在满足 $2k + m = C_X + Q - C_Y$ 的方案。 实现时，先对 $P$ 倒序做带权的最长下降子序列，其中 $P$ 中的前缀最大值权为 $2$ ，其余元素权为 $1$ ，分别维护为奇数和偶数的最大长度。这一步可以线段树实现。正在确定 $S$ 的第 $i$ 位时，只需要查询从标号 $j$ （$j\ge i, P_j &gt; M_Y$）的元素开始，长度与当前的 $(C_X + Q - C_Y)\bmod 2$ 同余的最长上升子序列的最大长度即可。 复杂度 $O(n\log n)$ 。 参考代码咕咕咕]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>AtCoder</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC029F」Construction of a tree]]></title>
    <url>%2Fblog%2FAGC029F%2F</url>
    <content type="text"><![CDATA[题意简述[AGC 029F] 一张无向图有 $n$ 个点，还没有边。给出 $n - 1$ 个大小至少为 $2$ 的点集 $E_i$ ，问是否能从每个点集中选出两个点连边，使得图连边后为一棵树。若能，输出一种方案；若否，输出 -1 。$2\le n\le 10^5, \sum|E_i|\le 2\times 10^5$ 。 主要思路任意钦定一个点为这棵树的根，之后每条边都可看作某个点连向其父亲的边。建立一个二分图去匹配每个点和其连向父亲的边。二分图的左边为除了根以外的点，右边为 $n - 1$ 个点集。若 $u$ 不是根节点且 $u\in E_i$ ，连边 $(u, E_i)$ 。 可以看出，有解的必要条件就是这个二分图存在一组完美匹配。而另一个必要条件即二分图（左边加入根节点并用上面的方式连边后）应当联通。 任取一组该二分图的完美匹配，之后考虑从根出发 bfs。一开始，我们将根所在的所有点集的匹配点的父亲均设为根，然后再从这些点递归进行下去。如果最后有的点没被访问，说明二分图不连通，与假设矛盾。于是我们构造出了一组合法解，也说明上面的必要条件便是充要条件。 用 Dinic 等算法求二分图完美匹配，时间复杂度 $O(\sum |E_i|\sqrt{n})$ 。 参考代码咕咕咕]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>AtCoder</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF559E」Gerald and Path]]></title>
    <url>%2Fblog%2FCF559E%2F</url>
    <content type="text"><![CDATA[细节好多，写死人了。 题意简述[CF 559E] 有 $n$ 个二元组 $(a_i, l_i)$ ，对于每个二元组有两个选择：将数轴上的 $[a_i - l_i, a_i]$ 染色或将 $[a_i, a_i + l_i]$ 染色。求最大化的最终被染色总长度。输入均为整数， $1\le n\le 100, 0\le a_i\le 10^8, 1\le l_i\le 10^8$ ，保证 $a_i$ 互不相同。 主要思路先把二元组按 $a_i$ 排序，考虑动态规划，设 $f(x, s), x\in[1, 2n], s\in[0, 1]$ 表示「第 $x$ 个二元组向左（$s=1$）或右（$s=0$）贡献，最终染色总长度与 $(-\infty, a_i - s\times l_i]$ 的交的最大值」。 先考虑第 x 个二元组向左贡献。则 $[a_x - l_x, a_x]$ 这段区间内的所有二元组，也都会向左贡献，这会产生连锁反应。连锁反应过后，我们可以得到最右边的不被连锁反应影响的二元组 $y$ 。此时便转化为一个子问题，然而多了一个右端点的限制，但是总体区别不大。然后考虑这个二元组往右贡献。发现其实更简单，因为不会产生连锁反应，所以不被影响的最右的二元组即为 $x - 1$ 。所以无论左右的转移代价都是常数。 有 $O(n)$ 中状态，而每种状态的转移方式不会超过 $O(n)$ 种，转移代价为常数，总复杂度 $O(n^2)$ 。 参考代码感觉可能是我有史以来写过注释比例最高的代码…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; inline int VSC_Local()&#123; #ifdef VSC_Compile while(getchar() != '\n'); #endif return 0; &#125; #define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout) #define PBTXDY&#125;using namespace my_std;const int N = 210, inf = 1145141919;struct bulb&#123; int pos, len; inline bool operator &lt;(const bulb &amp;t)const&#123; return pos &lt; t.pos; &#125;&#125;p[N];int n, f[N], pre[N], rpre[N], md[N][N];//pre[i] : 点 i 向左这段区域内最左边的点的编号; rpre[i] : 点 i 一直向左扩展最后最左的编号（相当于 pre[i] 的迭代）//md[i][j] : [i, j] 这段区间中向左的端点最左的点int dp(int tr)&#123; if(f[tr] != -1) return f[tr]; Rint id, R; //id : 当前最右可贡献点; R : 当前最右允许贡献位置 if(tr &gt; n * 2) id = n, R = inf; else if(tr &gt; n) id = pre[tr - n] - 1, R = p[tr - n].pos - p[tr - n].len; //「当前位置」向左，显然在定义下「当前位置」无法造成贡献，故实际当前位置为 pre[tr - n] - 1 else id = tr - 1, R = p[tr].pos; //「当前位置」向右，同理「当前位置」无法造成贡献，故实际当前位置为 tr - 1 if(!id) return f[tr] = 0; f[tr] = p[id].pos - (p[rpre[id]].pos - p[rpre[id]].len) + dp(rpre[id] + n); //考虑当前最左可贡献点 (rpre[id]) 向左 chkmax(f[tr], min(p[id].len, R - p[id].pos) + dp(id)); //考虑当前最右可贡献点 (id) 向右 ROF(i, id - 1, 1)&#123; if(p[i].pos + p[i].len &lt;= p[id].pos) continue; Rint u = md[i + 1][id]; //令 i 右边的点向左贡献，能贡献到最左的 u if(p[u].pos - p[u].len &gt; p[i].pos)&#123; chkmax(f[tr], min(p[i].len, R - p[i].pos) + dp(i)); //假如点 i 右边没有点可以贡献到它的左边，直接把这个点贡献到右边 &#125; else&#123; Rint v; if(pre[u] &lt; i)&#123; v = rpre[md[pre[u]][i - 1]]; if(p[v].pos - p[v].len &gt; p[u].pos - p[u].len) v = u; //找出的点 v 比原来的点 u 还劣 &#125; else v = u; //找出在 i 向右时的最左可贡献点 v 并将其向左贡献 chkmax(f[tr], min(R, p[i].pos + p[i].len) - (p[v].pos - p[v].len) + dp(v + n)); //i 向右贡献， v 向左贡献 &#125; &#125; return f[tr];&#125;int main()&#123; n = read(); FOR(i, 1, n) p[i].pos = read(), p[i].len = read(); sort(p + 1, p + n + 1); p[0].pos = -inf, p[n + 1].pos = inf; FOR(i, 1, n)&#123; const int L = p[i].pos - p[i].len; pre[i] = i; while(p[pre[i] - 1].pos &gt;= L) --pre[i]; //求 pre[i] &#125; FOR(i, 1, n)&#123; Rint L = p[i].pos - p[i].len, x = i; FOR(j, i, n)&#123; if(chkmin(L, p[j].pos - p[j].len)) x = j; md[i][j] = x; &#125;//暴力求 md[i][j] &#125; FOR(i, 1, n)&#123; Rint x = md[pre[i]][i]; rpre[i] = (i == x) ? i : rpre[x]; //求 rpre[i] &#125; MEM(f, -1); printf("%d\n", dp(n * 2 + 1)); return VSC_Local();&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC039D」Incenters]]></title>
    <url>%2Fblog%2FAGC039D%2F</url>
    <content type="text"><![CDATA[粉兔的题解令我学到许多…… 题意简述[AGC 039D] 给定单位圆上的 $n$ 个点 $(\cos(\dfrac{2\pi T_i}{L}), \sin(\dfrac{2\pi T_i}{L}))$ 。求等概率随机三个不同的点的内心的期望位置。$3\le n\le 3000, n\le L\le 10^9, 0\le T_i &lt; T_{i + 1}\le L - 1$ 。 主要思路 如图，$\triangle{ABC}$ 的外心为 $O$ ，内心为 $I$ 。 分别延长 $AI, BI, CI$ 与 $\odot O$ 交于点 $A^\prime, B^\prime, C^\prime$ 。则易得 $A^\prime, B^\prime, C^\prime$ 分别为弧 $\overset{\LARGE{\frown}}{BC}, \overset{\LARGE{\frown}}{CA}, \overset{\LARGE{\frown}}{AB}$ （不经过 $A, B, C$ 的那一段）的中点。 根据鸡爪定理，有 $A^\prime I = A^\prime C, B^\prime I = B^\prime C$ ，所以 $IC\!\perp\!A^\prime B^\prime$ ，即 $IC^\prime\!\perp\!A^\prime B^\prime$ 。所以 $I$ 同时为 $\triangle{A^\prime B^\prime C^\prime}$ 的垂心 $H^\prime$ 。 根据欧拉线定理，有 $\overrightarrow{OH^\prime} = 3\overrightarrow{OG^\prime} = \overrightarrow{OA^\prime} + \overrightarrow{OB^\prime} + \overrightarrow{OC^\prime}$ 。 所以求 $E(I) = E(H^\prime)$ 只用求 $E(A^\prime) + E(B^\prime) + E(C^\prime)$ 即可。 这个枚举点对计算即可，复杂度 $O(n^2)$ 。 参考代码真的很短…… 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;#define reg register#define Rint register int#define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i)#define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i)typedef double DB;inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans;&#125;const DB pi = acos(-1);const int N = 3010;int n, L, t[N];DB ansx, ansy;int main()&#123; n = read(), L = read(); FOR(i, 1, n) t[i] = read(); reg DB x, y, res = n * (n - 1.0) * (n - 2.0) / 6.0; FOR(A, 1, n - 1) FOR(B, A + 1, n)&#123; x = cos(pi * (t[A] + t[B]) / L); y = sin(pi * (t[A] + t[B]) / L); ansx += x * (n - 2 * (B - A)); ansy += y * (n - 2 * (B - A)); &#125; printf("%.12lf %.12lf\n", ansx / res, ansy / res); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>AtCoder</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF639F」Bear and Chemistry]]></title>
    <url>%2Fblog%2FCF639F%2F</url>
    <content type="text"><![CDATA[题意简述[CF 639F] 给定一张无向图 $G = (V, E)$ 其中点数 $n$ ，边数 $m$ 。$q$ 次询问，第 $i$ 次询问，会把无向图加上一些新的边，并询问一个大小为 $n_i$ 的点集在加入了给定 $m_i$ 条边的情况下，是否对于这个点集中的每一对点对 $(x, y)$ 都存在一条从 $x$ 到 $y$ 再回到 $x$ 的不经过重复边的路径。询问独立且强制在线。 $1\le n, q\le 3\times 10^5, 0\le m\le 3\times 10^5, \sum{n_i}, \sum{m_i} \le 3\times 10^5$ 。 主要思路显然，问题可以转化为询问加入一些边的情况下，某个点集是否在同一边双内。 可以先将原先给的图缩成边双，然后建成边双树。对于每次询问，将加边所在的点和询问的点集作为关键点。对关键点建虚树，再对虚树的边和新加的边求边双，判断询问点集是否在同一边双即可。 时间复杂度 $O(n\log n)$ （所有数与 $n$ 同阶）。 参考代码咕咕咕]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC022F」Checkers]]></title>
    <url>%2Fblog%2FAGC022F%2F</url>
    <content type="text"><![CDATA[这题太神了，对着题解看了好久还没完全搞懂…… 题意简述[AGC 022F] 数轴上有 $n$ 个点，第 $i$ 个点的坐标是 $10^{100i}$ 。每次操作选择两个棋子 $a, b$ ，之后 $a$ 跳到关于 $b$ 的对称点上，然后删掉 $b$ 。求 $n - 1$ 次操作后，最后剩下的棋子可能的坐标个数模 $10^9 + 7$ 。$1 \le n \le 50$ 。 主要思路显然，两种方案不同仅当某个棋子对最后答案贡献的系数不同。 定义一次操作 $a \rightarrow b$ （称「$a$ 合并到 $b$」）表示选择第 $b$ 个棋子与第 $a$ 个棋子进行操作（删除 $a$ 上的棋子）。我们对于每一次操作 $a\rightarrow b$ ，将 $b$ 向 $a$ 连一条边，则会形成一棵以最后剩下的点为根的树。将深度从 $0$ 开始计，则深度为 $d$ 的点贡献的系数为 $+2^d$ 或 $-2^d$ 。 设点 $x$ 最后给答案贡献的正负性（称「点权」）为 $p_x\in \{-1, 1\}$ 。设点 $x$ 的「奇偶性」为 $q_x\in \{-1, 1\}$，有奇数个儿子的点为奇点（$q_x = -1$），有偶数个儿子的点为偶点（$q_x = 1$）。 由题面定义，若某一棋子 $y$ 合并到棋子 $x$ ，则棋子 $x$ 贡献的正负性将改变。 从上向下考虑可以得到，对于点 $rt$ 的总共 $k$ 个儿子，其中有 $\lfloor\frac{k}{2}\rfloor$ 个儿子 $ch$ 有 $p_{rt} = p_{ch}\times q_{ch}$ ，$\lceil\frac{k}{2}\rceil$ 个儿子 $ch$ 有 $-p_{rt} = p_{ch}\times q_{ch}$ 。（$q_{ch}$ 可以理解为操作完 $ch$ 子树后 $ch$ 目前的贡献正负性） 我们并不关心整棵树的形态，而只关心每一层中两种点权分别的个数。按深度从小到大挂点，设 $f_{i, j}$ 表示已经挂了 $i$ 个点，上一层有 $j$ 个奇点的答案。 钦定上一层的所有奇点的点权均为 $1$ （若原本应为 $-1$，则相当于对整棵子树的点权取反，这样的方案数与原来是相等的）。枚举这一层的点数 $x$ 与点权为 $-1$ （在钦定该层奇点点权均为 $1$ 的情况下）的点的个数 $y$ 。根据上面的结论，可以得到这一层有 $\frac{x + j}{2}$ 个点 $v$ 使得 $p_v\times q_v = -1$ 。因此，这一层的奇点数应该是 $|y - \frac{x + j}{2}|$ ，乘上组合数转移即可。 注意 $x \ge j$ （使得 $p_v\times q_v = -1$ 成立的点 $v$ 的个数比不成立的点个数多 $j$ 个）且 $x + j$ 为偶数。 时间复杂度 $O(n ^ 4)$ 。 参考代码更多细节见代码。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;#define reg register#define Rint register int#define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i)#define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i)inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans;&#125;const int mod = 1000000007;inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125;inline int _abs(const int &amp;x)&#123; return x &gt;&gt; 31 ? -x : x; &#125;#define abs(x) _abs(x)const int N = 55;int n;int f[N][N], C[N][N];int main()&#123; n = read(); FOR(i, 0, n)&#123; C[i][0] = C[i][i] = 1; FOR(j, 1, i - 1) inc(C[i][j], C[i - 1][j - 1] + C[i - 1][j]); &#125; f[1][0] = f[1][1] = n; FOR(i, 1, n - 1) FOR(j, 0, i)&#123; FOR(x, 1, n - i)&#123; if(x &lt; j || (x ^ j) &amp; 1) continue; FOR(y, 0, x)&#123; Rint tr = abs(y - ((x + j) &gt;&gt; 1)); inc(f[i + x][tr], 1ll * f[i][j] * C[n - i][x] % mod * C[x][y] % mod); &#125; &#125; &#125; printf("%d\n", f[n][0]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>AtCoder</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2019模拟赛」Yuno loves sqrt technology I]]></title>
    <url>%2Fblog%2FYnoi2019%E6%A8%A1%E6%8B%9F%E8%B5%9B-Yuno-loves-sqrt-technology-I%2F</url>
    <content type="text"><![CDATA[这题好像也是咕咕了很久？ [Luogu 5046] 题意简述强制在线的区间逆序对， $n$ 长度 $m$ 查询， $1\le n, m\le 10^5$ 。 题面还保证是排列，更好写（ 主要思路分块，块长为 $O(n)$ ，记录以下几个数组： $\langle pre_x\rangle$ ：第 $x$ 个元素到所在块的开头一段的逆序对数。 $\langle suf_x\rangle$ ：第 $x$ 个元素到所在块的结尾一段的逆序对数。 $\langle f_{t, x}\rangle$ ：前 $x$ 个元素，每个元素与第 $t$ 块形成的逆序对数总和。注意这里元素若在块中，则钦定可以形成的逆序对数为 $0$ 。 接下来看询问如何解决： 对于跨块的询问，可以拆分成三个区间（两边的散块和中间的一堆整块）。 对于两边零散块内部的贡献，处理了 $\langle pre_x \rangle, \langle suf_x \rangle$ ，可以 $O(1)$ 。 对于整块内部的贡献，对于每个块求一下与后面的整块形成的逆序对数，这可以通过查 $\langle f_{t, x}\rangle$ 得到；该块内部的贡献和零散块的贡献方法相同。所以单次复杂度 $O(\sqrt{n})$ 。 对于零散与中间的整块形成的逆序对，和整块内部贡献类似，查 $\langle f_{t, x}\rangle$ 的表即可 $O(\sqrt{n})$。 对于两个零散部分之间形成的逆序对，先对每个块内部排好序，查询时 $O(\sqrt{n})$ 将需要的区间拎出来，然后用双指针可以 $O(\sqrt{n})$ 求出逆序对数。 对于在块内的询问，可以转化为该块的两个前缀的差。当然不能直接 $pre_r - pre_{l - 1}$ ，还要用双指针把这两个段之间产生的贡献减掉。 所以单次查询复杂度就是 $O(\sqrt{n})$ ，可以通过此题。 参考代码写了个 fread 结果负优化，所以删了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; inline LL readLL()&#123; reg LL ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; inline int VSC_Local()&#123; #ifdef VSC_Compile while(getchar() != '\n'); #endif return 0; &#125; #define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout) #define PBTXDY&#125;using namespace my_std;const int N = 100010, BN = 320, blo = 317;struct BIT&#123; int b[N]; inline void upd(Rint x, Rint v)&#123; for(; x &lt; N; x += x &amp; (-x)) b[x] += v; &#125; inline int qry(Rint x)&#123; Rint res = 0; for(; x; x -= x &amp; (-x)) res += b[x]; return res; &#125;&#125;BT;int n, m, bcnt, a[N], sv[N], sd[N];//array, sorted_val, sorted_idint bl[N], Blo_L[BN], Blo_R[BN];int suf[N], pre[N], f[BN][N];int sl[BN], sr[BN], tl, tr;inline int merge()&#123; Rint res = 0, el = 1, er = 1; while(el &lt;= tl &amp;&amp; er &lt;= tr)&#123; sl[el] &lt; sr[er] ? (res += er - 1, ++ el) : (++ er); &#125; while(el &lt;= tl) res += tr, ++ el; tl = tr = 0; return res;&#125;struct myP&#123; int val, id; inline myP(int vall = 0, int idd = 0)&#123; val = vall, id = idd; &#125; inline int operator &lt; (const myP &amp;d)const&#123; return val &lt; d.val; &#125;&#125; ary[N];inline LL query(const int &amp;l, const int &amp;r)&#123; if(l &gt; r || r &gt; n || l &lt;= 0) return 0; const int lb = bl[l], rb = bl[r]; if(lb == rb)&#123; const int L = Blo_L[lb], R = Blo_R[lb]; if(l == L) return pre[r]; if(r == R) return suf[l]; FOR(i, L, R)&#123; if(l &lt;= sd[i] &amp;&amp; sd[i] &lt;= r) sr[++ tr] = sv[i]; else if(sd[i] &lt; l) sl[++ tl] = sv[i]; &#125; return pre[r] - pre[l - 1] - merge(); &#125; reg LL res = pre[r] + suf[l]; FOR(i, lb + 1, rb - 1)&#123; res += (f[i][r] - f[i][Blo_R[i]]) + pre[Blo_R[i]]; res += (f[i][Blo_R[lb]] - f[i][l - 1]); &#125; FOR(i, Blo_L[lb], Blo_R[lb])&#123; if(sd[i] &gt;= l) sl[++ tl] = sv[i]; &#125; FOR(i, Blo_L[rb], Blo_R[rb])&#123; if(sd[i] &lt;= r) sr[++ tr] = sv[i]; &#125; return res + merge();&#125;int main()&#123; n = read(), m = read(); FOR(i, 1, n) a[i] = read(), ary[i] = myP(a[i], i); bcnt = (n - 1) / blo + 1; FOR(i, 1, bcnt)&#123; Rint L = Blo_L[i] = Blo_R[i - 1] + 1, R = Blo_R[i] = i == bcnt ? n : i * blo, res = 0; sort(ary + L, ary + R + 1); FOR(j, L, R)&#123; bl[j] = i, sv[j] = ary[j].val, sd[j] = ary[j].id; BT.upd(a[j], 1); res += j - L + 1 - BT.qry(a[j]); pre[j] = res; &#125; FOR(j, L, R)&#123; suf[j] = res; BT.upd(a[j], -1); res -= BT.qry(a[j] - 1); &#125; &#125; sort(ary + 1, ary + n + 1); FOR(i, 1, bcnt)&#123; const int L = Blo_L[i], R = Blo_R[i]; Rint it = L, x, v; FOR(j, 1, n)&#123; x = ary[j].id, v = ary[j].val; while(it &lt;= R &amp;&amp; v &gt; sv[it]) ++it; if(x &lt; L) f[i][x] = it - L; else if(x &gt; R) f[i][x] = R - it + 1; &#125; FOR(j, 2, n) f[i][j] += f[i][j - 1]; &#125; // reg LL ans = 0, ll, rr; while(m --)&#123; ll = readLL(), rr = readLL(); printf("%lld\n", ans = query(int(ll ^ ans), int(rr ^ ans))); &#125; return VSC_Local();&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>Ynoi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C盘快爆了之后的瞎折腾]]></title>
    <url>%2Fblog%2FC%E7%9B%98%E5%BF%AB%E7%88%86%E4%BA%86%E4%B9%8B%E5%90%8E%E7%9A%84%E7%9E%8E%E6%8A%98%E8%85%BE%2F</url>
    <content type="text"><![CDATA[下载了某培训机构的 PC 客户端到 C 盘（本人喜欢将学习有关的软件直接扔 C 盘，其他扔 F 盘）之后发现 C 盘所剩不多，已经显示了红色条条，于是就有了这篇文章。 虽然后面做的事情和 C 盘没多大关系就是了。 删除各类流氓好像删了 360 浏览器、布丁压缩、万能看图王之类的垃圾，具体还有啥不记得了（ 我寻思平时给我弹广告的大概就是布丁和看图王这俩屑。 Bandzip被机房的某位硬核的神仙很久之前推荐的。非常好用（所以我是怎么在下了 Bandzip 之后还不把布丁删掉的）。 Honeyview这东西和上面的 Bandzip 一样，都是 Bandisoft 的作品，当然非常好用。 打开之后大概是这样一个页面：（话说为什么翻译是「蜂蜜浏览器」啊……） 然后自己改改配置什么的就行了，使用非常愉悦舒适，并且加载速度很快。 PotPlayer据说新版开始弹广告了？？总之我是没遇到过 官网直接下载即可。 配置 PotPlayer这里推荐Zune 皮肤（potplayer皮肤下载文件夹内）。 下载皮肤后得到一个 .dsf 文件，将其放入 PotPlayer 目录下的 Skins 文件夹内，然后打开 PotPlayer 。 右键，打开选项（当然也可以直接 F5）。基本\皮肤/配色 中，先「重新搜索」，然后将皮肤改为 Zune.dsf 。 然后勾选「视频下自动隐藏」，并进入 基本\皮肤覆盖/放大 ，将在画面上输出皮肤的方式改为「使用 Direct3D 9」。 这样，就得到了一个进度条自动隐藏的视频（音频？）播放器。 当然也可以改改字体，把丑陋的宋体改掉，完美！ 播放 .mkv现在打开 .mkv 文件的时候，可以播放视频却没音频。 需要安装 K-Lite Codec Pack，本人直接装了 Full 版。而且为什么还给我赠送了一个 MPC-HC ……我现在不想搞配置啊…… 然后就可以使用 PotPlayer 播放 .mkv 文件了。 各种东西还在试验中…… foobar2000下载了 dream_awake 大大的 foobox，美观高效。 大概是这样一个界面： 用于听音频绝赞，可惜歌词自动匹配上稍微跟不上。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2018」五彩斑斓的世界]]></title>
    <url>%2Fblog%2FYnoi2018-%E4%BA%94%E5%BD%A9%E6%96%91%E6%96%93%E7%9A%84%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[写了有一段时间了，忘更博客（咕咕咕）。 Idea：lxl Solution：lxl Std：lxl Data：lxlIdea：lxl Solution：lxl Std：lxl Data：lxl “突刺贯穿的第二分块” （妈呀这名字好中二啊（谁叫我要用日本轻小说中的东西命名真是作死）） 这题的来源比较神奇，大概是 csy 搬了一个全局大于 x 的减 x，查 kth 什么的题，然后我想把这个出区间上 然后直接出会得到一个 $O(n\sqrt{n}\log n)$ 的废物，当时想了很久都没想到什么trick能做值域1e9的情况（有没有人教教我啊） 然后改了改发现值域1e5是可以做的就出了出来 对这题的评价：6/11 顺便这题的 Version4 是查询区间 rank ，我记得当时我用当时感觉挺厉害的 trick 做到了和现在一样的复杂度不过感觉不 practical 所以没有挂出来 [Luogu 4117] [BZOJ 5143] [CF 896E] 所以 lxl 啥时候把加强的数据咕出来啊（ 好现在咕出来了，然后我过不去了，找时间来改（咕咕咕 题意简述一个长为 $n$ 的序列，$m$ 个操作。操作可能是以下两种： 将区间 $[l, r]$ 内所有大于 $x$ 的数减去 $x$ 。 求区间 $[l, r]$ 内 $x$ 的个数。 $1\le n, m, a_i\le 10^5$ 。 主要思路考虑分块，块长 $O(\sqrt{n})$。显然，每块的最大值总是不增的。 我们用某种数据结构来维护块内的所有数，设将某个数合并到另一个数上的时间复杂度是 $O(k)$，查询某种数的个数的时间复杂度是 $O(t)$。 假设一个块所有大于 $x$ 的数减去 $x$ ，最大值为 $v$ 。 当 $v \le 2\times x$ 时，可以把所有 $[x + 1, v]$ 内的数合并到 $[1, x]$ 上。这样，我们用 $O(v - x)\times O(k)$ 的时间让块内的最大值减小了 $v - x$ 。 当 $v &gt; 2\times x$ 时，可以把所有 $[1, x]$ 内的数合并到 $[x + 1, 2\times x]$ 上。这样，我们用 $O(x)\times O(k)$ 的时间让块内的最大值减少了 $x$ 。 散块的修改则重构整块，复杂度 $O(k\times\sqrt{n})$。 由于开始时所有块的最大值之和是 $O(n\sqrt{n})$ ，所以修改的复杂度是 $O(n\sqrt{n}\times k)$ 。查询的复杂度是 $O(n\sqrt{n}\times t)$ 。 类似未来日记，使用并查集来维护块内的所有数，则 $k = t = 1$ ，总复杂度 $O(n\sqrt{n})$ ，可以通过此题。 参考代码由于洛谷数据咕咕咕，没有卡常…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353; #ifdef using_mod inline void inc(int &amp;x, const int &amp;y)&#123; x += y; if(x &gt;= mod) x -= mod; &#125; inline void dec(int &amp;x, const int &amp;y)&#123; x -= y; if(x &lt; 0) x += mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; inline int VSC_Local()&#123; #ifdef VSC_Compile while(getchar() != '\n'); #endif return 0; &#125; #define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout) #define PBTXDY&#125;using namespace my_std;const int N = 100010, Vmax = 100000, SN = 330;int blo, Bcnt;int n, m, a[N], bl[N], fth[N], siz[N];int ary[N];int find(int x)&#123; return x == fth[x] ? x : fth[x] = find(fth[x]); &#125;struct Block&#123; int bg, ed, tag, mx;//数 y 实际值为 y - tag int pos[N]; inline void build()&#123; FOR(i, bg, ed) fth[i] = siz[i] = 0; tag = 0, mx = 0; FOR(i, bg, ed)&#123; if(!pos[a[i]]) pos[a[i]] = fth[i] = i, siz[i] = 1; else ++siz[ fth[i] = pos[a[i]] ]; chkmax(mx, a[i]); &#125; &#125; inline int query(int x)&#123; return x + tag &lt;= Vmax &amp;&amp; pos[x + tag] ? siz[pos[x + tag]] : 0; &#125; inline void update(int x)&#123; if(x &gt;= mx) return; if(2 * x &gt;= mx)&#123; FOR(val, x + 1 + tag, mx + tag) if(pos[val])&#123; Rint f = val - x; if(pos[f]) fth[pos[val]] = pos[f], siz[pos[f]] += siz[pos[val]]; else pos[f] = pos[val], a[pos[val]] -= x; pos[val] = 0; &#125; mx = x; &#125; else&#123; ROF(val, x + tag, 1 + tag) if(pos[val])&#123; Rint f = val + x; if(pos[f]) fth[pos[val]] = pos[f], siz[pos[f]] += siz[pos[val]]; else pos[f] = pos[val], a[pos[val]] += x; pos[val] = 0; &#125; tag += x, mx -= x; &#125; &#125;&#125;B[SN];inline void SBupd(int p, int l, int r, int x)&#123; Rint tag = B[p].tag, L = B[p].bg, R = B[p].ed; FOR(i, L, R) B[p].pos[a[find(i)]] = 0; FOR(i, L, R) ary[i] = a[find(i)] - tag; FOR(i, L, R) a[i] = l &lt;= i &amp;&amp; i &lt;= r &amp;&amp; ary[i] &gt; x ? ary[i] - x : ary[i]; return B[p].build();&#125;inline int SBqry(int p, int l, int r, int x)&#123; Rint res = 0, rx = x + B[p].tag; FOR(i, l, r) res += (a[find(i)] == rx); return res;&#125;inline void update(int l, int r, int x)&#123; Rint lb = bl[l], rb = bl[r]; if(lb == rb) return SBupd(lb, l, r, x); SBupd(lb, l, B[lb].ed, x), SBupd(rb, B[rb].bg, r, x); FOR(bid, lb + 1, rb - 1) B[bid].update(x); return;&#125;inline int query(int l, int r, int x)&#123; Rint lb = bl[l], rb = bl[r]; if(lb == rb) return SBqry(lb, l, r, x); Rint res = SBqry(lb, l, B[lb].ed, x) + SBqry(rb, B[rb].bg, r, x); FOR(bid, lb + 1, rb - 1) res += B[bid].query(x); return res;&#125;inline void init()&#123; Rint cb = 1; FOR(i, 1, n)&#123; a[i] = read(); bl[i] = i % blo ? cb : cb ++; &#125; Bcnt = bl[n]; FOR(bid, 1, Bcnt)&#123; B[bid].bg = (bid - 1) * blo + 1; B[bid].ed = bid == Bcnt ? n : bid * blo; B[bid].build(); &#125;&#125;int main()&#123; n = read(), m = read(), blo = ceil(sqrt(n)); init(); Rint sta, l, r, x; FOR(o, 1, m)&#123; sta = read() - 1, l = read(), r = read(), x = read(); sta ? (void)printf("%d\n", query(l, r, x)) : update(l, r, x); &#125; return VSC_Local();&#125; 参考资料据说询问区间某个数的 rank 也可做？然而我太弱了并不会 lxl 原博客]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>Ynoi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[早春杂记]]></title>
    <url>%2Fblog%2F20200119%2F</url>
    <content type="text"><![CDATA[2019，真是各种意义上的多事之年。 零早在己亥年初，就有小道消息说自招降分最多只降 20 分。当时当然是一笑了之。 突然 jyb 允许举办的全国性竞赛名单中，少了 OI 。 没能有幸去现场听 dzd 的演讲。据传大概是 dzd 非常坦诚地表示 CCF 无法实现竞赛零收费的目标。 总之，己亥年就在 OIer 们不得不与 CCF 站在同一战线上对抗 jyb 这样一种可笑又无奈的状况下开始了。 不久之后， OI 又重新回到了竞赛名单中去。然而坏头已经开了，谁敢说一切都过去了呢。 壹初中生的省队名额变为了 E 类，省选也从三天变成了两天。 CTSC 扔了 C ，改名 CTS 避开收费的限制。 大家如果细心的话，你会发现，我们今年的选拔赛 少了一个字母「C」，「C」就是 competition（大笑+鼓掌），为什么「C」没了呢？好，给你们直说吧，如果是「赛」，就不让收费（大笑+鼓掌），不让收费呢，CCF 是没钱的（大笑+鼓掌） 啊 没有一分钱的政府的拨款（大笑+鼓掌）。500 名同学呢，你就要失去机会，只有 15 名同学我们选拔 4 位，我们还是要收点费的，要不然没有钱也没法干这活，啊，当然这钱也不一定够。——dzd 在 CTS2019 闭幕式上的讲话 zxr 省选挂分凉凉没进队退役， hz 倒二进 B ， pb 没成功拿到 E 类。为 z 老师惋惜的同时，也开始思考在强省进队的难度和自己目前实力的巨大差距。 只集训不停课，勉强保持着班级平均分。 贰就这样到了暑假。NOI 最后也没有收取「报名费」，而是以「食宿费」的名义收取了费用。 集训期间打了 NOI2019 网络同步赛，正好遇见 NOI 历史上第一道交互题。 一群初三升高一的神仙去浙江金华参加 ZR 集训，顺便逃了军训。 某老人生日前夕 CCF 突然放出暂停 NOIP 的公告，掀起轩然大波，被众多 OIer 的脚本刷到了一亿阅读量。 不安之中，暑假结束，迎来了 CCF 关于举办 CSP-S/J 的报名通知。一切，似乎又好起来了？ 肆开学，迎来初三生活。 吃完隔壁物理竞赛的学军瓜，刚考完第一次月考，距离 CSP 只剩一个月多。OI 生涯第一次停课，停了一个多月课冲刺 CSP 。 然而考得并不理想，回去之后文化课又落了一大截，从平均分掉到总分 30 名左右。 文化课生活太烦了，不知不觉重心有点向竞赛偏移了。 伍大概 jyb 终于开始向 CCF 反击了罢。1 月 15 日 jyb 发布的强基计划，感觉字里行间都是在针对 OI 。 利空消息一个接一个地到来：CS 没有列入强基计划的专业中；传出「 NOI 系列赛的奖项将不能作为强基计划校评部分的参考」的传闻；WHU 给签约选手打电话，通知签约作废的消息。 省一真就明面上什么用也没有了，据传 NOI 至少要 Ag 才有优惠可以拿。 kkksc03 在知乎发表的回答和 StudyingFather 的分析，使这件事看起来好像又没那么坏。 智子一如既往地开始在洛谷跳脚，大肆发表过激（？）言论（虽然他怼的人绝大多数比他的言论更草）。犇犇充斥着以其为首的激愤情绪与对 jyb 及此计划的强烈批判，洛谷管理员临时关闭犇犇。 而智子也在 18 日挨了洛弹。 StudyingFather 的灯下随笔（1）（2）（3）反复看了几遍，有些迷茫。 唯一能做的，也许是趁寒假补补文化课，尽量恢复到班级水平平均值罢。 毕竟 jyb 怎么搞我们，现在也还没能下定论。形势虽然偏向坏的方向，但总归不稳定，谁知道最后又会变成怎么样？ 陆1 月 21 日，CCF 发布了恢复 NOIP 竞赛的公告，去年拿的没什么用的一等证书或成为绝版。脚本哥们好像都回家过年了，如今一周后才刚破一千万阅读量。 WC 延期，某咕了一年的省内比赛延期……情况越发复杂多变。 反正寒假也很长，慢慢补文化课吧。 终如果现高三高二学生的一等约没法兑现，我想他们的人生轨迹也会因 jyb 被改变吧。 倘若这些学生们真的成为这场改革的「牺牲者」，我们除了替他们惋惜以外，又能够做什么呢。 倘若我们成为这场改革的「牺牲者」，我们除了替自己惋惜以外，又能够做什么呢。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>计划与总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC022E」Median Replace]]></title>
    <url>%2Fblog%2FAGC022E%2F</url>
    <content type="text"><![CDATA[这是毕克好久之前讲过的题……当时没写，现在再看到，回忆起做法就写了一发。 题意简述[AGC 022E] 定义长度为 $n$（奇数）的 01 字符串是好的，当且仅当可以通过进行 $\frac{n - 1}{2}$ 次下面的变换，使得最后字符串变为 1 。 变换是选择一个长度为 $3$ 的字串，将其改为这 $3$ 个字符的众数（即每次操作会减少 $2$ 个字符）。 先有一个字符串 $S$ ，保证长度为奇数，只含有 0, 1, ? 。分别将每个 ? 改为 0 与 1 中的一种，问有多少种方案，使得字符串是好的。 $1\le |S|\le 3\times 10^5$ 。 主要思路可以发现，如果在字符串后面加入一个字符，某些操作是不劣的。比如 000 肯定先变成 0 ，011 或 101 肯定先变成 1 。 然后我们可以构造出如下的自动机。 至于为啥 11 只加一个字符就可以再次变为 11 ，你可以理解为 11 后面无论加入什么，最后总是好的。 然后就可以倒着 dp 了。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 1000000007; #ifdef using_mod inline void inc(int &amp;x, const int &amp;y)&#123; x += y; if(x &gt;= mod) x -= mod; &#125; inline void dec(int &amp;x, const int &amp;y)&#123; x -= y; if(x &lt; 0) x += mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; inline int VSC_Local()&#123; #ifdef VSC_Compile while(getchar() != '\n'); #endif return 0; &#125; #define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout) #define PBTXDY&#125;using namespace my_std;/* * null + '0' -&gt; "0", null + '1' -&gt; "1" * "0" + '0' -&gt; "00", "0" + '1' -&gt; "01" * "1" + '0' -&gt; "10", "1" + '1' -&gt; "11" * "00" + '0' -&gt; "0", "00" + '1' -&gt; "0" * "01" + '0' -&gt; "0", "01" + '1' -&gt; "1" * "10" + '0' -&gt; "100", "10" + '1' -&gt; "1" * "11" + '0' -&gt; "11", "11" + '1' -&gt; "11" * "100" + '0' -&gt; "10", "100" + '1' -&gt; "10"*/const int N = 300010, trans[8][2] = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;, &#123;1, 1&#125;, &#123;1, 2&#125;, &#123;7, 2&#125;, &#123;6, 6&#125;, &#123;5, 5&#125;&#125;;int n, dp[N][8];char sc[N];int main()&#123; scanf("%s", sc); n = strlen(sc); dp[n][2] = dp[n][6] = 1; ROF(i, n - 1, 0)&#123; FOR(t, 0, 7)&#123; if(sc[i] != '0') inc(dp[i][t], dp[i + 1][trans[t][1]]); if(sc[i] != '1') inc(dp[i][t], dp[i + 1][trans[t][0]]); &#125; &#125; printf("%d\n", dp[0][0]); return VSC_Local();&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>AtCoder</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC037E」Reversing and Concatenating]]></title>
    <url>%2Fblog%2FAGC037E%2F</url>
    <content type="text"><![CDATA[题意简述[AGC 037E] 给你一个长为 $n$ 的字符串 $S$ ，你可以进行下面的操作 $k$ 次： 将 $S$ 翻转后接在 $S$ 后面得到一个长为 $2n$ 的字符串 $U$，再将 $S$ 改为 $U$ 的一个长为 $n$ 的子串。 求最后所得字典序最小的字符串。 $1\le n\le 5000, 1\le k\le 10^9$ 。 主要思路设 $S$ 中最小的字符为 $c$ ， $U$ 中最长的连续 $c$ 的个数为 $mxl$ 。 若 $2^k\times mxl \ge n$ ，则我们可以每次将最长连续 $c$ 的结尾作为选择的新 $S$ 的结尾，这样最后字符串将变为 $n$ 个 $c$ 。 否则，最后字符串必定开头有 $2^k\times mxl$ 个 $c$ 。而后面的 $n - 2^k\times mxl$ 个字符为第一次选择的新 $S$ 的翻转后的 $[mxl + 1, mxl + n - 2^k\times mxl]$ 字串。 注意到 $n\le 5000$ ，暴力比对取字典序最小即可。 若 $n$ 较大，也可使用各种后缀排序的算法 $O(n\log n)$ 或 $O(n)$ 解决。 果然这场的难度是乱序排的……另外这题在kenkoooo上的难度是 2845 ，在 AGC 的 E 来说是评分很低的。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353; #ifdef using_mod inline void inc(int &amp;x, const int &amp;y)&#123; x += y; if(x &gt;= mod) x -= mod; &#125; inline void dec(int &amp;x, const int &amp;y)&#123; x -= y; if(x &lt; 0) x += mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; inline int VSC_Local()&#123; #ifdef VSC_Compile while(getchar() != '\n'); #endif return 0; &#125; #define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout) #define PBTXDY&#125;using namespace my_std;const int N = 20010;int n, K, usd[N];char sc[N], ans[N];int main()&#123; n = read(), K = read() - 1; scanf("%s", sc + 1); reg char mn = 'z'; Rint len = 0, mxl = 0; FOR(i, 1, n) sc[2 * n + 1 - i] = sc[i], chkmin(mn, sc[i]); ROF(i, n * 2, n + 1)&#123; Rint l = i; while(sc[l] == mn &amp;&amp; i - l &lt; n) --l; chkmax(mxl, i - l); i = l; &#125; if(K &gt;= 13 || n &lt;= (1 &lt;&lt; K) * mxl)&#123; FOR(i, 1, n) putchar(mn); return VSC_Local(); &#125; ROF(i, n * 2, n + 1)&#123; Rint l = i; while(sc[l] == mn &amp;&amp; i - l &lt; n) --l; if(i - l == mxl) usd[i] = 1; &#125; len = n - (1 &lt;&lt; K) * mxl; FOR(i, 1, n) ans[i] = 'z'; function&lt;void(int)&gt; check = [&amp;](int x)&#123; FOR(i, 1, len)&#123; if(sc[x - i] &gt; ans[i]) return; if(sc[x - i] &lt; ans[i])&#123; FOR(j, 1, len) ans[j] = sc[x - j]; return; &#125; &#125; &#125;; FOR(i, n + 1, n * 2) if(usd[i]) check(i - mxl + 1); FOR(i, len + 1, n) putchar(mn); FOR(i, 1, len) putchar(ans[i]); return VSC_Local();&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>猜结论</tag>
        <tag>AtCoder</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC011D」Half Reflector]]></title>
    <url>%2Fblog%2FAGC011D%2F</url>
    <content type="text"><![CDATA[题意简述[AGC 011D] 给你一个长为 $n$ 的 AB 字符串。假设一个球从某一个方向（左或右）到达了一个 A ，该位置将变为 B 且该球会反弹；到达了一个 B ，该位置将变为 A 且该球会穿过该位置。 现在从字符串的最左边扔进去 $k$ 个球，每个球都在上一个球已经弹出字符串之后再放入（可以证明，任何字符串都不能把球永远留在字符串中）。 求最后的字符串。 $1\le n\le 200000, 1\le k\le 10^9$ 。 主要思路$k$ 这么大，说明最后的复杂度和 $k$ 没大关系。 发现如果扔进去球的时候第一个位置是 A ，则球从左边弹出，只改变第一个位置的值；否则，必然从右边弹出。 考虑球从某个位置的右边弹出时，原先在的位置和弹到的位置的值（注意到弹出时该位置必定为 A）。 AA 变为 BA ； AB 变为 AA ； 发现第二个位置的值取反即为最后第一个位置的值。 加以分析，即可得若球从字符串右边弹出，新字符串为原字符串左移一位每位取反后，最后一位补上 A 。 这样就得到了一个 $O(n + k)$ 的做法。 由于球从字符串右边弹出后，字符串最后一位必为 A ，所以球从字符串右边弹出若干次后，字符串有后缀 ...ABABA 。扔入足够多的球后，长度为偶数的字符串将变为 BABA...BABA 并保持稳定；长度为奇数的字符串将在 ABAB...BABA 与 BBAB...BABA 中反复。 显然，扔入两个球后至少有一个是从右边弹出的，故若 $k &gt; 2n$ ，可以直接利用上面的结论得到答案。 这样就得到了 $O(n)$ 做法。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;//AGC011Dnamespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353; #ifdef using_mod inline void inc(int &amp;x, const int &amp;y)&#123; x += y; if(x &gt;= mod) x -= mod; &#125; inline void dec(int &amp;x, const int &amp;y)&#123; x -= y; if(x &lt; 0) x += mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; inline int VSC_Local()&#123; #ifdef VSC_Compile while(getchar() != '\n'); while(getchar() != '\n'); #endif return 0; &#125; #define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout) #define PBTXDY&#125;using namespace my_std;const int N = 200010;int n, m, a[N &lt;&lt; 2], tag, fst;char S[N];int main()&#123; n = read(), m = read(); scanf("%s", S + 1); FOR(i, 1, n) a[i] = S[i] == 'A'; fst = 1; function&lt;void(void)&gt; update = [&amp;]()&#123; if(a[fst] ^ tag)&#123; a[fst] ^= 1; return; &#125; tag ^= 1; a[fst + n] = tag ^ 1; fst++; &#125;; FOR(i, 1, min(m, n * 3)) update(); if(m &gt; n * 3)&#123; if(n &amp; 1)&#123; Rint t = m - n * 3; if(t &amp; 1) update(); FOR(i, fst, fst + n - 1) putchar('B' - (tag ^ a[i])); &#125; else&#123; FOR(i, 1, n) putchar('A' + (i &amp; 1)); &#125; &#125; else&#123; FOR(i, fst, fst + n - 1) putchar('B' - (tag ^ a[i])); &#125; return VSC_Local();&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>猜结论</tag>
        <tag>找规律</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成函数初步学习笔记]]></title>
    <url>%2Fblog%2F%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[开始学生成函数了。 普通型生成函数生成函数是形式幂级数，不必顾虑收敛性等问题。对于一个数列 ${f_n}$，定义其普通型生成函数（Ordinary Generating Function，简称 OGF ）为 $F(x)=\sum\limits_{n\ge 0}{f_n x^n}$。$f_n$ 是 $x^n$ 在 $F(x)$ 中的系数（Coefficient），也写作 $f_n = [x^n]F(x)$。 一些例子$$\begin{aligned} \sum\limits_{n\ge 0}[n = m]x^n &amp;= x^m\\ \sum\limits_{n\ge 0}x^n &amp;= \dfrac{1}{1 - x}\end{aligned}$$ 由上面的那个式子可以得到以下四条： $$\begin{aligned} \sum\limits_{n\ge m}x^n &amp;= \dfrac{x^m}{1 - x}\\ \sum\limits_{n\ge 0}x^{nk} &amp;= \dfrac{1}{1 - x^k}\\ \sum\limits_{n\ge 0}c^n x^n &amp;= \dfrac{1}{1 - cx}\\ \sum\limits_{n\ge 0}\binom{n + k - 1}{n}x^n &amp;= \dfrac{1}{(1 - x)^k}\end{aligned}$$ 利用泰勒展开可以得到以下三条： $$\begin{aligned} \sum\limits_{n\ge 0}\dfrac{x^n}{n!}&amp;=e^x\\ \sum\limits_{n &gt; 0}\dfrac{x^n}{n} &amp;= \ln \dfrac{1}{1 - x}\\ \sum\limits_{n &gt; 0}\dfrac{(-1)^{n - 1}x^n}{n} &amp;= \ln (1 + x)\end{aligned}$$ 运算设 $F(x),G(x)$ 为数列 ${f_n}, {g_n}$ 的 OGF。 $$\begin{aligned} cF(x) &amp;= \sum\limits_{n\ge 0}cf_nx^n\\ x^mF(x) &amp;= \sum\limits_{n\ge m}f_{n - m}x^n\\ F(cx) &amp;= \sum\limits_{n\ge 0}c^nf_{n}x^n\\ \frac{\mathrm{d}}{\mathrm{d}x}F(x) &amp;= \sum\limits_{n\ge 0}(n + 1)f_{n + 1}x^n\\ \int_{0}^{x} F(x)\mathrm{d}x &amp;= \sum\limits_{n &gt; 0}\frac{f_{n - 1}}{n} x^n\\ F(x)G(x) &amp;= \sum\limits_{n\ge 0}(\sum\limits_{i=0}^{n}f_i g_{n - i})x^n\\ F(G(x)) &amp;= \sum\limits_{n\ge 0}f_n(G(x))^n\end{aligned}$$ 简单例题Example 1求数列 $a_n = \begin{cases} 1 &amp;,n = 0\\ ta_{n - 1} + w^{n - 1} &amp;,n &gt; 0\end{cases}$ 的通项公式。其中 $t, w &gt; 0$。 设 ${a_n}$ 的普通型生成函数为 $A$ ，则有 $A = tAx + \sum\limits_{n = 0}w^{n}x^{n} = tAx + \dfrac{1}{1 - wx}$。 则解出 $A = \dfrac{1}{(1 - tx)(1 - wx)}$。 所以 $a_n = \displaystyle\sum\limits_{i=0}^{n} t^i w^{n - i} = \dfrac{t^{n + 1} - w^{n + 1}}{t - w}$。 Example 2证明 $4^n = \sum\limits_{i=0}^{n}\binom{2i}{i}\binom{2n-2i}{2i}$。 设 $F = \sum\limits_{i\ge 0}\binom{2i}{i}x^i$，则需证 $F^2 = (1-4x)^{-1}$。 $(1 - 4x)^{-\frac{1}{2}} = \sum\limits_{n\ge 0}(-4)^n\dbinom{-\frac{1}{2}}{n}x^n = F$，证毕。 $$\begin{aligned} \dbinom{-\frac{1}{2}}{n} &amp;= \dfrac{(-\frac{1}{2})^{\underline{n}}}{n!}\\ &amp;= \dfrac{\prod\limits_{i=1}^{n}(-\frac{2i - 1}{2})}{n!}\\ &amp;= \dfrac{(-1)^n\prod\limits_{i=1}^{n}(2i - 1)}{2^n n!}\\ &amp;= \dfrac{(-1)^n(2n)!}{4^n (n!)^2}\\ &amp;= \dfrac{(-1)^n}{4^n}\binom{2n}{n}\end{aligned}$$ Example 3Catalan 数列：$f_n = [n = 0] + \sum\limits_{i = 0}^{n - 1}f_i f_{n - i - 1}$，求其通项公式。 易得其生成函数 $F(x)$ 有 $F(x) = 1 + x(F(x))^2$。 将 $F(x)$ 看作元而 $x$ 看作参，则 $F(x) = \dfrac{1\pm \sqrt{1 - 4x}}{2x}$。 由于 $f_0 = 1$，即 $\lim_{x\to 0}F(x) = 1$，故取 $F(x) = \dfrac{1 - \sqrt{1 - 4x}}{2x}$。 类似 Example 2 来化简它： $\sqrt{1 - 4x} = \sum\limits_{n\ge 0}(-4)^n\dbinom{\frac{1}{2}}{n}x^n = -2\sum\limits_{n\ge 0}\dfrac{(2n - 2)!}{n!(n - 1)!}x^n$ 故 $F(x) = \sum\limits_{n\ge 0}\dfrac{(2n)!}{n!(n + 1)!}x^n$，即 $f_n = \dfrac{(2n)!}{n!(n + 1)!}$。 指数型生成函数指数型生成函数与用于处理组合问题的普通型生成函数相对，用于处理排列问题。对于一个数列 ${f_n}$，定义其指数型生成函数（Exponential Generating Function，简称 EGF ）为 $F(x)=\sum\limits_{n\ge 0}{f_n \dfrac{x^n}{n!}}$。 运算设 $F(x),G(x)$ 为数列 ${f_n}, {g_n}$ 的 EGF。 大部分与 OGF 相同。 $$\begin{aligned} F(x)G(x) &amp;= \sum\limits_{n\ge 0}(\sum\limits_{i=0}^n \binom{n}{i}f_i g_{n - i})\dfrac{x^n}{n!}\\ \frac{\mathrm{d}}{\mathrm{d}x}F(x) &amp;= \sum\limits_{n\ge 0}f_{n + 1}\dfrac{x^n}{n!}\\ \int_{0}^{x} F(x)\mathrm{d}x &amp;= \sum\limits_{n &gt; 0}f_{n - 1}\dfrac{x^n}{n!}\\ xF(x) &amp;= \sum\limits_{n &gt; 0} \dfrac{f_{n - 1}}{n}\cdot\dfrac{x^n}{n!}\\ \frac{1}{x}(F(x) - f_0) &amp;= \sum\limits_{n\ge 0} f_{n + 1}\dfrac{x^n}{n!}\end{aligned}$$ 一些例子$$\begin{aligned} \sum\limits_{n\ge 0}\dfrac{x^n}{n!} &amp;= e^x\\ \sum\limits_{n\ge 0}\dfrac{c^n x^n}{n!} &amp;= e^{cx}\\ \sum\limits_{n\ge 0}\dfrac{n^\underline{k} x^n}{n!} &amp;= x^k e^x\\ \sum\limits_{n &gt; 0}(n - 1)!\dfrac{x^n}{n!} &amp;= \ln\dfrac{1}{1 - x}\end{aligned}$$ 简单应用Example 1 ——贝尔数贝尔数 $w_n$ 为将 $n$ 个不同元素划分为任意多个无序非空子集的方案数。 考虑递推，枚举1所在的子集大小 $i$，则应从剩下 $n - 1$ 个中选择 $i - 1$ 个与1放在同一集合，而其他随便放。即 $w_n = [n = 0] + \sum\limits_{i = 1}^{n}\binom{n - 1}{i - 1}w_{n - i}$。 设其 EGF 为 $W(x)$，则：$$\begin{aligned} W(x) &amp;= 1 + \displaystyle\int W(x) e^x \mathrm{d}x\\ \dfrac{\mathrm{d}W(x)}{\mathrm{d}x} &amp;= W(x)e^x\\ \dfrac{\mathrm{d}W(x)}{W(x)} &amp;= e^x\mathrm{d}x\\ \ln W(x) &amp;z= e^x + C\end{aligned}$$ 代入 $W(0) = w_0 = 1$，可得 $C = -1$。 故 $W(x) = \exp(e^x - 1)$。这个式子的组合解释？ 考虑到 $F = e^x - 1$ 就是「非空子集」的 EGF（对于任意 $n &gt; 0$ 均有一种方法把 $n$ 个元素放进一个集合里），那么套一层exp即 $\exp F = \displaystyle\sum\limits_{k\ge 0}\dfrac{F^k}{k!}$。 $k$ 可以看作非空子集的个数，且非空子集无序，故除以 $k!$。 类似地，可以得到 $n$ 个不同元素划分为任意多个无序非空集合，大小为 $k$ 的集合价值为 $a_k$，一种方案的价值为所有划分成的非空集合的价值的积，求所有方案的价值和，答案的 EGF 即为 $\exp(A(x))$。 Example 2 ——简单无向连通图求 $f_n$ 表示 $n$ 个点的简单无向连通图的个数（点带标号）。 先设 $g_n$ 表示 $n$ 个点的简单无向图的个数，即 $g_n = 2^{\binom{n}{2}}$。 那么 $n$ 个点的简单无向连通图，可以用 $g_n$ 减去不连通图的个数。不连通，则枚举1号点所在连通块大小 $k$。即：$$f_n = g_n - \sum\limits_{i = 1}^{n - 1}\binom{n - 1}{i - 1}f_i g_{n - i}$$移项，就得到 Example 1 中我们见过的式子：$$g_n = \sum\limits_{i = 1}^{n}\binom{n - 1}{i - 1}f_i g_{n - i}$$ 设 $F(x), G(x)$ 分别为 ${f_n},{g_n}$ 的 EGF，则 $G(x) = \exp F(x)$，即 $F(x) = \ln G(x)$。 于是我们得到ln的用处：如果我们知道了一个生成函数exp之后是什么，就可以把它ln回来。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>生成函数</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式版本控制系统Git学习笔记]]></title>
    <url>%2Fblog%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9FGit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Git 是目前世界上最先进的分布式版本控制系统。 安装Windows 下直接官网下，Linux 下可以直接 sudo apt-get install git 。 使用下面的命令来设置本地的账户名字与邮箱地址。 12git config --global user.name "Your Name"git config --global user.email "email@example.com" Windows 下出现「Git Credential Manager for Windows」对话框，关闭需要git config --edit --system，然后删除helper = manager行。但据说根据环境及安装时行为不同，有不同关闭方案。 每次远程操作都要输密码很烦？某次输入后git config --global credential.helper store即可。 创建版本库版本库，就是仓库，英文即为 repository 。 选择一个根目录。 如果你使用 Windows 系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。（啊，当然这提醒说不定已经过时了） 第二步，通过git init命令把这个目录变成 Git 可以管理的仓库。 然后根目录下就会多出一个.git的隐藏目录，如果你没有看到.git目录，用ls -ah命令就可以看见。 把文件添加到版本库 首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如 TXT 文件，网页，所有的程序代码等等，Git 也不例外。版本控制系统可以告诉你每次的改动，比如在第 5 行加了一个单词 “Linux” ，在第 8 行删了一个单词 “Windows” 。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从 100KB 改成了 120KB ，但到底改了啥，版本控制系统不知道，也没法知道。不幸的是， Microsoft 的 Word 格式是二进制格式，因此，版本控制系统是没法跟踪 Word 文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。因为文本是有编码的，比如中文有常用的 GBK 编码，日文有 Shift_JIS 编码，如果没有历史遗留问题，强烈建议使用标准的 UTF-8 编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 使用 Windows 要特别注意：千万不要使用 Windows 自带的记事本编辑任何文本文件。原因是 Microsoft 开发记事本的团队使用了一个非常弱智的行为来保存 UTF-8 编码的文件，他们自作聪明地在每个文件开头添加了 0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个 “?” ，明明正确的程序一编译就报语法错误，等等。这些都是由记事本的弱智行为带来的。 言归正传，把一个文件添加到 Git 仓库需要两步。 把文件添加或更新到仓库： 12git add &lt;file&gt;git add &lt;file1&gt; &lt;file2&gt; ... 执行上面的命令，没有任何显示，这就对了，Unix 的哲学是“没有消息就是好消息”，说明添加或修改成功。 把文件提交(commit)到仓库： 1git commit -m "massage" -m 后面输入的字符串是对本次提交的说明，可以输入任意内容，当然最好是有意义的。 掌握工作区状态git status命令可以让我们时刻掌握工作区当前的状态。 就比如说原博客给的一个例子： 123456789$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.txtno changes added to commit (use "git add" and/or "git commit -a") 上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 那假如我想要知道readme.txt哪里被修改了怎么办？这时就需要使用git diff命令来查看。 例如原博客给的一个例子： 123456789$ git diff readme.txt diff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software. git diff顾名思义就是查看 difference ，显示的格式正是 Unix 通用的 diff 格式。可以从上面的命令输出看到，我们在第一行添加了一个 distributed 单词。 也可以git diff &lt;file&gt;来查看单个文件的修改。 查看历史提交记录git log指令可以显示从最近到最远的提交日志。 会显示每次提交的 commit id, Author, Date 与我们在提交时写的&lt;message&gt;。 如果嫌输出信息太多，看得眼花缭乱的，可以使用git log --pretty=oneline，这样只会显示 commit id 和&lt;message&gt;。 使用git reflog可以显示每一次命令，包括提交、回退版本等。 版本回退首先， Git 必须知道当前版本是哪个版本，在 Git 中，用 HEAD 表示当前版本，也就是最新的提交，上一个版本就是 HEAD^ ，上上一个版本就是 HEAD^^ ，当然往上 100 个版本写 100 个 ^ 比较容易数不过来，所以写成 HEAD~100 。 就比如说git reset --hard &quot;HEAD^&quot;就回退到上一个版本。 所以说回退版本的命令就是： 1git reset --hard &lt;commit_id&gt; 这样就回退到你需要的版本了。 但是如果要恢复新版本怎么办？ 通过git reflog查看新版本对应的 commit id ，也使用上述指令即可。 Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的HEAD指针，当你回退版本的时候， Git 仅仅是把HEAD修改，然后顺便把工作区的文件更新。所以不仅可以回到历史版本也可以返回新版本。 工作区与暂存区的概念工作区即直接能看到的目录。 版本库打开显示隐藏目录，会发现.git目录。这个不算工作区，而是 Git 的版本库。 Git 的版本库中存了很多东西，比如称为 stage 或 index 的暂存区，及每个分支，指针HEAD。 回忆我们怎么把文件往 Git 版本库里添加： git add，把文件加入暂存区。 git commit，提交更改，即把把暂存区的所有内容提交到当前分支。 所以你在git status后看到的三类文件大概就是： Untracked files，从来未被添加过的文件。 Changes not staged for commit，在工作区修改了但没有将修改加入暂存区的文件。 Changes to be commited，加入了暂存区，还没有提交到分支的文件。 当我们加入某个文件到暂存区，之后再将其修改，未重新加入缓存区后提交到分支，则分支中的版本为先前暂存区中的版本。 可以使用git diff HEAD -- &lt;file&gt;验证。 参考文献Pro Git 廖雪峰的Git教程]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1266F」Almost Same Distance]]></title>
    <url>%2Fblog%2FCF1266F%2F</url>
    <content type="text"><![CDATA[nantf 由于生病窝在家里打 Global Round 6 然后 rating 超过 p_b_p_b 了…… 然后他场上做了 A - E。 题意简述[CF 1266F] 给定一棵树大小为 $n$ 。定义一个点集 $S$ 是 $k$ 均匀的，当且仅当对于任意 $u,v\in S, u\ne v$ ，有 $\operatorname{dist}(u, v) = k$ 或 $\operatorname{dist}(u, v) = k + 1$ ，其中 $\operatorname{dist}(u, v)$ 表示 $u$ 与 $v$ 在树上的距离，即它们的简单路径上的边数。 现在希望你对于 $1\le k\le n$ ，求出 $k$ 均匀点集点数的最大值。$2 \le n \le 5\times 10^5$ 。 主要思路题解讲得很迷，然后看了300iq的代码才明白的。 设 $ans[k]$ 为 $k$ 均匀点集点数的最大值。 显然我们可以 dfs 求出最长链的长度 $mxl$ ， $k &gt; mxl$ 则 $ans[k] = 1$ ， $k \le mxl$ 则 $ans[k] \ge 2$ 。 称一棵有根树的最深深度为根节点到所有叶子节点的距离最大值。 对于 $k = 2l + 1$ ($l &gt; 1$) ，最大 $k$ 均匀集必定以一个点 $r$ 为“中心”（该点不在均匀集中），而所有均匀集中的点 $x$ 距离 $r$ 为 $l + 1$ 或 $l$ ，且距离为 $l$ 的点的数量不超过 $1$ 个。 对于 $k = 2l$ ($l &gt; 1$) ，也类似，不过较为复杂。可能是以一个点 $r$ 为“中心”，此时所有均匀集中的点 $x$ 距离 $r$ 为 $l$ ；也可能是以一条边 $(s, t)$ 为“中心”，此时所有均匀集中的点 $x$ 有 $\min(\operatorname{dist}(x, s), \operatorname{dist}(x, t)) = l$ 。 由上，可得 $ans[k] \ge ans[k + 2]$ 。 对于 $k$ 为奇数，或 $k$ 为偶数的第一种情况，我们可以对每个点 $u$ ，求出若这棵树以这个点为根，它每个儿子的子树最深深度，并降序排序存入数组 $ret$ 中。 这样，我们就可以 $O(n\log_2 n)$ 地获得上述情况的答案。 这部分非常好写，但是对于 $k$ 为偶数且以一条边为“中心”的情况无法处理。 对于这种情况，我们对每个点 $u$ ，枚举其儿子 $v$ 。然后对于 $v$ 也求出它每个儿子的子树最深深度（不包含 $u$ ），并降序存入数组 $tmp$ 中。 然后对于每个 $ret[i], tmp[i]$ ，用类似上述的方法来更新。 这里每个节点会被访问两次，所以总的时间复杂度还是 $O(n\log_2 n)$ 。 参考代码上面的东西都可以两次 dfs 搞定。 写得丑了点不要介意。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 500010; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; inline int VSC_Local()&#123; #ifdef VSC_Compile while(getchar() != '\n'); #endif return 0; &#125; #define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout) #define PBTXDY&#125;using namespace my_std; #define swap(a,b) (a ^= b ^= a ^= b) int n, dep[N], mxl, ans[N &lt;&lt; 2], anss[N &lt;&lt; 2];vector&lt;int&gt; g[N]; struct BIT&#123; int a[N]; inline void update(int x, int v)&#123; for(; x &gt;= 0; x = (x &amp; (x + 1)) - 1) a[x] += v; &#125; inline int query(int x)&#123; Rint res = 0; for(; x &lt;= n; x = (x | (x + 1))) res += a[x]; return res; &#125;&#125;BT; void dfs(int u, int fth)&#123; dep[u] = 0; for(int v : g[u])&#123; if(v != fth)&#123; dfs(v, u); chkmax(dep[u], dep[v] + 1); &#125; &#125; return;&#125; void solve(int u, int fth, int upx)&#123; vector&lt;int&gt; ret&#123;upx, 0&#125;; for(int v : g[u])&#123; if(v != fth) ret.push_back(dep[v] + 1); &#125; sort(ret.rbegin(), ret.rend()); Rint fr = ret[0], sc = ret[1], siz = (int)ret.size(); chkmax(mxl, fr + sc); FOR(i, 1, siz - 1)&#123; chkmax(ans[2 * ret[i] + (ret[i] &lt; ret[i - 1])], i + 1); &#125; for(int v : g[u])&#123; if(v == fth) continue; Rint tmp = (dep[v] + 1 == fr ? sc : fr); solve(v, u, tmp + 1); &#125; vector&lt;int&gt; vec(siz); for(int v : g[u])&#123; if(v == fth) continue; vector&lt;int&gt; tmp; for(int x : g[v])&#123; if(x != u) tmp.push_back(dep[x] + 1); &#125; sort(tmp.rbegin(), tmp.rend()); FOR(i, 0, (int)tmp.size() - 1)&#123; Rint l = 0, r = siz, mid; while(l &lt; r - 1)&#123; mid = (l + r) &gt;&gt; 1; if(ret[mid] &lt;= tmp[i]) r = mid; else l = mid; &#125; if(r != siz)&#123; chkmax(vec[r], i + 1); chkmax(anss[2 * tmp[i]], i + l + 1); &#125; &#125; &#125; FOR(i, 1, siz - 1)&#123; chkmax(vec[i], vec[i - 1]); &#125; FOR(i, 0, siz - 1)&#123; chkmax(anss[2 * ret[i]], i + vec[i]); &#125; return;&#125; int main()&#123; n = read(); Rint u, v; FOR(i, 1, n - 1)&#123; u = read() - 1, v = read() - 1; g[u].push_back(v), g[v].push_back(u); &#125; dfs(0, -1); solve(0, -1, 0); ROF(i, n - 1, 1) chkmax(ans[i], ans[i + 1]); ROF(i, n - 2, 1) chkmax(anss[i], anss[i + 2]); FOR(i, 1, n)&#123; chkmax(ans[i], anss[i]); chkmax(ans[i], 1 + (i &lt;= mxl)); &#125; FOR(i, 1, n) printf("%d ", ans[i]); puts(""); return VSC_Local();&#125; dfs(v, u); chkmax(dep[u], dep[v] + 1); &#125; &#125; return;&#125;void solve(int u, int fth, int upx)&#123; vector&lt;int&gt; ret&#123;upx, 0&#125;; for(int v : g[u])&#123; if(v != fth) ret.push_back(dep[v] + 1); &#125; sort(ret.rbegin(), ret.rend()); Rint fr = ret[0], sc = ret[1], siz = (int)ret.size(); chkmax(mxl, fr + sc); FOR(i, 1, siz - 1)&#123; chkmax(ans[2 * ret[i] + (ret[i] &lt; ret[i - 1])], i + 1); &#125; for(int v : g[u])&#123; if(v == fth) continue; Rint tmp = (dep[v] + 1 == fr ? sc : fr); solve(v, u, tmp + 1); &#125; for(int x : ret) BT.update(x, 1); vector&lt;int&gt; vec(siz); for(int v : g[u])&#123; if(v == fth) continue; BT.update(dep[v] + 1, -1); vector&lt;int&gt; tmp; for(int x : g[v])&#123; if(x != u) tmp.push_back(dep[x] + 1); &#125; sort(tmp.rbegin(), tmp.rend()); FOR(i, 0, (int)tmp.size() - 1)&#123; Rint l = 0, r = siz, mid; while(l &lt; r - 1)&#123; mid = (l + r) &gt;&gt; 1; if(ret[mid] &lt;= tmp[i]) r = mid; else l = mid; &#125; if(r != siz)&#123; chkmax(vec[r], i + 1); &#125; &#125; FOR(i, 0, (int)tmp.size() - 1)&#123; chkmax(anss[2 * tmp[i]], i + 1 + BT.query(tmp[i])); &#125; BT.update(dep[v] + 1, 1); &#125; FOR(i, 1, siz - 1)&#123; chkmax(vec[i], vec[i - 1]); &#125; FOR(i, 0, siz - 1)&#123; chkmax(anss[2 * ret[i]], i + vec[i]); &#125; for(int x : ret) BT.update(x, -1); return;&#125;int main()&#123; n = read(); Rint u, v; FOR(i, 1, n - 1)&#123; u = read() - 1, v = read() - 1; g[u].push_back(v), g[v].push_back(u); &#125; dfs(0, -1); solve(0, -1, 0); ROF(i, n - 1, 1) chkmax(ans[i], ans[i + 1]); ROF(i, n - 2, 1) chkmax(anss[i], anss[i + 2]); FOR(i, 1, n)&#123; chkmax(ans[i], anss[i]); chkmax(ans[i], 1 + (i &lt;= mxl)); &#125; FOR(i, 1, n) printf("%d ", ans[i]); puts(""); return VSC_Local();&#125; 顺便从300iq那里学来了一个东西。 1234567891011struct BIT&#123; int a[N]; inline void update(int x, int v)&#123; for(; x &gt;= 0; x = (x &amp; (x + 1)) - 1) a[x] += v; &#125; inline int query(int x)&#123; Rint res = 0; for(; x &lt;= n; x = (x | (x + 1))) res += a[x]; return res; &#125;&#125;BT; 这个东西可以支持单点修改和查询后缀和。证明正确性和复杂度的方法好像和普通树状数组差不多。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>树论</tag>
        <tag>dfs类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF掉分笔记]]></title>
    <url>%2Fblog%2FCF%E6%8E%89%E5%88%86%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录本人 Codeforces 的比赛历程与心得。 Round #606(Div. 1)Codeforces Round #606(Div.1, Div.2) and Technocup — Elimination Round 4 (2019.12.14 19:05) RATING CHANGE: 1922 -&gt; 1869 第一场 div 1 ，然后自闭了只做出来 A …… A 都写了十分钟。 然后开 B ，发现是个不知道什么玩意的图论，盲猜 Tarjan 或者其他什么小玩意。 图论不擅长啊。直接跳了看 C 。 是构造题，我喜欢。把 $4\times 10^5$ 看成 $4\times 10^4$ ，然后推了许久搞出来个 $O(n\sqrt{n})$ 的暴力。 交上去 RE on 48 了，检查了好久，又交了几遍。 终于重新读了一遍题，发现数据范围看错了。马上改数据范围。 2.5e8 你 CF 一秒跑不过？我当场，就把这个键盘吃掉！ 结果还真跑不过。 此时已经过一个小时了（我浪费一堆时间什么分都没拿到），心慌了认为是常数原因。 然后花了大概 10 分钟在试图卡过去。 结果当然是失败了。 然后大概剩 45 分钟吧，只能换题看 B 。 由于前面心态崩了这个巨简单的 B 没搞出来。 于是自闭了。 最后 5 分钟想到 C 正解，但是没时间打了。 然后就只过了 A 结束了…… 毕竟是第一次 div 1 ，就当是长见识了。 RATING CHANGE 出了，喜闻乐见地掉回蓝名。（上一场 +53 升紫，这一场 -53 掉蓝……） 还是太慌张了，推不出题目情绪波动太大。 这不行啊。 以后打 CF 要注意 CF 的评测机是垃圾的事实，并且要仔细看数据范围。 Round #608(Div. 2)Codeforces Round #608 (Div. 2, based on Municipal Stage of All-Russian Competitions for Schools, Saratov) (2019.12.15 17:15) RATING CHANGE: 1869 -&gt; 1777 太久不打 div 2 了……遇到不顺的场就挂了。 开局犯傻，倒序开题先开 C 。（事实证明倒序开题必须先开 D 否则比顺开分还少） 然后果然切回去之后分少得一批。 然后看 D 。题意是啥啊没看懂。 感觉是个不好做的东西，于是去看 E 。这个 E ，看起来像是在数位上乱搞？ 大概知道怎么做 E 的时候已经过一小时了，于是开码。 结果码到比赛快结束才过了样例。艰难过 pp 。 然后就回去晚修了。 一节课下课发现 fst 两题 A 和 E ，当场自闭。 看了一下代码， A 是很傻逼的感觉都过不了 pp 的错误。 E 至今不知道哪里挂了。 感觉要掉至少 100 分…… 第二节晚修下课 RATING CHANGE 出来了，结果没掉超过 100 分。 无意间翻到昨天场的草稿纸，上面密密麻麻画满了 B 和 C 的样例。突然就感觉有点感慨。 后来发现 D 题的确被题意杀了。就该看看样例先的。 大失败。 下次打 div 2 一定要注意了，要么顺开要么先做 D ，题意看不懂一定要看样例，样例不给解释的题目建议疯狂对线出题人。 总有一天，我会超回来的。 Edu Round 79Educational Codeforces Round 79 (Rated for Div. 2) (2019.12.27 22:40) RATING CHANGE: 1814 -&gt; 1880 总算有一场打得还行的。 A 题不认真看题面（没说要成环）直接白交一发…… B 题这种暴贪心的题目又死在细节上了……（然后我不知道当时在想什么连交两发，真实本场最大败笔） 然后 C 和 D 都是简单题完全没啥好说的。 发现手速完全不够快…… nantf 20 min 切前四题 0 wa ，对比我 38 min 4 wa ，高下立判，，， 发现过了前四个题之后没事做了，然后 E 题看起来比 F 可做的样子就使劲肝，结果当然是没肝出来。 果然 Educational 拼的是码速和代码正确率……不过没掉分就随便吧。 Grakn Forces 2020Grakn Forces 2020 (2020.9.30 22:35) RATING CHANGE: 1979 -&gt; 2063 咕了巨大久，直到发现自己怎么没 coach。 咋办啊，只能不咕了呗。 于是随便打了一场。 A-&gt;C-&gt;B-&gt;F-&gt;D，这怕是至今过题顺序最迷惑的一场。 A 看错题了，于是又读了一遍题目，然后切了。 B 没看懂样例，于是就做 C 去了。 然后发了公告说修复了，并且延长了 15min。wdnmd 什么玩意。 还是无法理解 B 在讲什么。出题人也许丢了馬。 于是就把 C 切了。发现人均三题了，我谔谔。 看 D，假了。看 E，不会。 于是只能回去看 B，然后突然理解了题意，切了。 保底拿到了，于是回去看 E，试图把 E 搞了。 无果。只能往后看 F。 首先我会了 $n = 2^a + 2^b$。那么怎么做其他的呢。 想了一会发现自己傻了。直接前面 $2^a$ 个做一次，后面 $2^a$ 个做一次就好了。 此时人均 5 题。我自闭了。 看了看估摸着只要不 FST 就不会掉分。于是水去了。 水着发现 D 没假。就一个单调栈瞎搞完事，开冲。 然后发现自己水太久了，居然过 D 的时候都 2h 26min 了。 事后看了看代码发现滥用 STL 严重（（（ 于是试图搞出 E。 失败了。然后边水群边等着结束。 结束，在 U 群看到好多人 B fst 了草。 试图总结一下。 发现没啥好说的，这场就是随便打的。 哦要加强语文水平。（但这次绝对是出题人有问题好吧） 哦不要在还有希望切题的时候水。 没了。 事后发现 E, G 都挺可做。但是场上做不出来也挺正常的吧。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2015」我回来了]]></title>
    <url>%2Fblog%2FYnoi2015-%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86%2F</url>
    <content type="text"><![CDATA[这个题主要是当做手写 bitset 板子来写的。 Idea：lxl Solution：lxl Std：lxl Data：lxl 对这题的评价：1/11 大概是 lxl 评价最低的题吧…… [Luogu 5068] 题意简述珂朵莉给你一个无向图，每次查询的时候给一堆二元组 $(x_i,y_i)$ 。 求图中有多少个点 $u$ 与至少一个这次询问给出的二元组 $(x_i,y_i)$ 满足 $dist(u,x_i) \le y_i$ ，其中 $dist(u, v)$ 表示 $u, v$ 这两个点在图中的距离（不连通为 $\inf$），边权全为 $1$ 。 记 $n$ 为点数， $m$ 为边数， $q$ 为询问个数， $cnt$ 为给出二元组的总数。 $1\le n\le 10^3, 1\le m, q\le 10^5, cnt \le 2.1 \times 10^6$ 。 主要思路每个点上记个 bitset $f[i]$ ， $f[i][j]$ 表示距离点 $i$ 不大于 $j$ 的点数。 可以 bfs 处理这些 bitset ，每次查询就是把一堆 bitset 或起来。 时间复杂度 $O(n\times m + \frac{n\times cnt}{\omega})$ ，空间 $O(\frac{n^3}{\omega})$ 。 参考代码把 bitset 的大部分操作都写了一遍。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; Rint ans=0,f=1;reg char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=ans*10+c-'0'; return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 1010, ToT = 16, M = 100010; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;struct my_bitset&#123; unsigned long long a[ToT]; inline void reset()&#123; FOR(i, 0, ToT - 1) a[i] = 0ull; return; &#125; inline void set()&#123; FOR(i, 0, ToT - 1) a[i] = ~0ull; return;&#125; inline my_bitset()&#123; reset(); &#125; inline void filp(int x)&#123; a[x &gt;&gt; 6] ^= (1ull &lt;&lt; (x &amp; 63)); &#125; inline void reset(int x)&#123; a[x &gt;&gt; 6] &amp;= ~(1ull &lt;&lt; (x &amp; 63)); &#125; inline void set(int x)&#123; a[x &gt;&gt; 6] |= (1ull &lt;&lt; (x &amp; 63)); &#125; inline int test(int x)&#123; return (a[x &gt;&gt; 6] &gt;&gt; (x &amp; 63)) &amp; 1; &#125; inline int count()&#123; Rint res = 0; FOR(i, 0, ToT - 1) res += __builtin_popcountll(a[i]); return res; &#125; //----- inline my_bitset operator ~()const &#123; my_bitset res; FOR(i, 0, ToT - 1) res.a[i] = ~a[i]; return res; &#125; inline my_bitset operator |(const my_bitset &amp;B)const &#123; my_bitset res; FOR(i, 0, ToT - 1) res.a[i] = a[i] | B.a[i]; return res; &#125; inline my_bitset operator &amp;(const my_bitset &amp;B)const &#123; my_bitset res; FOR(i, 0, ToT - 1) res.a[i] = a[i] &amp; B.a[i]; return res; &#125; inline my_bitset operator ^(const my_bitset &amp;B)const &#123; my_bitset res; FOR(i, 0, ToT - 1) res.a[i] = a[i] ^ B.a[i]; return res; &#125; inline my_bitset operator &lt;&lt;(const int &amp;t)const &#123; my_bitset res; Rint High = t &gt;&gt; 6, Low = t &amp; 63; unsigned long long Last = 0; FOR(i, 0, ToT - High - 1)&#123; res.a[i + High] = Last | (a[i] &lt;&lt; Low); if(Low) Last = a[i] &gt;&gt; (64 - Low); &#125; return res; &#125; inline my_bitset operator &gt;&gt;(const int &amp;t)const &#123; my_bitset res; Rint High = t &gt;&gt; 6, Low = t &amp; 63; unsigned long long Last = 0; ROF(i, ToT - 1, High)&#123; res.a[i - High] = Last | (a[i] &gt;&gt; Low); if(Low) Last = a[i] &lt;&lt; (64 - Low); &#125; return res; &#125; //----- inline void operator |=(const my_bitset &amp;B)&#123; FOR(i, 0, ToT - 1) a[i] |= B.a[i]; return; &#125; inline void operator &amp;=(const my_bitset &amp;B)&#123; FOR(i, 0, ToT - 1) a[i] &amp;= B.a[i]; return; &#125; inline void operator ^=(const my_bitset &amp;B)&#123; FOR(i, 0, ToT - 1) a[i] ^= B.a[i]; return; &#125; inline void operator &lt;&lt;=(const int &amp;t)&#123; *this = *this &lt;&lt; t; &#125;//懒了…… inline void operator &gt;&gt;=(const int &amp;t)&#123; *this = *this &gt;&gt; t; &#125;&#125;a[N][N], tmp;#define inf (1001)int n, m, q, dis[N], Que[M];vector&lt;int&gt; G[N];inline void bfs(int S)&#123; FOR(i, 1, n) dis[i] = inf; dis[S] = 0; Rint l = 0, r = 1, u, v; Que[0] = S; while(l &lt; r)&#123; u = Que[l++]; FOR(i, 0, int(G[u].size()) - 1)&#123; v = G[u][i]; if(chkmin(dis[v], dis[u] + 1)) Que[r++] = v; &#125; &#125; FOR(i, 1, n) a[S][dis[i]].set(i); FOR(i, 1, n) a[S][i] |= a[S][i - 1];&#125;int main()&#123; n = read(), m = read(), q = read(); Rint u, v, T; FOR(i, 1, m)&#123; u = read(), v = read(); G[u].push_back(v); G[v].push_back(u); &#125; FOR(i, 1, n) bfs(i); while(q--)&#123; T = read(); tmp.reset(); while(T--)&#123; u = read(), v = read(); tmp |= a[u][v]; &#125; printf("%d\n", tmp.count()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Ynoi</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2015」盼君勿忘]]></title>
    <url>%2Fblog%2FYnoi2015-%E7%9B%BC%E5%90%9B%E5%8B%BF%E5%BF%98%2F</url>
    <content type="text"><![CDATA[这个题是刚考挂 CSP 回来写的。 Idea：lxl Solution：lxl Std：lxl Data：lxl 对这题的评价：4/11 [Luogu 5072] 题意简述一个长为 $n$ 的整数序列， $m$ 次查询。每次给出 $l, r, p$ ，查询区间 $[l,r]$ 中所有子序列分别去重（即一个子序列中出现多次的数只留下一个）后的和 $\bmod\ p$ 。 $1\le n, m, a_i\le 10^5, 1\le p\le 10^9$ ，不强制在线。 主要思路一个长度为 $len$ 的询问，如果一个数 $x$ 出现了 $k$ 次，对答案的贡献是 $x(2^{len - k}(2^k - 1))$ 。 $2^{len - k}$ 是除了 $x$ 以外的数的子序列个数， $2^k - 1$ 是所有 $x$ 构成的子序列中包含 $x$ 的种数。 把出现个数为 $i$ 的数的和记为 $s_i$ ，则只需要维护 $s$ 即可。 肯定是离线下来莫队，但是模数不同不好求答案。 发现出现个数大于 $\sqrt{n}$ 的数的个数不会超过 $\sqrt{n}$ ，所以将出现次数大于 $\sqrt{n}$ 的数用一个东西来维护，复杂度就是单次 $O(\sqrt{n})$ 的了。 然后快速幂要用那种 $O(\sqrt{n})$ 预处理 $O(1)$ 求幂次的方法（就是处理 $2^0, 2^1, 2^2, \dots, 2^{\sqrt{n}}$ 和 $2^{\sqrt{n}}, 2^{2\sqrt{n}}, \dots, 2^{n}$ ）。 出现次数大于 $\sqrt{n}$ 的数可以用哈希表来维护。 unordered_set 居然没被卡。 于是就时间复杂度 $O((n + m)\sqrt{n})$ ，空间复杂度 $O(n)$ 了。 参考代码然后不知道为什么跑得巨慢，花了 std 的两倍时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125;// #define using_mod const int N = 100010, BN = 330; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;const int blo = 317;int n, m, a[N], ans[N], bl[N], cnt[N];struct Query&#123; int l, r, mod, id; inline int operator &lt;(const Query &amp;t)const&#123; return bl[l] == bl[t.l] ? (bl[l] &amp; 1 ? r &lt; t.r : r &gt; t.r) : l &lt; t.l ; &#125;&#125;Que[N];LL sum[BN];unordered_set&lt;LL&gt;s;int p_2[BN], pb2[N];inline int ksm2(const int &amp;x, const int &amp;mod)&#123; return 1ll * p_2[x % blo] * pb2[x / blo] % mod; &#125;inline void inc(int &amp;x, const int &amp;y, const int &amp;mod)&#123; x += y; if(x &gt;= mod) x -= mod; &#125;inline void Query(int id)&#123; const int mod = Que[id].mod; Rint l = Que[id].l, r = Que[id].r, res = 0, len = r - l + 1; FOR(i, 1, blo) p_2[i] = 2ll * p_2[i - 1] % mod; pb2[1] = p_2[blo]; Rint tmp = pb2[1]; FOR(i, 2, blo) pb2[i] = 1ll * tmp * pb2[i - 1] % mod; tmp = ksm2(len, mod); FOR(j, 1, blo) inc(res, sum[j] * (tmp - ksm2(len - j, mod) + mod) % mod, mod); for(int t : s) inc(res, 1ll * t * (tmp - ksm2(len - cnt[t], mod) + mod) % mod, mod); ans[Que[id].id] = res;&#125;inline void update_add(int x)&#123; if(cnt[x] &gt; blo) cnt[x]++; else&#123; sum[cnt[x]++] -= x; if(cnt[x] &gt; blo) s.insert(x); else sum[cnt[x]] += x; &#125;&#125;inline void update_del(int x)&#123; if(cnt[x] &gt; blo + 1) cnt[x]--; else&#123; if(cnt[x] &gt; blo) s.erase(x), sum[--cnt[x]] += x; else sum[cnt[x]--] -= x, sum[cnt[x]] += x; &#125;&#125;int main()&#123; n = read(), m = read();// blo = ceil(sqrt(n)); p_2[0] = pb2[0] = 1; Rint cb = 1; FOR(i, 1, n)&#123; a[i] = read(); bl[i] = (i % blo) ? cb : cb++; &#125; FOR(i, 1, m) Que[i].id = i, Que[i].l = read(), Que[i].r = read(), Que[i].mod = read(); Rint l = 1, r = 0; sort(Que + 1, Que + m + 1); FOR(i, 1, m)&#123; while(r &lt; Que[i].r) update_add(a[++r]); while(l &gt; Que[i].l) update_add(a[--l]); while(r &gt; Que[i].r) update_del(a[r--]); while(l &lt; Que[i].l) update_del(a[l++]); Query(i); &#125; FOR(i, 1, n) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2015」纵使日薄西山]]></title>
    <url>%2Fblog%2FYnoi2015-%E7%BA%B5%E4%BD%BF%E6%97%A5%E8%96%84%E8%A5%BF%E5%B1%B1%2F</url>
    <content type="text"><![CDATA[感觉失去卡常的兴致了……，虽然这个题明明不卡常。 Idea：ccz Solution：ccz Std：ccz Data：ccz 对这题的评价：3/11 [Luogu 5069] 题意简述维护一个长度为 $n$ 的正整数序列 $a$ ， $m$ 次修改序列中某个位置的值。 每次修改后问对序列重复进行以下操作，需要进行几次操作才能使序列变为全 $0$ （询问后序列和询问前相同，不会变为全 $0$ ）： 选出序列中最大值的出现位置，若有多个最大值则选位置标号最小的一个，设位置为 $x$ ，则将 $a{x-1},a_x,a_{x+1}$ 的值减 $1$ ，如果序列中存在小于 $0$ 的数，则把对应的数改为 $0$ 。 $1\le n, m\le 10^5, 1\le a_i \le 10^9$ 。 主要思路如果一个位置 $x$ 是极大值（即 $a_{x-1} &lt; a_x, a_x \ge a_{x + 1}$ ），显然位置 $x - 1$ 和位置 $x + 1$ 不会成为最大值，且位置 $x$ 会成为最大值 $a_x$ 次。而操作过位置 $x$ 后，可能会出现新的极大值。 分析找极大值的过程，发现是从初始每个极大值开始向两侧隔一个位置取一个位置，直到到达极小值或边界为止。一个极小值仅当到两侧第一个极大值的距离均为偶数时才成为极大值。 所以对奇数位置和偶数位置分别开一棵树状数组维护一下，然后用一棵平衡树记录序列的极大值和极小值位置。这样就能够快速计算两个极值之间的区间的贡献。 对于单点修改，只会影响两侧最多分别两个区间，重新计算贡献即可。 时间复杂度 $O(n\log_2{n})$ 。 参考代码写得好的话细节其实不多。 开始想要把两个极值之间的答案记在前一个极值上，然后发现很难写…… 于是把极大值到两侧极小值这两段区间的答案记在极大值上，极小值上只记录自己有没有贡献。 然后由于要访问前两个和后两个极值，所以开始先插入一些初值即可减少讨论。 总之想好了再码还是比较容易的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#pragma GCC optimize("Ofast")#pragma GCC optimize("unroll-loops")#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 100010; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;typedef set&lt;int&gt;::iterator iter;set&lt;int&gt; s;int n, m, a[N];LL ans;struct BIT&#123;//树状数组 LL a[N]; inline void update(int x, LL v)&#123; if(x) for(; x &lt;= n; x += x &amp; (-x)) a[x] += v; &#125; inline LL query(int x)&#123; if(x &lt;= 0) return 0; if(x &gt; n) x = n; reg LL res = 0; for(; x; x -= x &amp; (-x)) res += a[x]; return res; &#125; inline LL query(int l, int r)&#123; return l &lt;= r ? query(r) - query(l - 1) : 0; &#125;&#125;BT[2];inline LL get_num(iter it)&#123;//求贡献直接传迭代器进来 Rint x = *it; if(x &lt;= 0 || x &gt; n) return 0; Rint opt = a[x - 1] &lt; a[x] &amp;&amp; a[x] &gt;= a[x + 1]; reg iter nxt = it, pre = it; ++nxt, --pre; if(opt)&#123; return BT[x &amp; 1].query(*pre + 1, *nxt - 1); &#125; else&#123; return (x - *pre + 1) &amp; 1 &amp;&amp; (*nxt - x + 1) &amp; 1 ? a[x] : 0; &#125;&#125;inline void build()&#123; s.insert(-1), s.insert(n + 2); s.insert(-1145141919), s.insert(1145141919); s.insert(1), s.insert(n); FOR(i, 2, n - 1) if(!((a[i - 1] &lt; a[i]) ^ (a[i] &gt;= a[i + 1]))) s.insert(i); for(reg iter it = s.begin(); it != s.end(); ++it) ans += get_num(it); return;&#125;inline void update(int x, int y)&#123; reg iter nxt = s.upper_bound(x), pre = --s.lower_bound(x); ans -= get_num(nxt), ans -= get_num(pre); reg iter nnxt = nxt, ppre = pre; ++nnxt, --ppre; ans -= get_num(nnxt), ans -= get_num(ppre); if(*next(pre) == x) ans -= get_num(next(pre)); BT[x &amp; 1].update(x, y - a[x]); a[x] = y; FOR(i, x - 1, x + 1)&#123; if(i &lt;= 1 || i &gt;= n) continue;//边界也不需要从 set 里面取出来 if(!((a[i - 1] &lt; a[i]) ^ (a[i] &gt;= a[i + 1]))) s.insert(i); else s.erase(i); &#125; ++nnxt; for(reg iter it = ppre; it != nnxt; ++it)&#123; ans += get_num(it); &#125; return;&#125;int main()&#123; n = read(); FOR(i, 1, n) BT[i &amp; 1].update(i, a[i] = read()); build(); m = read(); Rint x, y; FOR(o, 1, m)&#123; x = read(), y = read(); update(x, y); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>log数据结构</tag>
        <tag>Ynoi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于日常使用字体]]></title>
    <url>%2Fblog%2F%E5%85%B3%E4%BA%8E%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[出于某些原因，在学校使用的电脑换了一台。 然后由于实在忍受不了 cmd 界面丑陋的字体，所以就折腾了一会。 下列操作均在 Windows 7 系统中进行。 字体的安装什么 build 不会啊，反正是 Windows ，直接把 ttf 文件下下来选中右键安装完事。 推荐平时使用 Sarasa Gothic（更纱黑体），代码 Hack 或 Fira Code。 目前计算机中安装的字体可以在在 C:\Windows\Fonts 查看。 Fira Code 还有一些特性，详见后文。 更改 cmd 字体Win + R， regedit 进入注册表。 再进入[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Console\TrueTypeFont]中。 代码页936：默认简中字体 代码页950：默认繁中字体 代码页932：默认日文字体 代码页949：默认韩文字体 代码页437：其他（不属于上面的所有项都属于这个代码页） 添加一项 0936 ，输入需要的字体即可。 然后打开 cmd ，右键标题栏的 属性(P) ，更改字体即可。 参考kangflict的博客。 更改 Dev C++ 字体虽然我本人是不喜欢 Dev C++ ……但是总还是得用。 工具[T]&gt;编译器选项[E]&gt;显示。 更改 VS Code 字体打开 UI 界面的设置。 顺便附上目前使用的 settings.json 。 12345678910111213141516&#123; "git.ignoreMissingGitWarning": true, "C_Cpp.intelliSenseEngineFallback": "Enabled", "atomKeymap.promptV3Features": true, "editor.multiCursorModifier": "ctrlCmd", "editor.formatOnPaste": true, "window.zoomLevel": 0, "editor.cursorBlinking": "phase", "editor.cursorStyle": "line-thin", "C_Cpp.updateChannel": "Insiders", "files.associations": &#123; "*.json": "jsonc" &#125;, "editor.fontFamily": "'Fira Code', 'Sarasa Term SC'", "editor.fontLigatures": "false"&#125; 更改 Hexo 博客字体（NexT 主题）打开主题目录下的 _config.yml 。 然后就是 font: 那一段。 发现原本的 Lato 字体不是很难看，所以就只将代码字体改为了 Hack 。 Fira Code 特性 大概就是在支持连字属性的地方会将各种连着的符号渲染成左图这个样子…… SublimeText, Xcode, Notepad++, Eclipse 等编辑器都不支持连字。 然而 VS Code 支持，只要在 settings.json 里加上一行： 1&quot;editor.fontLigatures&quot;: &quot;true&quot; 但是本人觉得这样搞反而会降低代码可读性，所以便作罢。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1172D」Nauuo and Portals]]></title>
    <url>%2Fblog%2FCF1172D%2F</url>
    <content type="text"><![CDATA[ouuan 场的有意思构造题。 [CF 1172D] 题意简述定义一对传送门 $(A,A^\prime)$ 为从 $A$ 门进入会从 $A^\prime$ 门出来，且保持进入 $A$ 门的方向（从 $A^\prime$ 进去同理）。 给出一个 $n\times n$ ($1\le n\le 10^3$) 的矩形和 $2n$ 个要求，其中前 $n$ 个要求的形式为 $(r_i,n)$ ，代表 $\texttt{Nauuo}$ 从 $(i,1)$ 这个格子出发一直向右走，经过若干对传送门（或者不经过传送门）后从 $(r_i,n)$ 这个格子走出矩形；后 $n$ 个要求的形式为 $(n,c_i)$ ，代表 $\texttt{Nauuo}$ 从 $(1,i)$ 这个格子出发一直向下走，经过若干对传送门（或者不经过传送门）后从 $(n,c_i)$ 这个格子走出矩形。 请你在这个 $n\times n$ 的矩形中放置若干对传送门，使得这 $2n$ 个请求可以同时满足。输出传送门的对数和每对传送门两个门各自的坐标。 保证 $r_i, c_i$ 为 $1$ 到 $n$ 的排列。无解时输出 $-1$ 。 注意：你不需要找到使用传送门最少的方案数，只需要让你给出的方案可以满足题目中给出的要求。 主要思路考虑 $n\times n$ 的问题如何转换成 $(n - 1)\times (n - 1)$ 。 假设从第 $i$ 行进的人要从第 $r_i$ 行出去，第 $i$ 行出去的人要是从第 $idr_i$ 行进的人。 假设从第 $i$ 列进的人要从第 $c_i$ 列出去，第 $i$ 列出去的人要是从第 $idc_i$ 列进的人。 考虑满足第 $i$ 行出去的人和第 $i$ 列出去的人。 我们可以在 $(i, idc_i), (idr_i, i)$ 的位置放置一对传送门（如果 $idc_i$ , $idr_i$ 不都为 $i$ ），并且之后不再在第 $i$ 行或第 $i$ 列放置传送门。 此时，满足了第 $idr_i$ 行进的人与第 $idc_i$ 列进的人。并且第 $i$ 行进的人一定会到达 $(idr_i, i)$ ，第 $i$ 列进的人一定会到达 $(i, idc_i)$ 。 然后更改 $idr_{r_i},r_{idr_i},idc_{c_i},c_{idc_i}$ ，继续做下一行即可。时间复杂度 $O(n)$ 。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 1010; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;int n, r[N], c[N], idr[N], idc[N];vector&lt;pair&lt;PII, PII&gt; &gt; ans;int main()&#123; n = read(); FOR(i, 1, n) idr[r[i] = read()] = i; FOR(i, 1, n) idc[c[i] = read()] = i; FOR(i, 1, n)&#123; if(idr[i] == i &amp;&amp; idc[i] == i) continue; ans.push_back(MP(MP(i, idc[i]), MP(idr[i], i))); r[idr[i]] = r[i], idr[r[i]] = idr[i]; idr[i] = i, r[i] = i; c[idc[i]] = c[i], idc[c[i]] = idc[i]; idc[i] = i, c[i] = i; &#125; printf("%d\n", (int)ans.size()); for(auto &amp;i : ans)&#123; printf("%d %d %d %d\n", i.fir.fir, i.fir.sec, i.sec.fir, i.sec.sec); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2018」天降之物]]></title>
    <url>%2Fblog%2FYnoi2018-%E5%A4%A9%E9%99%8D%E4%B9%8B%E7%89%A9%2F</url>
    <content type="text"><![CDATA[第二道 Ynoi2018 。 Idea：lxl Solution：lxl Std：lxl Data：lxl “弑尽破净的第四分块” （妈呀这名字好中二啊（谁叫我要用日本轻小说中的东西命名真是作死）） 这题就是我想改一个已有的经典根号形式改出来，然后想了想发现可以做 考虑根号分治 存在序列分块做法 对这题的评价：6/11 [Luogu 5397] [51nod 2046] 题意简述维护一个长 $n$ 的整数序列 $a$ ， $m$ 个操作，可能是以下两种： 给出 $x,y$ 两个正整数，将序列中所有值为 $x$ 的数变为 $y$ ； 给出 $x,y$ 两个正整数，查询序列中对于所有 $i,j$ 满足 $a_i=x, a_j=y$ ， $|i-j|$ 的最小值，无解输出Ikaros。 强制在线， $1\le n,m\le 10^5,0\le a_i,x,y\le 10^5$ 。 主要思路看到所有操作都只涉及整个序列就感觉应该不是序列分块。 所以考虑根号分治。 设 $x$ 在序列中的个数为 $siz[x]$ 。 称满足 $siz[x] \ge \sqrt{n}$ 的数 $x$ 为大的，否则为小的。 无修做法把每个数 $i$ 出现的位置按顺序丢到一个数组 $V[i]$ 里。 再预处理每个大的数到所有其他值的答案，显然可以每个大的数 $O(n)$ ，预处理复杂度 $O(n\sqrt{n})$ 。 查询的时候如果 $x$ 与 $y$ 均为小，则可以使用类似归并的方法， $O(\sqrt{n})$ 查询排序后的位置数组得到答案；否则直接 $O(1)$ 取出预处理的答案即可。 所以时间复杂度为 $O(n\sqrt{n} + m\sqrt{n})$ 。 带修做法假设将所有 $x$ 变为 $y$ 。 由于可以通过一些技巧，使得 $x$ 变为 $y$ 等价于 $y$ 变为 $x$ ，所以不妨先设 $siz[x] \le siz[y]$ 。 假设我们一开始预处理的大的数 $B$ 到任意数 $i$ 的答案为 $ans[B][i]$ 。 如果 $x$ 与 $y$ 均为大，我们可以直接 $O(n)$ 重构 $y$ 到每个数 $i$ 的答案 $ans[y][i]$ 。由于需要满足 $x,y$ 均为大，故这样的重构不会超过 $\sqrt{n}$ 次，总复杂度 $O(n\sqrt{n})$ 。 如果 $x$ 与 $y$ 均为小，并且合并后也为小，我们只需要对于每个大数 $B$ ，使用 $ans[B][x]$ 更新 $ans[B][y]$ ，并将 $ans[B][x]$ 设为 $\inf$ 即可。这样单次复杂度为大数个数，即 $O(\sqrt{n})$ 。若 $x$ 与 $y$ 合并后为大，那么直接如上方 $O(n)$ 重构。易得这样的重构也不会超过 $\sqrt{n}$ 次，所以总复杂度 $O(n\sqrt{n})$ 。 然而 $x$ 为小， $y$ 为大时，仅使用 $ans$ 数组来记录答案不可行。若直接 $O(n)$ 重构，总复杂度上升到 $O(n^2)$ ；若只更新每个大数 $B$ 到 $y$ 的答案 $ans[B][y]$ ，正确性出现问题。 假设将 $x_1, x_2$ （小）分别变为 $y_1, y_2$ （大）。则 $ans[y_1][y_2]$ 记录的是原本的 $y_1$ 到原本的 $y_2, x_2$ 的答案的最小值， $ans[y_2][y_1]$ 记录的是原本的 $y_2$ 到原本的 $y_1, x_1$ 的答案的最小值。若现在 $y_1, y_2$ 的答案实际在原本的 $x_1, x_2$ 之间取得，则无法被更新到。故直接更新正确性错误。 我们对每个大的数 $B$ 都开一个附属集合，表示目前序列的哪些位置原本不是 $B$ 但现在变成了 $B$ ，这些位置就应该是在上方讨论过，未被完全更新的位置。将这些位置按顺序放入数组 $V^\prime[B]$ 中，$|V^\prime[B]|$ 记为 $psz[B]$。 对于 $x$ 为小， $y$ 为大时的修改，仍然对每个大数 $B$ 更新 $ans[B][y]$ ，并将所有 $x$ 出现的位置按顺序加入 $V^\prime[y]$ 中。此时一次的时间复杂度为 $O(\sqrt{n} + psz[y])$ 。故若 $V^\prime[y]$ 在加入 $x$ 的位置后， $psz[y]$ 大小已经比 $\sqrt{n}$ 大，需要像 $x$ 与 $y$ 均为大时一样，直接 $O(n)$ 重构 $ans[y][i]$ 。由于这样的重构次数也不会超过 $\sqrt{n}$ 次，总复杂度也是 $O(n\sqrt{n})$ 。 如上述修改，总复杂度即为 $O(n\sqrt{n} + m\sqrt{n})$ 。 接下来假设查询 $x$ 与 $y$ ，先钦定 $siz[x] \le siz[y]$ 。 如果 $x$ 与 $y$ 均为小，可以通过无修时类似归并的方法， $O(\sqrt{n})$ 做。 如果 $x$ 与 $y$ 均为大，先 $\min(ans[y][x], ans[x][y])$ 得到一个答案，再将两数的附属集合像上面的方法一样归并做，两个答案的最小值就是真正的答案，复杂度也为 $O(\sqrt{n})$ 。 如果 $x$ 为小， $y$ 为大，将 $V[x]$ 和 $V^\prime[y]$ 归并做，再与 $ans[y][x]$ 取最小值即为答案，复杂度仍为 $O(\sqrt{n})$ 。 所以总时间复杂度 $O((n + m)\sqrt{n})$ ，空间复杂度 $O(n\sqrt{n})$ 。 参考代码然而怎么实现？ 由于需要支持在修改中交换 $x, y$ ，需要一个数组 $rn[i]$ 来表示数 $i$ 现在在序列中的真实值。 发现当数 $i$ 为大的时候，存 $V[i]$ 没有用，直接把 $V^\prime[i]$ 存到 $V[i]$ 上去，这样合并两个集合或者附属集合就好写多了。 大数肯定要编个号，注意垃圾回收。然后就是注意 $siz$ 和 $psz$ 的修改不要漏了。 实验证明大数的判定标准定到 $500$ 时跑得最快。加了三行指令集之后，跑到了最优解，纪念一下。 更多细节见代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#pragma GCC optimize("Ofast")#pragma GCC optimize("unroll-loops")#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 100010, MX = 100000, BN = 500, BM = 210; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;inline int my_max(Rint a, Rint b)&#123; return (a &gt; b) ? a : b; &#125;inline int my_min(Rint a, Rint b)&#123; return (a &lt; b) ? a : b; &#125;#define max(a,b) my_max(a,b)#define min(a,b) my_min(a,b)//inline int abs(Rint x)&#123; return x &lt; 0 ? -x : x; &#125;//#define abs(x) ((x) &lt; 0 ? -(x) : (x))#define swap(a,b) (a ^= b ^= a ^= b)#define inf (114514)//手写各种东西vector&lt;int&gt; v[N];int n, m, bgn, a[N], siz[N], psz[N], rn[N], bnd[N];//siz[x] : 数 x 在序列中的个数; psz[x] : 数 x 附属集合大小; rn[x] : 数 x 实际上是什么数//bgn : 目前最大大数序号; bnd[x] : 数 x 对应的大数序号 int ans[BM][N];int del[N], dt;const int blo = BN;inline int new_big_num()&#123; return dt ? del[dt--] : ++bgn;&#125;inline void init_big_num(Rint x)&#123;//O(n) 预处理 ans[bnd[x]]][i] Rint id = bnd[x], now = inf; FOR(i, 1, MX) ans[id][i] = inf; FOR(i, 1, n)&#123; if(a[i] == x) now = 0; else chkmin(ans[id][a[i]], ++now); &#125; now = inf; ROF(i, n, 1)&#123; if(a[i] == x) now = 0; else chkmin(ans[id][a[i]], ++now); &#125;&#125;inline void build_big_num(Rint x)&#123;//建新大数 bnd[x] = new_big_num(); init_big_num(x), ans[bnd[x]][x] = 0;&#125;inline void rebuild_big_num(Rint x, Rint y)&#123;//将 x 合并到大数 y 并重构 if(bnd[x]) del[++dt] = bnd[x]; FOR(i, 1, n) if(a[i] == x) a[i] = y; psz[y] = 0; init_big_num(y);&#125;inline void merge(Rint x, Rint y)&#123;//将 x 的集合合并到 y 的集合中 Rint sx = siz[x], sy = siz[y] &lt; blo ? siz[y] : psz[y], ss = sx + sy; vector&lt;int&gt; tmp = v[y]; v[y].resize(ss + 10); while(sx &amp;&amp; sy) v[y][ss--] = ((v[x][sx] &gt; tmp[sy]) ? v[x][sx--] : tmp[sy--]); while(sx) v[y][ss--] = v[x][sx--]; while(sy) v[y][ss--] = tmp[sy--]; FOR(i, 1, bgn) chkmin(ans[i][y], ans[i][x]); FOR(i, 1, siz[x]) a[v[x][i]] = y; return;&#125;inline int merge_num(Rint x, Rint y)&#123;//求两个集合间的答案 Rint sx = siz[x] &lt; blo ? siz[x] : psz[x], sy = siz[y] &lt; blo ? siz[y] : psz[y], res = inf; if(!sx || !sy) return inf; while(sx &amp;&amp; sy) chkmin(res, (v[x][sx] &gt; v[y][sy]) ? v[x][sx--] - v[y][sy] : v[y][sy--] - v[x][sx]); //这两行不需要是因为通过这两行得出的答案一定不会比上一行得出的答案更优// ROF(i, sx, 1) chkmin(res, v[y][1] - v[x][i]);// ROF(i, sy, 1) chkmin(res, v[x][1] - v[y][i]); return res;&#125;inline void update(Rint xx, Rint yy)&#123; Rint x = rn[xx], y = rn[yy]; if(x == y || !siz[x]) return; if(siz[x] &gt; siz[y]) swap(x, y), swap(xx, yy), rn[yy] = 0, rn[xx] = y;//保证 siz[x] &lt;= siz[y] else rn[xx] = 0; if(!x || !y) return;//没有直接跳了 //siz[x] &lt;= siz[y] &lt; blo if(siz[y] &lt; blo)&#123; if(siz[x] + siz[y] &lt; blo)&#123; merge(x, y); siz[y] += siz[x], siz[x] = 0; &#125; else&#123;//变大重构 bnd[y] = new_big_num(); FOR(i, 1, siz[x]) a[v[x][i]] = y; init_big_num(y); siz[y] += siz[x], siz[x] = 0; &#125; return; &#125; //siz[x] &lt; blo &lt;= siz[y] if(siz[x] &lt; blo)&#123; if(psz[y] + siz[x] &lt; blo)&#123; merge(x, y); psz[y] += siz[x], siz[y] += siz[x], siz[x] = 0; &#125; else&#123;//psz[y] 过大重构 psz[y] += siz[x], siz[y] += siz[x], siz[x] = 0; rebuild_big_num(x, y); &#125; return; &#125; //blo &lt;= siz[x] &lt;= siz[y] siz[y] += siz[x], siz[x] = 0; rebuild_big_num(x, y);//直接重构&#125;inline int query(Rint xx, Rint yy)&#123; Rint x = rn[xx], y = rn[yy]; if(x == y) return siz[x] ? 0 : -1; if(!siz[x] || !siz[y]) return -1;//判掉无解情况 if(siz[x] &gt; siz[y]) swap(x, y), swap(xx, yy); //siz[x] &lt;= siz[y] &lt; blo if(siz[y] &lt; blo) return merge_num(x, y); //siz[x] &lt; blo &lt;= siz[y] if(siz[x] &lt; blo) return min(ans[bnd[y]][x], merge_num(x, y)); //blo &lt;= siz[x] &lt;= siz[y] return min(min(ans[bnd[y]][x], ans[bnd[x]][y]), merge_num(x, y));&#125;int main()&#123; n = read(), m = read(); FOR(i, 1, n) ++siz[a[i] = read()], rn[i] = i; FOR(i, 1, MX)&#123; if(siz[i] &gt;= blo) build_big_num(i), v[i].resize(10); else v[i].resize(siz[i] + 10), siz[i] = 0; &#125; FORit(int, a, i, 1, n)&#123; if(siz[*i] &lt; blo) v[*i][++siz[*i]] = i - a; &#125; Rint lastans = 0, opt, x, y; while(m --)&#123; opt = read(), x = read() ^ lastans, y = read() ^ lastans;// opt = read(), x = read(), y = read(); if(opt == 1) update(x, y); else&#123; lastans = query(x, y); if(lastans == -1) puts("Ikaros"), lastans = 0; else printf("%d\n", lastans); &#125; &#125; return 0;&#125; 对比一下自己写「Ynoi2018」未来日记时的码风发现变化有点大…… 参考资料lxl 原博客 foreverlasting 的博客]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Ynoi</tag>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Musescore初体验]]></title>
    <url>%2Fblog%2FMusescore%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[边打 Codeforces 边下《恋×シンアイ彼女》， System Test 结束之后才下了一半不到。 于是觉得好无聊啊，就去找我的 Sibelius 7 破解版。结果发现挂了，各种意义上的。 折腾了一会之后修好了，但是本来我就不大会用 Sibelius ，加上它很卡，于是就弃了。 想到还有一个免费制谱软件 Musescore ，并且有汉化版。 于是赶紧到官网下了一个来折腾。 然后发现这比以前用过的 Overture 好太多了，以后就用 Musescore 吧。 结果下完好久之后才折腾完。 抄写了まんどぉ 採譜空間的 喫茶ステラと死神の蝶 OP -「Smiling-Swinging!!」，作为使用 Musescore 的练习。 mscz, pdf, mp3, mid. 原谱面： 原 OP 动画。 操作用户手册。 基本操作首先先创建空乐谱。 然后，大概就会有教程手把手教你基本操作了。 而且这个……大部分都可以摸索出来吧……于是这篇文章只讲一些比较重要的东西。 所以也有需要时才更新吧。 输入音符官网教程 快捷键N可以快速进入或退出音符输入模式。 快捷键1~9分别对应选择时值为六十四分音符到四全音符。 快捷键.为选择附点，0为选择对应休止符。 这个多声部功能居然是可以删掉除第一声部以外其他声部的休止符的，好评。 连音符可以Ctrl + 2 ~ 9来添加 2 ~ 9 连音。 大于 9 个音符的连音可以使用上方的添加 &gt; 连音符 &gt; 其他…。 速度打开那个符号面板中速度那一栏。选择一个音符（休止符）然后双击你需要的速度即可。可以移动位置，也可以双击修改。 Swing摇摆节拍的使用方法。官网讲得蛮详细了。 右键出谱表文字属性之后的界面： 图片可以复制到占位框里然后使劲移动，做到图中的效果。 线性记号记得先选中一段区间再双击需要的记号。 这个东西也可以拖动。 奏法记号Ctrl + ↑↓居然可以上下移动奏法记号。不过也可以拿鼠标拖动就是了。 倚音这倚音也很不错啊。 有前后两种，如果想要一个位置多个倚音的话可以使用添加音程的方式向倚音添加音程。 不过因为有缩小音符音头这个东西在，好像只要是不带斜杠的倚音都不用倚音做出同样的效果哎。 琶音与滑音没啥大问题，然而这个刮奏为啥在音符距离比较小的时候就变了样子啊…… 谱表与分谱属性 所以怎么调整整个谱表的高度啊……]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫老师带你从高考走向一试]]></title>
    <url>%2Fblog%2F%E8%8E%AB%E8%80%81%E5%B8%88%E5%B8%A6%E4%BD%A0%E4%BB%8E%E9%AB%98%E8%80%83%E8%B5%B0%E5%90%91%E4%B8%80%E8%AF%95%2F</url>
    <content type="text"><![CDATA[两位数竞大佬 mzc 与 cp 心血来潮出了一份难度据说是高考衔接一试难度的小测卷，并由苦工 zsd 验题。 两大看点： 看本人因好久没有认真做过数学题被其他神仙暴踩； 试卷不用 $\LaTeX$ 格式爆炸，各种出锅，骂出题人。 一些题目T1在锐角 $\triangle{ABC}$ 中， $\sin{A} + \sin{B} + \sin{C} + \tan{A} + \tan{B} + \tan{C}$ ____ $\pi$ 。（） A. $&lt;$ B. $&gt;$ C. $\ge$ D. $=$ solution: 然而这题最快方法或许是代正三角形？ 大家都知道当 $x\in(0, \frac{\pi}{2})$ 有 $\sin{x} &lt; x &lt; \tan{x}$ 。 什么？要用万能公式？不存在的。 T2已知奇函数 $f(x)$ 在 $[-1, 0]$ 上为单调递减函数， $\alpha, \beta$ 为某锐角三角形的两个内角，则____。（） A. $f(\cos{\alpha}) &gt; f(\cos{\beta})$ B. $f(\sin{\alpha}) &lt; f(\cos{\beta})$ C. $f(\sin{\alpha}) &gt; f(\sin{\beta})$ D. $f(\sin{\alpha}) &gt; f(\sin{\beta})$ solution: $\because \alpha + \beta &gt; \frac{\pi}{2}$ $\therefore 0 &lt; \frac{\pi}{2} - \beta &lt; \alpha\qquad\therefore \sin{(\frac{\pi}{2} - \beta)} &lt; \sin{\alpha}$ $\therefore f(\sin{\alpha}) &lt; f(\cos{\beta})$ T3若实数 $a, b$ 满足不等式 $\begin{cases}a + b - 2 \ge 0 \\ b - a - 1 \le 0 \\ a \le 1 \end{cases}$ ，则 $\frac{a + 2b}{2a + b}$ 的最大值为____。（） A. $\frac{8}{5}$ B. $\frac{7}{5}$ C. $\frac{6}{5}$ D. $1$ solution: 直接线性规划就完事了。 T9函数 $f(a, b) = (a - b)^2 + (\sqrt{2 - a^2} - \frac{9}{b})^2$ 的最小值为____。 solution: 这东西就是两点 $C,D$ ，其中 $x_C^2 + y_C^2 = 2, y_C \ge 0, x_D\cdot y_D = 9$ ，然后求这两点距离的最小值。 然后场上居然没做出来。 T12设 $\triangle{ABC}$ 中 $BC$ 边上的高为 $h$ ，且 $h = \frac{\sqrt{3}a}{3}$ ，则 $\frac{c}{b} + \frac{b}{c} + \frac{a^2}{bc}$ 的最大值为____。 solution: 设 $L=\frac{c}{b} + \frac{b}{c} + \frac{a^2}{bc}=\frac{c^2+b^2+a^2}{bc} = 2\cos{A} + \frac{2a^2}{bc}$ $\because 2S = ah = \frac{\sqrt{3}}{3} a^2 = bc\sin{A}$ $\therefore L = 2\cos{A} + 2\sqrt{3}\sin{A} = 4\sin(A + \frac{\pi}{6}) \le 4$ 又当 $A = \frac{\pi}{3}, B = \frac{\pi}{2}, C = \frac{\pi}{6}$ 时， $L = 4$ $\therefore L_{\max} = 4$ T13请用一个式子表示数列 $1, 2, 3, 1, 2, 3, \dots$ 的通项公式（下标从 $1$ 开始）。 solution: $a_n = (n - 1) % 3 + 1$ 好，结果你要求只用初等方法，还不告诉我初等方法是什么 上单位根。 $[x|n] = \frac{1}{x}\sum\limits_{r = 0}^{x - 1} \omega_x^{r\cdot n}$ $n \% x = \sum\limits_{t = 1}^{x - 1}t \cdot [x | (n - t)] = \sum\limits_{t = 1}^{x - 1}\frac{t}{x}\sum\limits_{r = 0}^{x - 1} \omega_x^{r\cdot (n-t)}$ 直接代进去就能得到一个很丑的式子。 然后稍微好看点的式子是 $a_n = 1 + \omega_3^n + \omega_3^{n + 1} + \omega_3^{2n} + \omega_3^{2n + 2}$ 。 结果你还要求不准用虚数…… $\cos{\frac{2n\pi}{3} = \begin{cases} 1, 3|n\\ -\frac{1}{2}, \text{others} \end{cases}}$ 好，配一下就好了。 T17在 $\triangle{ABC}$ 中， $M$ 为 $BC$ 中点，有一条直线穿过线段 $AB,AC$ 与 $AB,AC,AM$ 分别交于点 $P,Q,N$ 。求证 $\frac{AB}{AP},\frac{AM}{AN},\frac{AC}{AQ}$ 成等差数列。 solution: 设 $\frac{AB}{AP} = \alpha,\frac{AM}{AN} = \gamma,\frac{AC}{AQ} = \beta$ 。 则要证明 $\alpha + \beta = 2\gamma$ 。 $\because M$ 为 $BC$ 中点 $\qquad\therefore \overrightarrow{AB} + \overrightarrow{AC} = 2\overrightarrow{AM}$ 即 $\alpha\overrightarrow{AP} + \beta\overrightarrow{AQ} = 2\gamma\overrightarrow{AN}\qquad$ 即 $\frac{\alpha}{2\gamma}\overrightarrow{AP} + \frac{\beta}{2\gamma}\overrightarrow{AQ} = \overrightarrow{AN}$ $\because P,Q,N$ 三点共线 $\qquad\therefore \frac{\alpha}{2\gamma} + \frac{\beta}{2\gamma} = 1$ $\therefore \alpha + \beta = 2\gamma$ T18设 $a,b,c\in \mathbf{R}_+, abc = 1$ 。求证 $L = (a - 1 + \frac{1}{b})(b - 1 + \frac{1}{c})(c - 1 + \frac{1}{a}) \le 1$ 。 solution: 设 $a = \frac{x}{y}, b = \frac{y}{z},c = \frac{z}{x}, x,y,z\in \mathbf{R}_+$ 。 则 $L = (\frac{x - y + z}{y})(\frac{x + y - z}{z})(\frac{-x + y + z}{x})$ 设 $p = x + y - z, q = x + y - z, p = x + y - z$ ，则 $x = \frac{p + q}{2}, y = \frac{p + r}{2}, z = \frac{q + r}{2}$ 。 $\because pqr = \sqrt{pq}\cdot\sqrt{qr}\cdot\sqrt{rp} \le \frac{p + q}{2}\cdot\frac{p + r}{2}\cdot\frac{q + r}{2} = xyz$ $\therefore L = \frac{pqr}{xyz} \le 1$ T20用牟合方盖证明球的体积公式。 solution: 咕了。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1261E」Not same]]></title>
    <url>%2Fblog%2FCF1261E%2F</url>
    <content type="text"><![CDATA[这构造题怎么随便猜个结论就对了啊……另外这个题做法好多…… 所以 Technocup 都是升分好场？等等 div 2 没这题 总有一天我不会再咕掉升分好场的！ [CF 1261E] 题意简述给你一个整数序列 $\left\langle a_n\right\rangle$ ，保证每个数都在 $[1,n]$ 之内。 你需要找出至多 $n + 1$ 个互不相同的 $1, 2, 3, \dots, n$ 的子集，使得对于任意整数 $i$ ( $1\le i\le n$ ) 在这些集合中的出现次数为 $a_i$ 。 输出任意一个答案， $1\le n\le 10^3$ 。 主要思路本人做法首先肯定还是先排序。下文中基于 $\left\langle a_n\right\rangle$ 为不降的序列讨论。 根据样例，先考虑 $\forall i, a_i = n$ 的情况。 在 $n = 5$ 时的一个答案： 12345676111110111110111110111110111110 这给我们一些微小的启发。 初始化现在我们规定 $g(i,j)$ 表示集合 $i$ 内是否有数 $j$ 。 考虑刚刚的情况。如果 $a_i \le i$ ，令 $g(k, i) = 1$ ( $1\le k\le a_i$ ) ；如果 $a_i &gt; i$ ，令 $g(k, i) = 1$ ( $k\in [1,i] \cup [i+2,a_i+1]$ ) 。 例如样例二： Input: 1251 3 4 4 5 g: 123451111101111001110101100101 发现此时每个集合都是不同的，即已经找到了一个答案。 显然，这样的方法并不能保证最后每个集合都不同。例如样例三： Input: 1251 1 1 1 5 g: 123451111100001000010000100001 此时，有 $4$ 个相同的集合，g不是合法的答案。 解决冲突考虑如何将这些相同的集合变为不同的集合。 发现第一个集合必定是全集。下称第一个集合为元集合。 我们考虑从元集合中取出一些数放到其他集合中使得所有集合不同。 比如上面的样例三就可以变成这样： g(new): 123450001100001001010100110001 我们将元集合中 $1, 2, 3$ 这三个数分别移出并放入第 $5, 4, 3$ 这 $3$ 个集合中。 定义 $h(i)$ 为处理前 $i$ 个数时，原本的 $g$ 中序号最大的不为空的集合的序号。 例如样例四： Input: 1252 2 3 5 5 g: 123456111110111110111000110000100010 $i$ $1$ $2$ $3$ $4$ $5$ $h(i)$ $3$ $3$ $3$ $6$ $6$ 可以看出，因为 $g(i, i + 1) = 0$ ，几个冲突的集合必定为前缀一段0，后缀一段1的形式。 而仅当 $a_i &gt; a_{i - 1}$ 时，才有可能发生冲突。此时有相同的集合个数为 $\min(a_i, i) - h(i - 1)$ 。 相同的 $c$ 个集合可以对除第一个以外的 $c-1$ 个中加入一个数使得其互不相同。 一个显然的想法是维护一个 $p$ ，表示当前元集合中最小的数。每当出现冲突时，将该数从元集合中取出，并插入到冲突的最后一个集合中，然后将 $p$ 设为元集合现在最小的数。 这样，就得到了上文中样例三的一个答案。 然而我们发现这样会有一些问题。 例如样例五： Input: 1271 1 1 4 4 4 7 g: 12345671111111000111100011110001111000000100000010000001 处理第 $4$ 个数出现的冲突时没有问题，此时 g 变为： 12345670011111000111101011111001111000000100000010000001 而当处理第 $7$ 个数出现的冲突时，如果将元集合中的 $3$ 移出放入第 $7$ 个集合，则会导致第 $1$ 与第 $2$ 个集合相同。 所以，为了保证元集合不和其他集合相同，如果 $a_p &lt; a_{p + 1}$ ，那么 $p$ 这个数就不应该被从元集合中移出。 那么还有什么元集合中的数应该保留？ 例如样例五： Input: 1271 3 3 3 3 3 7 g: 12345671111111011111100111110100001000000100000010000001 处理第 $7$ 个数的冲突时，会导致 g 变为： 12345670011111011111100111110100001000000101000011000001 此时，第 $1$ 与 第 $3$ 个集合相同了。 所以，如果 $a_i &gt; i$ ，数 $i$ 也不应从元集合中取出。 加上这两个处理后开码，一交过了。 正确性证明为什么这是对的？ 首先我们先将初始的 g 表示成几个点与一条直线。 例如上图对应的 g : 1234567811111110001111000111100011110000111000001100001010000110 设这条直线为 $\text{base}$ ，向右为 $x$ 轴正方向，向下为 $y$ 轴正方向。将所有在 $\text{base}$ 下方的点都向上移动一个单位，这样，第 $i$ 个点的位置即为 $(i, a_i)$ 。 然后把相邻两个点之间的先向右再向下两条线段连起来。这样得到一条折线，从 $(1, a_1)$ 开始，到 $(n, a_n)$ 结束。 考虑这条折线中所有竖直的线段。设所有跨过直线 $\text{base}$ 的线段的在 $\text{base}$ 下方的长度和为 $nS$ ，所有线段的长度和为 $S$ ，线段条数为 $cS$ （将跨过 $\text{base}$ 的线段算作两条）。例如上图中， $nS = 1, S = 6, cS = 3$ 。 则需要将 $S - cS - nS$ 个元集合中的数取出。 考虑这条折线中所有水平的线段。设所有跨过直线 $\text{base}$ 的线段的在 $\text{base}$ 下方的长度和为 $nT$ ，所有线段的长度和为 $T$ ，线段条数为 $cT$ 。例如上图中， $nT = 1, T = 6, cT = 3$ 。 则有 $T - cT - nT$ 个元集合中的数可以被取出。 现在我们要证明 $S - cS - nS \le T - cT - nT$ 。 因为折线的结束点 $(n, a_n)$ 必定不在直线 $\text{base}$ 下方，所以可以得到 $nS = nT$ 。并且易得 $T = n - 1, S = a_n - 1$ ， 所以 $S \le T$ 。 由于从 $(1, a_1)$ 出发后第一条线段必定向右，所以 $cS \le cT$ 。 最后就可以得到 $S - cS - nS \le T - cT - nT$ 。 所以这个做法是对的！ 神仙 HZB 做法还是先不降排序。 构造方法仍然规定 $g(i,j)$ 表示集合 $i$ 内是否有数 $j$ 。 当 $a_i \le i$ 时，令 $g(k, i) = 1$ ( $i - a_i + 1 \le k \le i$ ) ；否则令 $g(k, i) = 1$ ( $k\in [1, i] \cup [i + 2, a_i + 1]$ ) 。 例如样例二： Input: 1251 3 4 4 5 g: 123451111101111001110101100101 哎这怎么和本人的方法得到的集合一模一样啊 样例三： Input: 1251 1 1 1 5 g: 123451000101001001010001100001 不像上面本人的做法，这个答案直接就对了。 于是直接写一发，然后过了。 ？？？？？？ 正确性证明好，证明。 观察到一个鲜明的特点：集合 $i$ ( $1 \le i \le n$ ) 有 $g(i, i) = 1$ 。 首先证明第 $n + 1$ 个集合不会和任何其他集合相同。 如果 $a_{n - 1} &lt; n$ 显然这个集合为空，而其他集合均为非空。 如此，我们设 $t$ 为最小满足 $a_t = n$ 的整数。 此时 $g(n + 1, i) = 1$ ( $t \le i \le n - 1$ ) 。 易得集合 $[t, n]$ 均不与其相同（因为后面都挖掉了一个数而且每个集合挖掉的数是不同的）；且集合 $[1, t - 1]$ 均不与其相同（因为 $g(j, i) = 1$ ( $1 \le j &lt; t, t \le i \le n$ ) 而 $g(n + 1, n) = 0$ ）。 假设集合 $x$ 与集合 $y$ ( $x &lt; y \le n$ )相同。 因为 $g(x, x) = 1, g(y, y) = 1$ ，且这两个集合相同，故有 $g(y, x) = 1, g(x, y) = 1$ 。 所以 $a_x \ge y - 1$ ，即 $a_{y - 1} \ge y - 1$ ，即 $g(x, y - 1) = 1$ 。但显然 $g(y, y - 1) = 0$ ，与我们的假设矛盾。 故不存在两个集合相同。 故该构造方法正确。 BGNB! 神 tourist 做法没看懂，咕了。 原社论先不升排序。我们现在依次在这至多 $n + 1$ 个集合中加入数 $1$ 至数 $n$ 。 我们用一可重集合 $S$ 来描述已经加入 $[1, x - 1]$ 后的状态。 假设 $S = {c_1, c_2, c_3, \dots, c_{|S|}}$ ，则目前至多有 $|S|$ 种互相不同的集合，第 $i$ 种集合的数量为 $c_i$ 。 现在我们研究加入 $x$ 时会发生什么。 首先假设 $S$ 中最大的数为 $A$ 。 如果 $a_x &lt; A$ ，我们可以将 $x$ 加入到这 $A$ 个集合中的前 $a_x$ 个中去。这样，原本 $A$ 个相同的集合就变成了 $a_x$ 个新的相同的集合和 $A - a_x$ 个旧的相同的集合。由于其他集合中必定没有 $x$ ，所以这 $a_x$ 个新的相同的集合必定和其他集合不相同。 如果 $a_x \ge A$ ，我们可以类似地将 $A$ 个相同的集合变为 $A - 1$ 个新的相同的集合和 $1$ 个旧的集合。多出来的 $a_x - A + 1$ 个 $x$ 只用随机放到剩下的集合中就可以了。 开始时令 $S={n + 1}$ 即可。由于最后要将 $S$ 变为一个有 $n + 1$ 个 $1$ 的集合，且每放入一个数都会导致其中的一个元素分裂成两个而集合内元素总和不变，所以只需要 $n$ 次，一定可以满足要求。 参考代码本人做法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 1010; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;struct NODE&#123; int num, id; inline int operator &lt;(const NODE &amp;X)const&#123; return num &lt; X.num; &#125;&#125;a[N];int n, g[N][N], cbu[N], cnt, ot[N];inline int get_ans()&#123; ROF(i, n + 1, 1) FOR(j, 1, n) if(g[i][j]) return i; return 0;&#125;int main()&#123; n = read(); FOR(i, 1, n) a[i].num = read(), a[i].id = i; sort(a + 1, a + n + 1); FOR(i, 1, n) ot[a[i].id] = i; FOR(i, 1, n)&#123; FOR(j, 1, min(a[i].num, i)) g[j][i] = 1; FOR(j, i + 1, a[i].num) g[j + 1][i] = 1; &#125; FOR(i, 1, n - 1) if(a[i].num == a[i + 1].num &amp;&amp; a[i].num &lt;= i) ++cnt, cbu[i] = 1; Rint tmp = 1, h = a[1].num + (a[1].num &gt; 1); FOR(i, 2, n)&#123; if(a[i - 1].num &lt; a[i].num)&#123; Rint res = min(a[i].num, i); for(Rint t = 1; t &lt; res - h;)&#123; if(cbu[tmp])&#123; g[1][tmp] = 0; g[res - t + 1][tmp] = 1; ++t; &#125; ++tmp; &#125; &#125; chkmax(h, a[i].num + (a[i].num &gt; i)); &#125; Rint ans = get_ans(); printf("%d\n", ans); FOR(i, 1, ans)&#123; FOR(j, 1, n) putchar(g[i][ot[j]] ^ 48); putchar('\n'); &#125; return 0;&#125; 看，多短（然而在所有做法中好像也是最繁琐的……）]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP-S2019二轮游]]></title>
    <url>%2Fblog%2F20191115%2F</url>
    <content type="text"><![CDATA[感觉自一轮游已经过去了好久。 今年怎么题这么难啊。 我怎么挂了这么多分啊。 我怎么这么菜啊。 Before…总之停了一个月左右的文化课。 后三周大概每天一套模拟题。每天日常挂分。 慢慢感觉有点状态了。 Day -5 ~ -1双十一来了。然后发现当天已经day -4。 最后一周，搞了两套信心赛，之后就自主改题和复习。 然而好像也没啥能复习的。所以就开始做往年的大搜索和模拟。 Day 0早上没咋写代码了。学习p_b_p_b搞了一篇挂分集锦，然而还没上传。 结果下午还去上了个数学课放松身心。 晚上开了个美其名曰动员大会的玩意。总感觉大家都被奶了。 结束后突然开始在机房狂笑不止，机房里充满了快活的空气。笑气中毒（确信） 之后回家dd Vtuber去了。结果发现喫茶ステラと死神の蝶（星巴克与扑棱蛾子）的 OP 出了，听了一晚上。 果然柚子社最棒了。 Day 1和NOIP 2018考场相同，坐地铁只用半个小时。 感觉昨晚没睡好。在地铁里听了一路寒蝉的you，差点在地铁里睡着了。 考室在 7 楼。边爬楼还边想着有什么要注意的地方。 大概8:20让我们进去试机。翻来覆去看了各种须知之后去找noi linux虚拟机。然而并没有找到，一定是我瞎了罢。不过当时我还不知道虚拟机怎么打开，虽然会用linux。然而noi linux对于一个还没参加过 NOI 的选手有什么用吗。 8:30，开考了。 这个 T1 …… 打了个表之后知道是 k ^ (k &gt;&gt; 1) ，然而开了long long，成功-5pts。 这个 T2 …… 看上去就很套路的东西，CSP 开无限栈空间对吧，写就完事了。 才过去了不到 1.5h 。 这个 T3 …… 先码个 10pts 。 不对啊，我怎么可能只会 10pts ！ 然后想了各种假做法。最后还是只写了 10 分暴力。 期望得分 95 + 100 + 10 = 205 。 出来发现大家基本都 100 + 100 + 10 = 210 ，还好还好。 回家之后继续水群和dd Vtuber。 Day 2AthousandMoon似乎 D1T1 用了 cout 然后因为 &lt;&lt; 比 ^ 优先级高并没打括号导致 CE 了…… 不要指望着Day 2翻盘，因为你根本就不知道盘是什么样子。 再次试机，有点紧张，安分地坐在那里，什么也没动。 又到了八点半。密码怎么是抓紧时间…… 第一题卫宫饭好评。 看了几眼，第一题数数，第二题最优化，第三题在树上搞不知道什么玩意，果断顺序开题。 发现 T1 只会 32pts ，赶紧写完暴力搞 T2 。 T2 想了一会，搞了个 $O(n^2\log_2{n})$ 。希望能过 $n\le 5000$ 的点吧。 接着回肝 T1 ，码了一个假做法之后，搞出来一个 $O(n^3m)$ 的垃圾，发现有 84pts ，然后决定先拿个 T3 暴力再开码。 开 T3 ，此时10:40。然后整整 40min 没调过 T3 的 $O(n^2)$ 暴力。虽然玩出来了链，完全二叉树也大概知道思路，但是连最裸的暴力都写挂了不太敢写。 不太对劲啊。 最后半小时，赶紧回去写 T1 的 84pts 。在之前没码完的假做法上改一改就好了，写完用了不到一刻钟。 不太对劲啊。 这怎么也能写挂啊。 剩下 15min 疯狂调 T1 。然而没调出来。 完了， 32 + 64 + 0 = 96 ，连仨暴力都不如的分数。 实际能写 84 + 64 + 55(75?) = 203(223) 。真就挂的分比拿到的分还多呗。 凉了。万一哪里再写挂了什么，就连 300 都上不了了。 出来发现大家都挂分了，都在说今年题难。 成功获得小机房吊车尾，甚至差点被联赛组同学吊打了。 然而p_b_p_b（期望 498）和nantf（期望 430+）稳了。 完了，要放年假了。 Day 3 ~ 4然后就回归文化课了。 这两天年级月考。逃掉了月考，在机房自习文化课。 完全接受了自己凉凉的事实。真就浪费一年呗。 After All ～痛苦的现实～今年居然发了程序。 拉下来一测， D1T3 因为最后几分钟还在测样例，忘记开文件操作又挂 10 分。 只能捞到个没什么用的一等。 接下来的一年，虽然 OI 训练不会停止，但是没什么比赛可以现场参加了。 唉。滚回去搞文化课罢。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Old Driver Tree学习笔记]]></title>
    <url>%2Fblog%2FOldDriverTree%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Old Driver Tree (ODT)，又称珂朵莉树，是源于 lxl 出的「CF 896C」的，对一类以推平区间作为关键操作的维护数列方法。 原理很简单：使用一棵平衡树（大多数情况下为std::set），每个节点存储一段权值相等的极长区间。 一些操作下述时间复杂度时， $n$ 表示平衡树中的节点数量（即序列中权值相等的极长区间数量）。 split将某一个权值相等的区间分裂成两个，要求 $pos$ 为后一个的左端点。 在平衡树中找到跨过 $pos$ 的区间，删除并添加新区间即可。复杂度稳定 $O(\log_2{n})$ 。 assgin将区间 $[l,r]$ 推平。 先把 $l$ 和 $r + 1$ 进行 split 操作，再把 $[l,r]$ 合成一个节点。 注意要先 split $r+1$ 再 split $l$ 。 单次复杂度最坏 $O(n)$ 。 其他操作在平衡树上遍历节点即可。 复杂度的证明假设在数据真随机的情况下，开始时有 $n$ 个长为 $1$ 的区间，接下来有 $k$ 个区间推平操作。 考虑一次推平操作后，点 $i$ 作为一个权值相等的极长区间的结尾的可能性为:$$1 - \dfrac{i + \binom{i - 1}{2} + \binom{n - i}{2}}{\binom{n}{2}} = 1 - \dfrac{2i(n - i - 1)}{n(n - 1)} \approx \left(\dfrac{i}{n}\right)^2 + \left(1 - \dfrac{i}{n}\right)^2$$ 假设这 $k$ 次区间推平是独立的，那么 $k$ 次推平后点 $i$ 作为一个权值相等的极长区间的结尾的可能性约为 $((\frac{i}{n})^2 + (1 - \frac{i}{n})^2)^k$ 。 所以总的权值相等的极长区间的总数即约为 $\sum\limits_{i=1}^{n}((\frac{i}{n})^2 + (1 - \frac{i}{n})^2)^k\approx n\int_0^1 (x^2 + (1 - x)^2)^k \mathrm{d}x$ 。 $$\begin{aligned} &amp; n\int_0^1 (x^2 + (1 - x)^2)^k \mathrm{d}x \\=\ &amp; n \int_{-1/2}^{1/2} ((\frac{1}{2} + x)^2 + (\frac{1}{2} - x)^2)^k \mathrm{d}x \\=\ &amp; n \int_{-1/2}^{1/2} (\frac{1}{2} + 2x^2)^k \mathrm{d}x \\=\ &amp; n\cdot 2^{-k} \int_{-1/2}^{1/2} (1 + 4x^2)^k \mathrm{d}x \\=\ &amp; n\cdot 2^{-k} \sum\limits_{i=0}^{k} \binom{k}{i}\cdot 4^i \int_{-1/2}^{1/2} x^{2i} \mathrm{d}x \\=\ &amp; n\cdot 2^{-k} \sum\limits_{i=0}^{k} \binom{k}{i}\cdot 4^i\cdot \frac{(1/2)^{2i+1} - (-1/2)^{2i+1}}{2i+1} \\=\ &amp; n\cdot 2^{-k} \sum\limits_{i=0}^{k} \binom{k}{i} \frac{1}{2i + 1} \\\le\ &amp; n\cdot 2^{-k} \sum\limits_{i=0}^{k} \binom{k}{i} \frac{1}{i + 1} \\=\ &amp; n\cdot 2^{-k} \cdot \frac{2^{k+1} - 1}{k + 1} \\=\ &amp; O(\frac{n}{k})\end{aligned}$$ 所以，最坏情况下 $k$ 次区间推平的复杂度是 $O(n\log_2k)$ 。 lxl的题解，Akababa的原证明。另外，Blaze也给出了一种证明方法。 代码实现及例题「CF 896C」Willem, Chtholly and Seniorious例题。 维护长为 $n$ 的序列， $m$ 个操作，可能为区间加、区间推平、区间查询第 $k$ 小，区间查询 $(\sum_{i=l}^{r} a_i^x)\mod y$ 。 $1\le n,m\le 10^5$ ，数据随机生成。 思路直接上 ODT 即可。 由于要区间加，记得节点开 $mutable$ 。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125;// #define using_mod const LL mod = 1000000007; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; Templ(_Tp) inline _Tp ksm(_Tp x,LL y)&#123; reg _Tp res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;inline LL ksm(LL x, LL y, const LL &amp;p)&#123; x %= p; reg LL res = 1; for(; y; y &gt;&gt;= 1, x = x * x % p) if(y &amp; 1) res = res * x % p; return res;&#125;int n, m;LL seed, vmess;inline LL rnd()&#123; reg LL ret = seed; seed = (seed * 7 + 13) % mod; return ret;&#125;namespace ODT&#123; struct node&#123; int l, r; mutable LL val; inline node(int rl = 0, int rr = -1, LL rv = 0)&#123; l = rl, r = rr, val = rv; &#125; inline int operator &lt;(const node &amp;t)const&#123; return l &lt; t.l; &#125; &#125;; set&lt;node&gt; s; typedef set&lt;node&gt;::iterator iter; inline iter split(int pos)&#123; iter it = s.lower_bound(node(pos)); if(it != s.end() &amp;&amp; it-&gt;l == pos) return it; --it; Rint l = it-&gt;l, r = it-&gt;r; reg LL v = it-&gt;val; s.erase(it); s.insert(node(l, pos - 1, v)); return s.insert(node(pos, r, v)).first; &#125; inline void assign(int l, int r, LL val)&#123; iter itr = split(r + 1), itl = split(l); s.erase(itl, itr); s.insert(node(l, r, val)); &#125; inline void add(int l, int r, LL val)&#123; iter itr = split(r + 1), itl = split(l); while(itl != itr) (itl++)-&gt;val += val; return; &#125; inline LL k_th(int l, int r, int k)&#123; iter itr = split(r + 1), itl = split(l); vector&lt; pair&lt;LL, int&gt; &gt; vec; vec.clear(); while(itl != itr)&#123; vec.push_back(MP(itl-&gt;val, itl-&gt;r - itl-&gt;l + 1)); itl++; &#125; sort(vec.begin(), vec.end()); for(pair&lt;LL, int&gt; &amp;i : vec)&#123; k -= i.sec; if(k &lt;= 0) return i.fir; &#125; return -1ll; &#125; inline LL sum(int l, int r, LL x, LL y)&#123; iter itr = split(r + 1), itl = split(l); reg LL res = 0; while(itl != itr)&#123; res =(res + ksm(itl-&gt;val, x, y) * (itl-&gt;r - itl-&gt;l + 1)) % y; itl++; &#125; return res; &#125;&#125;using namespace ODT;int main()&#123; n = read(), m = read(), seed = read(), vmess = read(); FOR(i, 1, n) s.insert(node(i, i, rnd() % vmess + 1)); Rint opt, l, r; reg LL x, y; FOR(i, 1, m)&#123; opt = rnd() % 4 + 1; l = rnd() % n + 1; r = rnd() % n + 1; if(l &gt; r) swap(l, r); x = rnd() % ((opt == 3) ? (r - l + 1) : vmess) + 1; switch(opt)&#123; case 1:&#123; add(l, r, x); break; &#125; case 2:&#123; assign(l, r, x); break; &#125; case 3:&#123; printf("%lld\n", k_th(l, r, x)); break; &#125; case 4:&#123; y = rnd() % vmess + 1, printf("%lld\n", sum(l, r, x, y)); break; &#125; &#125; &#125; return 0;&#125; 「CometOJ contest#14 D」转转的数据结构题[CometOJ contest#14 D]。 一个长为 $m$ 的整数序列 $c$ ，初值全为 $0$ ；一个长为 $n$ 的操作序列，第 $i$ 个用三元组 $(l_i, r_i, v_i)$ 描述，代表将 $c_{l_i}, c_{l_i + 1}, c_{l_i + 2}, \cdots, c_{r_i}$ 赋值为 $v_i$ 。 $q$ 个询问，第 $i$ 个有两个参数 $x_i$ , $y_i$ ( $x_i\le y_i$ )，回答对初值全为 $0$ 的空序列 $c$ ，按顺序执行序号位于 $[x_i,y_i]$ 中的操作后， $c$ 中所有整数的和。 $1\le n,m,q\le 5\times 10^5,0\le v_i\le 2\times 10^9$ 。 思路将询问按照 $y_i$ 排序。使用类似 ODT 的方法来维护 $c$ 序列。 对平衡树上的每个节点存储一个时间戳 $t$ ，即这个节点是由哪次操作产生的。发现询问 $x_i, y_i$ 即为做完前 $y_i$ 个操作后，时间戳不小于 $x_i$ 的节点的和。这可以很容易地使用树状数组维护。 将时间后移（即进行下一个修改）时修改树状数组即可。 考虑这个方法的时间复杂度。每个节点最多只会被删除 $1$ 次。而一个修改在插入 $1$ 个节点的同时最多只会分裂 $2$ 个节点，所以节点的变化次数是 $O(n)$ 的。 所以，虽然这个题的数据不随机，然而时间复杂度是稳定 $O(n\log_2{n})$ 的。 代码写得特别丑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 500010; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;int n, m, q;struct Query_Node&#123; int tl, tr, id; inline int operator &lt;(const Query_Node &amp;t)const&#123; return tr &lt; t.tr; &#125;&#125;qry[N];struct Cover_Node&#123; int l, r, val;&#125;cvr[N];struct ODT_Node&#123; int l, r, val, tsp; inline ODT_Node(int ll = 0, int rr = 0, int vall = 0, int tspp = 0)&#123; l = ll, r = rr, val = vall, tsp = tspp; &#125; inline int operator &lt;(const ODT_Node &amp;t)const&#123; return l &lt; t.l; &#125;&#125;;struct BIT&#123; LL a[N]; inline void update(int x, LL val)&#123; if(!x) return; for(; x &lt;= m; x += x &amp; (-x)) a[x] += val; return; &#125; inline LL query(int x)&#123; reg LL res = 0; for(; x; x -= x &amp; (-x)) res += a[x]; return res; &#125; inline LL queryS(int l, int r)&#123; return query(r) - query(l - 1); &#125;&#125;BT;set&lt;ODT_Node&gt; odt;typedef set&lt;ODT_Node&gt;::iterator ODTit;LL ans[N];inline ODTit split(int pos)&#123; ODTit it = odt.lower_bound(ODT_Node(pos, 0, 0, 0)); if(it != odt.end() &amp;&amp; it-&gt;l == pos) return it; --it; Rint l = it-&gt;l, r = it-&gt;r, val = it-&gt;val, tsp = it-&gt;tsp; odt.erase(it); odt.insert(ODT_Node(l, pos - 1, val, tsp)); return odt.insert(ODT_Node(pos, r, val, tsp)).fir;&#125;inline void Assign(int l, int r, int val, int tsp)&#123; ODTit R = split(r + 1), L = split(l); for(ODTit i = L; i != R; ++i) BT.update(i-&gt;tsp, -1ll * (i-&gt;val) * (i-&gt;r - i-&gt;l + 1)); odt.erase(L, R); odt.insert(ODT_Node(l, r, val, tsp)); BT.update(tsp, 1ll * val * (r - l + 1));&#125;int main()&#123; m = read(), n = read(), q = read(); FORit(Cover_Node, cvr, i, 1, m) i-&gt;l = read(), i-&gt;r = read(), i-&gt;val = read(); FORit(Query_Node, qry, i, 1, q) i-&gt;tl = read(), i-&gt;tr = read(), i-&gt;id = i - qry; sort(qry + 1, qry + q + 1); odt.insert(ODT_Node(1, n + 1, 0, 0)); FORit(Query_Node, qry, i, 1, q)&#123; FOR(tsp, (i - 1)-&gt;tr + 1, i-&gt;tr) Assign(cvr[tsp].l, cvr[tsp].r, cvr[tsp].val, tsp); ans[i-&gt;id] = BT.queryS(i-&gt;tl, m); &#125; FOR(i, 1, q) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ODT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Comet#13F」「蓬莱的弹枝 -七色的弹幕-」]]></title>
    <url>%2Fblog%2FCometOJ-13F%2F</url>
    <content type="text"><![CDATA[一道只有标题和东方有关系的大分块。 [CometOJ contest#13 F] 题意简述维护一个长为 $n$ 的序列，要求支持查询距离某个数 $a_x$ 距离最近的相等的数与这个数的距离，区间加一，区间左移一位（即 $a_{i}\leftarrow a_{i+1} (l\le i\le r), a_r\leftarrow a_l$ ）。 $1\le n,m,a_i\le 10^5$ 。 主要思路所以平衡树怎么做这个玩意？ 分块，设每块长度为 $K$ 。每个块内记录： $beg$ ：这个块第一个数的下标减一 $cnt$ ：这个块的长度 $tag$ ：这个块的加标记 $\left\langle num\right\rangle$ ：块中元素（存储的值为真实值减去 $tag$ ，存储的数对应原序列中的 $[beg + 1, beg + cnt]$ ） $\left\langle fix\right\rangle$ ： $fix_{val}$ 表示块内值为 $val$ （真实值为 $val + tag$ ）的数的数量 查询查询时，寻找这个位置 $x$ 所在的块 $B_x$ ，先在这个块内找有没有相同数；再分别遍历 $B_x$ 后面与前面的块，找到后面与前面分别第一次出现 $a_x$ 的块（由于存储了 $\left\langle fix\right\rangle$ ，可以 $O(1)$ 判断一个块内有没有 $a_x$），在块内暴力寻找 $a_x$ 出现的位置更新答案。 这样得到三组结果，取最优即可。一次时间复杂度 $O(K + \dfrac{n}{K})$ 。 区间加经典操作。散块暴力整块打 $tag$ 即可。一次时间复杂度 $O(K + \dfrac{n}{K})$ 。 区间左移设区间左移 $[l,r]$ 时，最前和最后的要修改的块分别为 $B_l$ 与 $B_r$ 。 官方题解中，每个块的大小是定的。这样使用块状数组，每次左移即对于 $[B_l, B_r]$ 中的每个块，将弹出一个数字和插入一个数字，块大小仍然不变，只需处理修改块的 $beg$ 即可。发现散块是在中间插入与弹出，可以暴力处理；整块是在两端插入与弹出，可以 $O(1)$ 搞。一次时间复杂度是 $O(K + \dfrac{n}{K})$ 。 这样写比较方便，代码也比较短。 然而本人将此题当作块状链表的例题来做。即完全按照题意，每次左移将块 $B_l$ 中对应序列中下标为 $l$ 的数弹出，其他块不变，然后插入到块 $B_r$ 中对应序列中下标为 $r$ 的数后面。 由于一个块大小减少 $1$ ，一个块大小增加 $1$ ，所以当一个块大小过大 ( $cnt &gt; 2\times K$ ) 或过小 ( $cnt \le \dfrac{K}{2}$ ) 时，将这个块分裂成两个块或与后一个块合并（若合并后 $cnt &gt; 2\times K$ ，也不应合并，应将后一个块前端部分移至该块后端使这两个块的大小较为平衡）。 最后也能推出单次时间复杂度为 $O(K + \dfrac{n}{K})$ 。 所以 $K$ 取 $\sqrt{n}$ 时，时间复杂度取到最优为 $O(n\sqrt{n})$ 。这题不卡空间所以 $K$ 开 $\sqrt{n}$ 空间上也不会有问题。 参考代码然而我真就把这题当作块状链表的例题来做了，各种不熟练导致调了一下午。 一些细节详见代码与注释。 大量指针注意。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 100010, BN = 400; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;int n, m, blo, a[N], dtop;struct Block;inline Block* new_Block();inline void del_Block(Block *B);struct Block&#123; Block *pre, *nxt; int beg, fix[N &lt;&lt; 1], tag, cnt, num[BN &lt;&lt; 1]; //beg : 前面的块总共有多少个数, cnt : 块大小, tag : 加标记 //fix : 值域(不加 tag)上每种数的数量, num : 每个数(不加 tag) inline void Clear()&#123; pre = nxt = nullptr; beg = tag = cnt = 0; MEM(fix, 0), MEM(num, 0); &#125; inline Block()&#123; Clear(); &#125; inline void scatter()&#123;//把过大的块拆成两个 Rint rc = cnt, *it = nullptr; reg Block *to = nxt, *x = new_Block(); x-&gt;pre = this, x-&gt;nxt = to; nxt = x;//处理各种关系 if(to != nullptr) to-&gt;pre = x; cnt = blo, x-&gt;cnt = rc - blo; x-&gt;beg = beg + blo, x-&gt;tag = tag; it = x-&gt;num; FOR(i, blo + 1, rc)&#123;//把信息转到分出来的块里去 ++it; *it = num[i], --fix[*it], ++(x-&gt;fix[*it]); &#125; return; &#125; inline void merge()&#123;//把过小的块和下一个块合并成两个 / 将过小的块后端插入下一个块的一个前缀使该块不至于太小 reg Block *x = nxt, *to = nullptr; if(x == nullptr) return; if(cnt + x-&gt;cnt &gt; (blo &lt;&lt; 1))&#123;//如果两个块加起来大小过大就不能直接合并(然而这样就不用处理各种关系了, 写起来其实更方便) Rint *it = nullptr; FOR(i, 1, cnt) --fix[num[i]], num[i] += tag, ++fix[num[i]]; tag = 0; it = x-&gt;num; FOR(i, cnt + 1, blo)&#123;//把这个块的长度补到 blo ++it; num[i] = (*it) + x-&gt;tag, ++fix[num[i]], --(x-&gt;fix[*it]); &#125; FOR(i, 1, cnt + x-&gt;cnt - blo) ++it, x-&gt;num[i] = *it;//处理下个块的信息 x-&gt;cnt += cnt - blo, x-&gt;beg += blo - cnt, cnt = blo; return; &#125; to = x-&gt;nxt, nxt = to; if(to != nullptr) to-&gt;pre = this;//处理各种关系 Rint rc = cnt + x-&gt;cnt, *it = x-&gt;num; FOR(i, 1, cnt) --fix[num[i]], num[i] += tag, ++fix[num[i]];//把 tag 去掉 tag = 0; FOR(i, cnt + 1, rc)&#123;//把原本的下一个块的信息转过来 ++it; num[i] = *it + x-&gt;tag, ++fix[(*it) + x-&gt;tag]; &#125; cnt = rc; del_Block(x);//把原本的下一个块删了 return; &#125; inline void check()&#123;//检查块是否过大或过小 if(cnt &gt; (blo &lt;&lt; 1)) return scatter(); if(cnt &lt;= (blo &gt;&gt; 1)) return merge(); return; &#125; inline void print()&#123; puts("Block : "); printf("beg : %d, cnt : %d, tag : %d\n", beg, cnt, tag); FOR(i, 1, cnt) printf("%d ", num[i]); puts(""); &#125;&#125;;Block *St = nullptr/*, *Ed = nullptr*/, *del[BN &lt;&lt; 1];inline Block* new_Block()&#123; return dtop ? del[--dtop] : (new Block);&#125;inline void del_Block(Block *B)&#123;//由于有拆块和合并块, 所以写了垃圾回收, 回收方式比较奇怪 B-&gt;Clear(); del[dtop++] = B; return;&#125;inline void Debug()&#123; reg Block *now = St; while(now != nullptr)&#123; now-&gt;print(); now = now-&gt;nxt; &#125; return;&#125;inline void Build()&#123; St = new_Block(); FOR(i, 1, blo) St-&gt;num[i] = a[i], ++(St-&gt;fix[a[i]]); St-&gt;beg = 0, St-&gt;cnt = blo;//先把头搞出来 reg Block *now = St, *to; FOR(i, 2, ceil(n / (DB)(blo)))&#123;//做出每个块 to = new_Block(); now-&gt;nxt = to, to-&gt;pre = now; to-&gt;beg = now-&gt;beg + now-&gt;cnt; to-&gt;cnt = min(n, to-&gt;beg + blo) - to-&gt;beg; FOR(j, to-&gt;beg + 1, to-&gt;beg + to-&gt;cnt)&#123; to-&gt;num[j - to-&gt;beg] = a[j]; ++(to-&gt;fix[a[j]]); &#125; now = to; &#125;// Ed = now; return;//实际上 Ed 根本不需要用... &#125;inline int query(int x)&#123; reg Block *now = St, *B = nullptr; Rint wgh, res = n + 1;// find block [x] while(now-&gt;beg + now-&gt;cnt &lt; x) now = now-&gt;nxt;// query block [x] wgh = now-&gt;num[x - now-&gt;beg]; if(now-&gt;fix[wgh] &gt; 1)&#123;//处理自己的块 ROF(i, x - now-&gt;beg - 1, 1) if(now-&gt;num[i] == wgh)&#123; chkmin(res, x - now-&gt;beg - i); break; &#125; FOR(i, x - now-&gt;beg + 1, now-&gt;cnt) if(now-&gt;num[i] == wgh)&#123; chkmin(res, i - x + now-&gt;beg); break; &#125; &#125; wgh += now-&gt;tag;// query next blocks B = now-&gt;nxt; while(B != nullptr)&#123; if(wgh - B-&gt;tag &gt; 0 &amp;&amp; B-&gt;fix[wgh - B-&gt;tag])&#123;//找到 next blocks 中第一个有 wgh 的块, 注意可能 wgh - B-&gt;tag 不大于 0, 要判 FOR(i, 1, B-&gt;cnt) if(B-&gt;num[i] == wgh - B-&gt;tag)&#123; chkmin(res, i + B-&gt;beg - x); break; &#125; break; &#125; B = B-&gt;nxt; &#125;// query pre blocks B = now-&gt;pre; while(B != nullptr)&#123; if(wgh - B-&gt;tag &gt; 0 &amp;&amp; B-&gt;fix[wgh - B-&gt;tag])&#123;//找到 pre blocks 中第一个有 wgh 的块, 注意可能 wgh - B-&gt;tag 不大于 0, 要判 ROF(i, B-&gt;cnt, 1) if(B-&gt;num[i] == wgh - B-&gt;tag)&#123; chkmin(res, x - i - B-&gt;beg); break; &#125; break; &#125; B = B-&gt;pre; &#125; return res != n + 1 ? res : -1;&#125;inline void update_add(int l, int r)&#123;//区间加没啥难度 reg Block *now = St; Rint *it = nullptr;// find block [l] while(now-&gt;beg + now-&gt;cnt &lt; l) now = now-&gt;nxt; if(now-&gt;beg + now-&gt;cnt &gt;= r)&#123;//if [l] and [r] in the same block it = now-&gt;num + l - now-&gt;beg - 1; FOR(i, l - now-&gt;beg, r - now-&gt;beg)&#123; ++it; --(now-&gt;fix[*it]), ++(*it), ++(now-&gt;fix[*it]); &#125; return; &#125;// update block [l] it = now-&gt;num + l - now-&gt;beg - 1; FOR(i, l - now-&gt;beg, now-&gt;cnt)&#123; ++it; --(now-&gt;fix[*it]), ++(*it), ++(now-&gt;fix[*it]); &#125;// find block [r] now = now-&gt;nxt; while(now-&gt;beg + now-&gt;cnt &lt; r)&#123; ++(now-&gt;tag); now = now-&gt;nxt; &#125; // update block [r] it = now-&gt;num; FOR(i, 1, r - now-&gt;beg)&#123; ++it; --(now-&gt;fix[*it]), ++(*it), ++(now-&gt;fix[*it]); &#125; return;&#125;inline void update_shift(int l, int r)&#123; reg Block *now = St, *x; Rint *it = nullptr, wgh;// find block [l] while(now-&gt;beg + now-&gt;cnt &lt; l) now = now-&gt;nxt; if(now-&gt;beg + now-&gt;cnt &gt;= r)&#123;//if [l] and [r] in the same block wgh = now-&gt;num[l - now-&gt;beg]; FOR(i, l - now-&gt;beg, r - now-&gt;beg - 1) now-&gt;num[i] = now-&gt;num[i + 1]; now-&gt;num[r - now-&gt;beg] = wgh; return; &#125;// update block [l] wgh = now-&gt;num[l - now-&gt;beg], --(now-&gt;fix[wgh]); FOR(i, l - now-&gt;beg, now-&gt;cnt - 1) now-&gt;num[i] = now-&gt;num[i + 1]; wgh += now-&gt;tag, --(now-&gt;cnt);//把一个点从这个块里抽出来所以 --(now-&gt;cnt) , 这个点已经抽出来了所以 wgh += now-&gt;tag x = now;// find block [r] now = now-&gt;nxt; while(now-&gt;beg + now-&gt;cnt &lt; r &amp;&amp; now != nullptr)&#123; --(now-&gt;beg);//这些中间的块因为前面有块被抽了一个数所以 --(now-&gt;beg) now = now-&gt;nxt; &#125; if(now == nullptr) return;// update block [r] ++(now-&gt;cnt), --(now-&gt;beg);//要插一个数进这个块里所以 ++(now-&gt;cnt) //由于 wgh - now-&gt;tag 可能不大于 0 所以应该把这个块的 tag 归 0 it = now-&gt;num; FOR(i, 1, r - now-&gt;beg - 1)&#123; ++it; --(now-&gt;fix[*it]), *it += now-&gt;tag, ++(now-&gt;fix[*it]); &#125; it = now-&gt;num + now-&gt;cnt; ROF(i, now-&gt;cnt, r - now-&gt;beg + 1)&#123; *it = *(it - 1); --(now-&gt;fix[*it]), *it += now-&gt;tag, ++(now-&gt;fix[*it]); --it; &#125;//归 0 tag 顺便把 now-&gt;num[r - now-&gt;beg] 空出来 ++(now-&gt;fix[wgh]), now-&gt;num[r - now-&gt;beg] = wgh;// tag 归 0 了所以直接插进去 now-&gt;tag = 0; x-&gt;check(), now-&gt;check();//因为两个块分别减少/增加了一个数所以 check 一下 return;&#125;int main()&#123; n = read(), m = read(), blo = ceil(sqrt(n)); FOR(i, 1, n) a[i] = read(); Build(); Rint opt, l, r; while(m--)&#123; opt = read() - 1, l = read(); if(opt == 2)&#123; printf("%d\n", query(l)); continue; &#125; r = read(); opt ? update_add(l, r) : update_shift(l, r); &#125; return 0;&#125; 所以我第一题块状链表是不是还是写个「POJ 2887」Big String 啥的合适啊…… 结果为什么写了这题之后马上又拿分块链表过了「SCOI 2013」多项式的运算呢……]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>块状链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉回路学习笔记与Hierholzer算法]]></title>
    <url>%2Fblog%2F%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E4%B8%8EHierholzer%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[欧拉回路和欧拉路径的学习笔记。 例题：[UOJ 117] 、 [LOJ 10105] 、 [Luogu 2731] 。 一些定义一个图，若能够找到一条路径，使得可以遍历完所有的边且不重复，则这样的图称为欧拉图，这条路径称为欧拉路径，若路径闭合也称为欧拉回路。 一些定理以下大量文字摘自维基百科。 定理一 连通的无向图有欧拉路径的充要条件是：图中度数是奇数的顶点数量是 $0$ 或 $2$ 。 连通的无向图有欧拉回路的充要条件是：图中所有点的度数都是偶数。 证明一 必要性：如果一个图能够一笔画成，那么对于除了起点和终点的其他顶点，总有路径中连向点的边数与这个点的出边数相同，即这个点的度数为偶数。而对于起点和终点，若起点和终点相同，则这个点的度数也为偶数；否则这两个点的度数为奇数。即图中度数为奇数的点的数量是 $0$ 或 $2$ 。 充分性： 如果图中没有度数为奇数的点，则任选一点出发，连一个环。如果这个环就是原图则结束。若不是，由于图是连通的，该环与原图的其他部分必然有公共顶点，从该点出发，在原图的剩余部分中重复上述步骤。由于原图是连通图，经过若干步后，全图被分为一些环。由于两个相连的环就是一个环，原来的图也就是一条欧拉回路。 如果图中有两个度数为奇数的顶点 $u$ 和 $v$ ，那么将他们连边后，得到一个无奇数度数的点的连通无向图，由上知这是一个环，因此去掉新加的边后，成为一条路径，起点和终点是 $u$ 与 $v$ 。至此证毕。 定理二如果连通无向图有 $2k$ 个奇数度数的顶点，那么它可以且至少可以用 $k$ 笔画成。 证明二将这 $2k$ 个奇数度数的顶点分成 $k$ 对后分别连起，则得到一个无奇数度数顶点的连通图。由上知这个图是一个环，因此去掉新加的边后至多成为 $k$ 条欧拉路径，因此必然可以用 $k$ 笔画成。但是假设全图可以分为 $q$ 条欧拉路径，则由定理一知，每条链中只有不多于两个奇顶点，于是 $2q\ge 2k$。因此必定至少要 $k$ 笔画成。 有向图的欧拉路径 一个连通的有向图可以表示为一条欧拉回路的充要条件是：每个顶点的出度和入度都相等。 一个连通的有向图可以表示为一条不闭合的欧拉路径的充要条件是：某一个点的出度比入度多 $1$ ，另一个点的出度比入度少 $1$ ，前者为起点而后者为终点。 证明方式类似证明一。 Hierholzer算法Hierholzer算法是一种可以在时间复杂度 $O(|E|)$ 内求出无向图或有向图的欧拉路径（如果有的话）的算法。 算法流程首先要判断这个图有没有欧拉路径，判断方法就是前面的定理。 然后，任选择一个顶点 $u$ 开始 dfs 。枚举 $u$ 的每条出边（若是无向图则为无向边） $e=(u,v)$ ，将这条边删去并 dfs 点 $v$ ，结束后将这条边加入答案序列。 最后再判断答案是否合法（指图是否不连通，图只要连通则必定合法），若合法，该序列倒序即为欧拉路径。 无论是否为欧拉回路均可以找到。 由于选择了一条边之后便将其删去，所以时间复杂度是 $O(|E|)$ 。 参考代码细节比较多，详见代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 100010; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;int n, m, ecnt, stk[N &lt;&lt; 2], stop;struct Edge&#123; int link, to, id, vis;&#125;e[N &lt;&lt; 2];struct Vertice&#123; int head, ind, outd, vis;&#125;p[N];inline void add_edge(int u, int v, int i)&#123; e[++ecnt] = (Edge)&#123; p[u].head, v, i &#125;; p[u].head = ecnt, ++p[u].outd, ++p[v].ind;&#125;inline int Output_path()&#123; if(stop &lt; m) return 0; puts("YES"); ROF(i, stop, 1) printf("%d ", stk[i]); return 1;&#125;inline void dfs_directed_graph(int u)&#123;//做有向图 for(Rint &amp;i = p[u].head, v, real_i; i; i = e[i].link)&#123;//&amp;i 是为了保证这条边不会再被遍历到 real_i = i, v = e[real_i].to; if(!e[real_i].vis)&#123; if(!p[v].vis) p[v].vis = 1; e[real_i].vis = 1; dfs_directed_graph(v); stk[++stop] = e[real_i].id; &#125; &#125; return;&#125;inline void dfs_undirected_graph(int u)&#123;//做无向图 for(Rint &amp;i = p[u].head, v, real_i; i; i = e[i].link)&#123; real_i = i, v = e[real_i].to; if(!e[(real_i + 1) &gt;&gt; 1].vis)&#123; if(!p[v].vis) p[v].vis = 1; e[(real_i + 1) &gt;&gt; 1].vis = 1; dfs_undirected_graph(v); stk[++stop] = e[real_i].id; &#125; &#125; return;&#125;int work_directed_graph()&#123; n = read(), m = read(); Rint u, v; FOR(i, 1, m) u = read(), v = read(), add_edge(u, v, i); FOR(i, 1, n) if(p[i].ind != p[i].outd) return puts("NO"), 0; FOR(i, 1, n) if(!p[i].vis)&#123; p[i].vis = 1, dfs_directed_graph(i); if(Output_path()) return 0; stop = 0; &#125; return puts("NO"), 0;&#125;int work_undirected_graph()&#123; n = read(), m = read(); Rint u, v; FOR(i, 1, m) u = read(), v = read(), add_edge(u, v, i), add_edge(v, u, -i); FOR(i, 1, n) if(((p[i].ind + p[i].outd) &gt;&gt; 1) &amp; 1) return puts("NO"), 0; FOR(i, 1, n) if(!p[i].vis)&#123; p[i].vis = 1, dfs_undirected_graph(i); if(Output_path()) return 0; stop = 0; &#125; return puts("NO"), 0;&#125;int main()&#123; int test_type = read() - 1; return test_type ? work_directed_graph() : work_undirected_graph();&#125; 一些套路哈密顿路径和欧拉路径相对，指的是遍历一个图的所有点且不重复的路径，可以不经过所有的边。 有时一个题目可以转化成哈密顿路径或欧拉路径。 然而图上找哈密顿路径是 NP 问题，所以基本是用欧拉路径做。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Comet#7C」临时翻出来的题]]></title>
    <url>%2Fblog%2FCometOJ-7C%2F</url>
    <content type="text"><![CDATA[状压好题。 [CometOJ contest#7 C] 题意简述给出一个 $1$ 至 $n$ 的排列 $a_i$ 。定义一个排列 ${p_i}$ 是合法的，要满足 $p_i\ne a_i$ 。 一个排列 ${p_i}$ 的权值可以这样计算：对于每一个逆序对 $(i,j)$ ($p_i &gt; p_j$) ，贡献为 $(j - i)\times(p_i - p_j)$ ，这个排列的权值即所有逆序对的贡献和。 求每一个合法的排列的权值和。 $case$ 组数据， $case \le 10, n \le 16$ 。 主要思路首先先把下标和值域都转换成 $[0,n-1]$ 。 这么小的数据范围，猜测复杂度大概是指数级别的。 按照从小到大往排列里放数，这样每个数在放入排列时，必定所有在其后的已经在排列中的数都会对其产生贡献。 考虑集合 $S$ 为放了数的位置，已经放了 $0,1,\dots,|S|-1$ 这些数，此时的合法排列（仅考虑已经放的数）方案。 记合法排列总数为 $t(S)$ ，贡献总和为 $f(S)$ ，位置 $pos$ 上的数在所有合法排列中的总和为 $g(S, pos)$ 。 如何转移？对于一个集合 $S$ ，枚举下一个数即( $|S|$ )放的位置 $x,x\ne a_{|S|}$ 。 设 $T = S\ \cup\ {x}$ ，考虑 $S$ 转移至 $T$ 。 对 $f(T)$ 的贡献为： $f(S) + \sum\limits_{i&gt;x,i\in S}(|S|\times t(S) - g(S,i))\times (i - x)$ 。（枚举与数 $|S|$ 形成逆序对的位置） 对 $t(T)$ 的贡献为： $t(S)$ 。（数 $|S|$ 只有一种放法） 对 $g(T,x)$ 的贡献为： $t(S)\times |S|$ 。 对 $g(T,i)$ 的贡献为： $g(S,i)$ ( $i\ne x$ ) 。 初始状态是 $|S|={k}$ 的状态 ( $0\le k\le n - 1$ ) ，如果 $a_0\ne k$ ， $f({k})=0,g({k},k)=0,t({k})=1$ 。 参考代码然后不知道为什么代码写得特别丑……为了卡常 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 20, MX = 65550; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;int n, a[N], U, count_[MX], loog[MX] = &#123;-1&#125;;LL f[MX], g[MX][N], t[MX];inline void Summer_Pockets()&#123; n = read(), U = (1 &lt;&lt; n) - 1; FOR(i, 0, n - 1) a[i] = read() - 1; FOR(S, 0, U) f[S] = 0, t[S] = 0; FOR(S, 0, U) FOR(i, 0, n - 1) g[S][i] = 0; FOR(S, 1, U)&#123; if(count_[S] == 1)&#123; if(a[0] == loog[S]) continue; f[S] = 0, g[S][loog[S]] = 0, t[S] = 1; continue; &#125; Rint cnt = count_[S] - 1, T, pos; reg LL res; for(Rint rS = S, x = S &amp; (-S); x; rS ^= x, x = rS &amp; (-rS))&#123; T = S ^ x, res = 0, pos = loog[x]; if(a[cnt] == pos) continue; for(Rint rrS = rS ^ (rS &amp; (-rS)), i = rrS &amp; (-rrS); i; rrS ^= i, i = rrS &amp; (-rrS))&#123; res += (t[T] * cnt - g[T][loog[i]]) * (loog[i] - pos); &#125; f[S] += res + f[T]; for(Rint rT = T, i = T &amp; (-T); i; rT ^= i, i = rT &amp; (-rT))&#123; g[S][loog[i]] += g[T][loog[i]]; &#125; g[S][pos] += t[T] * cnt; t[S] += t[T]; &#125; &#125; printf("%lld\n", f[U]);&#125;int main()&#123; U = 65535; FOR(i, 1, U) count_[i] = count_[i &gt;&gt; 1] + (i &amp; 1), loog[i] = loog[i &gt;&gt; 1] + 1; Rint esac = read(); while(esac --) Summer_Pockets(); return 0;&#125; CometOJ 其实有很多高质量题目，比如状压 dp 就还有「Comet#1C」,「Comet#4F」。等我不咕了一定把「Comet#4F」肝出来。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF750G」New Year and Binary Tree Paths]]></title>
    <url>%2Fblog%2FCF750G%2F</url>
    <content type="text"><![CDATA[这题听了几遍还没听懂，结果对着 nantf 的代码爆抄才大概懂了这题在搞什么。 [CF 750G] 题意简述一棵无限的满二叉树，根节点为 $1$ ，节点 $x$ 的左儿子是 $2x$ ，右儿子是 $2x+1$ 。给定一个正整数 $n$ ，询问这棵满二叉树上有多少条简单链，使得链上所有点之和，即链的权值为 $n$ 。 $1\le n\le 10^{15}$ 。 主要思路发现可以将满足条件的链分为 $\text{LCA}$ 是链的端点的（单链）和不是的（双链），分别考虑。 单链考虑从 $x$ 往左儿子走 $h$ 步。此时链权值为 $x(2^h - 1)$ 。 若倒数第 $i$ 步走了右儿子，权值将增加 $2^i - 1$ 。 所以 $x$ 往下形成的长为 $h$ 的链中，设倒数第 $i,i\in T$ 步走向了右儿子，这样一条单链就可以表示成 $(h, T)$ 的形式。 则最后链的权值为：$$x(2^h - 1) + \sum\limits_{i\in T} 2^i - |T|$$ 令 $L=\lfloor\dfrac{n}{2^h - 1}\rfloor$ ，显然有 $|T|&lt; h \le \log_2(n+1) , x \le L$ 。 又 $(L - 1)(2^h - 1) + \sum\limits_{i\in T}2^i - |T| \le n - (2^h - 1) + (2^h - h - 1) = n - h &lt; n$ ，所以 $x &gt; L - 1$ ，即对于给定的 $h$ 有唯一的 $x=L$ ，并且方案数就是关于集合 $T$ 的方程 $L(2^h - 1) + \sum\limits_{i\in T} 2^i - |T| = n$ 的解的个数。发现这个方程最多只有一组解。 双链从 $x$ 的左右儿子出发两条单链，类似上面设这两条单链表示为 $(h_0, T_0), (h_1, T_1)$ 。 此时，这条 $\text{LCA}$ 为 $x$ 的双链的权值和为：$$\begin{aligned}&amp;x + 2x(2^{h_0} - 1) + (2x+1)(2^{h_1} - 1) +\sum\limits_{i\in T_0} 2^i +\sum\limits_{i\in T_1}2^i-|T_0|-|T_1|\\&amp;=x(2^{h_0 + 1} + 2^{h_1 + 1} - 3) + 2^{h_1} - 1 + \sum\limits_{i\in T_0} 2^i +\sum\limits_{i\in T_1} 2^i-|T_0|-|T_1|=n\end{aligned}$$ 类似单链时的推论，发现 $h_0,h_1$ 确定时有唯一的 $x=\lfloor\dfrac{n-2^{h_1}+1}{2^{h_0+1}+2^{h_1+1}-3}\rfloor$ 。 此时，问题转化为了在 $2^1,2^2,\dots,2^{h_0-1},2^1,2^2,\dots,2^{h_1-1}$ 中一共选取 $cnt$ 个数，和为 $n - x(2^{h_0 + 1} + 2^{h_1 + 1} - 3) - 2^{h_1} + 1 + cnt$ 的方案数。 考虑枚举 $cnt$ ，设 $f(i,j,0/1)$ 表示枚举完前 $i$ 个指数 ( $2^1,2^2,\dots,2^i$ ) 后，已经选了 $j$ 个数字，二进制下 $i+1$ 是否进位的方案数。 $f(0,0,0) = 1$ 。 dp 过程大概就是枚举两边的单链走左儿子还是右儿子，然后保证上一位和需要凑出的和相同之类的，详见代码。 在枚举了 $h_0,h_1,cnt$ 的情况下，答案就是 $f(max(h_0,h_1),cnt,0)$ 。 可以得出时间复杂度是 $O(\log_2^5n)$ 。 参考代码基本爆抄的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline LL read()&#123; reg LL ans=0,f=1;reg char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=ans*10+c-'0'; return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, MX = 50; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;LL n, f[60][120][2];//inline int count1(LL x)&#123; return x ? count1(x &amp; (x - 1)) + 1 : 0; &#125;#define count1(x) (__builtin_popcountll(x))inline LL work1()&#123; reg LL ans = 0, x, res; FOR(i, 1, MX)&#123; x = n / ((1ll &lt;&lt; i) - 1); if(!x) break; res = n - x * ((1ll &lt;&lt; i) - 1); FOR(j, 0, i - 1) if( !((res + j) &amp; 1) &amp;&amp; count1(res + j) == j) ++ans; &#125; return ans;&#125;inline LL work2()&#123; reg LL ans = 0, x, res; FOR(l, 2, MX) FOR(r, 2, MX)&#123; x = (n - (1ll &lt;&lt; (r - 1)) + 1) / ((1ll &lt;&lt; r) + (1ll &lt;&lt; l) - 3); if(!x) break; res = n - (1ll &lt;&lt; (r - 1)) + 1 - x * ((1ll &lt;&lt; r) + (1ll &lt;&lt; l) - 3); FOR(cnt, 0, l + r - 4) if(!((res + cnt) &amp; 1))&#123; FOR(i, 0, max(l, r)) FOR(j, 0, min(cnt, i &lt;&lt; 1)) f[i][j][0] = f[i][j][1] = 0; f[0][0][0] = 1; FOR(i, 1, max(l, r)) FOR(j, 0, min(cnt, (i - 1) &lt;&lt; 1))&#123; FOR(k, 0, 1) FOR(a, 0, 1) FOR(b, 0, 1)&#123; if(i &gt;= l - 1 &amp;&amp; a) continue; if(i &gt;= r - 1 &amp;&amp; b) continue; if( ((k + a + b) &amp; 1) == (((res + cnt) &gt;&gt; i) &amp; 1) )&#123; f[i][j + a + b][(k + a + b) &gt;&gt; 1] += f[i - 1][j][k]; &#125; &#125; &#125; ans += f[max(l, r)][cnt][0]; &#125; &#125; return ans;&#125;int main()&#123; n = read(); return printf("%lld\n", work1() + work2()), 0;&#125; 参考资料nosta 的 blog Kelin 的 blog nantf 的代码]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>猜结论</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF715D」Create a Maze]]></title>
    <url>%2Fblog%2FCF715D%2F</url>
    <content type="text"><![CDATA[神仙构造题不是人能场上做出来的…… [CF 715D] 题意简述一个四联通的 $n\times m$ 的迷宫，相邻的两个位置之间可能有墙阻隔使得这两个位置不能直接互达，一共有 $k$ 堵墙。从 $(1,1)$ 进入迷宫，而出口是 $(n,m)$ ，假设现在在 $(x,y)$ ，下一步只能走到 $(x + 1,y)$ 或 $(x,y + 1)$ ，当然不能走出迷宫且下一步走到的位置和现在位置之间不能有墙。通过一些计算，得出从入口 $(1,1)$ 走到 $(n,m)$ 共有 $T$ 种走法。 现在给出 $T$ ， $1\le T\le 10^{18}$ ，希望你构造出一个迷宫，使得从入口 $(1,1)$ 走到 $(n,m)$ 共有 $T$ 中走法，限制 $1\le n,m\le 50, 0\le k\le 300$ 。 主要思路考虑在 $(x,y)$ 时答案是 $T$ 。发现可以简单地在 $(x+1,y+1)$ 获得 $2T$ 。 如何将 $T$ 变为 $2T + 1$ ？考虑将上方开一小口，将一个 $1$ 引入。 如何保证引入的是 $1$ ？ 发现只需要保证红圈位置的为 $1$ 即可，所以可以在外面建墙。 那么初始的状态如何生成呢？如图，左上角为 $(1,1)$ 。 这样，可以将 $T$ 转换成二进制数，就可以得到 $T &lt; 2^{50}$ 的做法了。 然而题目要求做到 $T \le 10^{18}$ ，如何解决？ 发现可以在 $(x+2,y+2)$ 获得 $6T$ ，而 $6 &gt; 2^2$ ，看起来就可以将 $n,m$ 卡进 $50$ 以内。 但是我们同时要便于获得 $6T + i$ ( $1\le i \le 5$ )。 发现在引入 $1$ 的情况下，若不建图中的蓝墙，不建一堵墙会增加 $3$ 种方案；不建图中的红墙，不建一堵墙会增加 $1$ 种方案。如此就可以将 $T$ 转换成六进制做了。 同时为了保证引入的是 $1$ ，可以如图所示在外围建墙。此时，计算最大的 $n,m,k$ ，发现都可以卡进限制范围内。 初始状态同二进制做法。 参考代码代码写起来特别难受…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline LL read()&#123; reg LL ans=0,f=1;reg char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=ans*10+c-'0'; return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, K = 310, N = 55; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;LL T;struct Wall&#123; int x, y, xx, yy;//x &lt;= xx, y &lt;= yy&#125;Q[K];int top, a[N], acnt;int main()&#123; T = read(); while(T)&#123; a[acnt++] = T % 6; T /= 6; &#125; FOR(i, 0, (acnt - 1) &gt;&gt; 1) swap(a[i], a[acnt - 1 - i]); Rint n = 2; Q[top++] = (Wall)&#123; 1, 2, 2, 2 &#125;, Q[top++] = (Wall)&#123; 2, 1, 2, 2 &#125;; FOR(i, 0, acnt - 1)&#123; if(n &gt; 2)&#123; Q[top++] = (Wall)&#123; n - 2, n + 2, n - 1, n + 2 &#125;, Q[top++] = (Wall)&#123; n + 2, n - 2, n + 2, n - 1 &#125;; if(i != acnt - 1)&#123; Q[top++] = (Wall)&#123; n - 2, n + 3, n - 1, n + 3 &#125;, Q[top++] = (Wall)&#123; n + 3, n - 2, n + 3, n - 1 &#125;; &#125; &#125; if(i != acnt - 1)&#123; Q[top++] = (Wall)&#123; n, n + 2, n, n + 3 &#125;, Q[top++] = (Wall)&#123; n + 1, n + 2, n + 1, n + 3 &#125;; Q[top++] = (Wall)&#123; n + 2, n, n + 3, n &#125;, Q[top++] = (Wall)&#123; n + 2, n + 1, n + 3, n + 1 &#125;; &#125; switch(a[i])&#123; case 0 :&#123; Q[top++] = (Wall)&#123; n - 1, n + 1, n, n + 1 &#125;, Q[top++] = (Wall)&#123; n - 1, n + 2, n, n + 2 &#125;; Q[top++] = (Wall)&#123; n + 1, n - 1, n + 1, n &#125;, Q[top++] = (Wall)&#123; n + 2, n - 1, n + 2, n &#125;; break; &#125; case 1 :&#123; Q[top++] = (Wall)&#123; n - 1, n + 1, n, n + 1 &#125;; Q[top++] = (Wall)&#123; n + 1, n - 1, n + 1, n &#125;, Q[top++] = (Wall)&#123; n + 2, n - 1, n + 2, n &#125;; break; &#125; case 2 :&#123; Q[top++] = (Wall)&#123; n - 1, n + 1, n, n + 1 &#125;; Q[top++] = (Wall)&#123; n + 1, n - 1, n + 1, n &#125;; break; &#125; case 3 :&#123; Q[top++] = (Wall)&#123; n - 1, n + 2, n, n + 2 &#125;; Q[top++] = (Wall)&#123; n + 1, n - 1, n + 1, n &#125;, Q[top++] = (Wall)&#123; n + 2, n - 1, n + 2, n &#125;; break; &#125; case 4 :&#123; Q[top++] = (Wall)&#123; n + 1, n - 1, n + 1, n &#125;, Q[top++] = (Wall)&#123; n + 2, n - 1, n + 2, n &#125;; break; &#125; case 5 :&#123; Q[top++] = (Wall)&#123; n + 1, n - 1, n + 1, n &#125;; break; &#125; &#125; n += 2; &#125; printf("%d %d %d\n", n, n, top); FORit(Wall, Q, i, 0, top - 1)&#123; printf("%d %d %d %d\n", i-&gt;x, i-&gt;y, i-&gt;xx, i-&gt;yy); &#125; return 0;&#125; 其他解法 如图，可以将 $T$ 转化为三进制做，一位是几就把那一位对应的几面墙打开，外面的墙是用于将答案引至最终点的。 据说这样更好写？]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2019」连续子序列]]></title>
    <url>%2Fblog%2FSDOI2019-%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[一道神仙题，场上只想到一半不到…… [LOJ 3115] [Luogu 5362] 题意简述$\text{Thue−Morse}$ 序列是一个无限长度的序列 $\left\langle T_n\right\rangle$ ： $T_0 = 0$ ； $T_{2n} = T_n$ ； $T_{2n + 1} = 1 - T_n$ 。( $n &gt; 0$ ) 显然这是一个 $\text{01}$ 序列。现在给定一个 $01$ 序列 $S$ 和一个非负整数 $k$ ，求 $\text{Thue-Morse}$ 序列中有多少本质不同的连续子序列 $T$ 满足： $S$ 是 $T$ 前缀； $|T| = |S| + k$ ，其中 $|x|$ 表示 $\text{02}$ 序列 $x$ 的长度。 数据组数 $case \le 100$ ， $|S| \le 100$ ， $0\le k\le 10^{18}$ ，答案模 $10^9+9$ 。 主要思路据说 $\text{Thue-Morse}$ 序列被出到过很多找规律题里？然而本人才第一次见，充分说明本人刷题量还大大不足…… 由于这个序列是个 $\text{01}$ 序列，所以下文可能会把这个序列当成一个 $\text{01}$ 字符串。 关于 $\text{Thue-Morse}$ 序列的性质以下简称 $\text{Thue-Morse}$ 为 $\text{T.M.}$ 。 场上通过手玩样例和瞪这个序列，不难发现几个性质： 每次这个序列会将上一次生成的子串中， 1 变为 10 ， 0 变为 01 ，接入总串尾部，这我们称为一次生成。例如，一开始的串是 01 ，上一次生成的串是 1 。接着，这个串会以此变成 0110 , 01101001 , 0110100110010110 …… 除了 000 与 111 之外，其他长度不大于 $3$ 的 $\text{01}$ 字符串都是 $\text{T.M.}$ 串的子串。同时，如果一个串 $s$ 中有至少三个 1 或 0 相连，那么这个串不可能是 $\text{T.M.}$ 的子串。 对于一个长度大于 $3$ 的串 $s$ ，如果其是 $\text{T.M.}$ 串的子串，它必然是由一长度为 $\lceil\dfrac{n}{2}\rceil$ 或 $\lceil\dfrac{n + 1}{2}\rceil$ 的 $\text{T.M.}$ 串的子串 $t$ 生成的。发现并不用考虑 $t$ 是不是一次生成了 $s$ ，因为即使 $t$ 并不是一次就生成了 $s$ ，生成的 $s$ 也会是连续的。 对于上面的第三条，考虑如何通过 $s$ 反推回 $t$ 。大概思路就是将 01 写为 0 ，将 10 写为 1 ，适当在串前后补字符。 看几个例子： 011001 是如何生成的？显然这个串可以通过 010 生成。 001100 是如何生成的？考虑 1010 可以生成 10011001 ，可得 001100 也是由 1010 生成的。 10010 是如何生成的？和上面的串思路差不多，发现是由 100 生成的。 10110 是如何生成的？也和上面的串思路差不多，发现是由 001 生成的。 0011001100 是如何生成的？沿着刚刚的思路推，发现是由 101010 生成的。而 101010 是由 111 生成的。由于 111 不是 $\text{T.M.}$ 串的子串，所以 0011001100 不是 $\text{T.M.}$ 串的子串。 通过上面的几个例子，又可以大致看出一个结论： 对于一个长度大于 $3$ 的串 $s$ ，如果其是 $\text{T.M.}$ 串的子串，它必然是由且仅可能由一长度为 $\lceil\dfrac{n}{2}\rceil$ 或 $\lceil\dfrac{n + 1}{2}\rceil$ 的 $\text{T.M.}$ 串的子串 $t$ 生成的。即不可能通过两个不同的串生成出相同的串。 如何证明？ 如果串 $s$ 有子串 00 或子串 11 ，因为 0 和 1 生成一次产生的串不能是 00 或 11 ，若 $s$ 是 $\text{T.M.}$ 串的子串则 $s$ 只有一种生成方式。 如果串 $s$ 无子串 00 或子串 11 ： 若长度大于 $4$ ，则可以由 0...0 （或 1...1） 生成，但由于长度大于 $4$ ，所以 0 （或 1） 的数量不小于 $3$ ，该串不在 $\text{T.M.}$ 串中。 若长度等于 $4$ ，则 0101 由 00 、 1010 由 11 构成。 所以我们终于得出了这题最重要的一个结论。 利用该结论 dp考虑 $dp(k)$ 为，一个长为 $1$ 的 $\text{01}$ 字符串后任意插入一个长为 $k$ 的后缀，这个串是 $\text{T.M.}$ 的子串的总数。 发现这个串 $1$ 开始是 0 或是 1 答案是相同的。下文钦定这个长为 $1$ 的字符串从 0 开始。 由于这个串一定是由唯一的 $t$ 串生成的，考虑像上文一般寻找这个 $t$ 串。 如果不在串前补 1 ，则 $t$ 串是从 0 开始的一个串，后接了长度是 $\lceil\dfrac{k - 1}{2}\rceil$ 的任意后缀，即有 $dp(\lceil\dfrac{k - 1}{2}\rceil)$ 种串在 $\text{T.M.}$ 串内；如果在串前补 1 ，则 $t$ 串是从 1 开始的一个串，同理可得有 $dp(\lceil\dfrac{k}{2}\rceil)$ 种 $t$ 串。故得到 $dp(k) = dp(\lceil\dfrac{k - 1}{2}\rceil) + dp(\lceil\dfrac{k}{2}\rceil)$ 。 考虑边界状态。显然，若 $k&lt;3$ 可以预处理出来。$dp(0) = 1, dp(1) = 2, dp(2) = 3$ 。（由于不能是 000 所以 $dp(2) = 3$ ） 最后推得答案设 $Calc(S,k)$ 是询问串为 $S$ ，后缀长度为 $k$ 的答案。 类似 $|S| = 1$ 的询问，可以先确定 $S$ 串是由什么串生成而来的。同样类似 $|S| = 1$ 的询问讨论 $k$ 的取值，注意细节即可。 复杂度没仔细分析……大概一个询问是 $O(|S| + \log_2k)$ 左右？ 参考代码其实代码挺短的，但是为啥把同步关了之后在洛谷 MLE ，在 LOJ RE …… 然而即使没关同步也跑得飞快。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef unsigned long long uLL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline LL read()&#123; reg LL ans=0,f=1;reg char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=ans*10+c-'0'; return f?ans:-ans; &#125; Templ(_Tp) inline void write(_Tp x)&#123; if(x &lt; 0) return (void)(putchar('-'), write(-x)); if(x &lt; 10) return void(putchar( int(x) ^ 48 )); return (void)(write(x / 10), putchar( int(x % 10) ^ 48 )); &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 1000000009; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;#define rsiz(x) (int)(x.size())map&lt;LL, int&gt; dp;inline int moded_add(int a, int b)&#123; return (a += b) &gt;= mod ? a -= mod : a; &#125;int Function(LL k)&#123; if(dp[k]) return dp[k]; if(k &lt; 3) return k + 1; return (dp[k] = moded_add(Function(k &gt;&gt; 1), Function((k + 1) &gt;&gt; 1)));&#125;inline int Generate(const string &amp;S, string &amp;T)&#123;//判断 S 串是否能被生成并反推得可生成 S 串的 T 串 T.clear(); for(Rint i = 0, ed_i = rsiz(S); i &lt; ed_i; i += 2)&#123; if(i + 1 == ed_i) T += (S[i] == '0') ? "0" : "1"; else&#123; if(int(S[i]) ^ int(S[i + 1])) T += (S[i] == '0') ? "0" : "1"; else return 0; &#125; &#125; return 1;&#125;int Calc(const string &amp;S, const LL &amp;k)&#123; Rint siz = rsiz(S); if(siz == 1) return Function(k); if(siz == 2 &amp;&amp; k &lt; 2) return k == 1 ? (S[0] == S[1] ? 1 : 2) : 1; if(siz == 3 &amp;&amp; k == 0) return S[0] != S[1] || S[1] != S[2]; string T; Rint res = 0; if(Generate(S, T))&#123; inc(res, Calc(T, (k + (!(siz &amp; 1))) &gt;&gt; 1)); &#125; if(Generate((S[0] == '0' ? "1" : "0") + S, T))&#123; inc(res, Calc(T, (k + (siz &amp; 1)) &gt;&gt; 1)); &#125;//缩串，注意处理后缀串长度 return res;&#125;inline void sdoi_work()&#123; string S; LL k; cin &gt;&gt; S &gt;&gt; k; write(Calc(S, k)), putchar('\n');&#125;int main()&#123;// ios::sync_with_stdio(false); Rint sdoi_2019_score = read(); while(sdoi_2019_score --) sdoi_work(); return 0;&#125; 参考资料zxyoi_dreamer 的 blog]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>猜结论</tag>
        <tag>dp</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「雅礼集训2018Day2」颜色]]></title>
    <url>%2Fblog%2F%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD2018Day2%E3%80%8D%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[所以这个题场上没写出来就是完全蠢了吧…… 而且为啥加了各种优化还是跑不过最优解…… [LOJ 6499] 题意简述给定一个长 $n$ 的整数序列， $m$ 次询问，每次给定 $k_i$ 个区间 $[i_{i,j},r_{i,j}]$ ，求这些区间中一共出现了多少种不同的数字。 部分数据强制在线。 $1\le n,m,a_i,\sum k_i\le 10^5$ 。 ML : 8MiB, TL : 1000ms. 主要思路对序列分块。设分成 $K$ 块。 考虑如何记录答案。一个比较显然的想法是对每个块记录一个 bitset 来表示这个块有哪些数，询问就暴力把所有块或起来。 这样做出一个总时间复杂度 $O(n(\dfrac{nK}{\omega}+\dfrac{n}{K}))$ ，空间复杂度 $O(K\dfrac{n}{\omega})$ 的垃圾，然后跑得比暴力还慢。 然后发现可以用 $K^2$ 个 bitset 来维护两个块之间有哪些数，时间复杂度 $O(\dfrac{n^2}{K})$ 但是空间 $O(K^2\dfrac{n}{\omega})$ 。发现如果这样 $K$ 只能开几十，然后也跑得慢得一批。 考虑如何保持快速求出两个块之间答案的同时减少需要的空间。接下来就是本题最神仙的思路：可以使用一个ST表来维护两个块之间的答案。 这样总时间复杂度变为 $O(n(\dfrac{n}{\omega}+\dfrac{n}{K}))$ ，空间复杂度降至 $O(\dfrac{n}{\omega}\times K\log_2 K)$ ， $K$ 可以开到一百，手写个 bitset 大概就能过了。 参考代码主要有两个优化： 首先， $k_i$ 个区间先排个序，然后取并集，再把并集分成互不相交的若干个区间来做，具体详见代码。 其次，可以把序列中只出现一次的数丢出来做一个前缀和，不加到 bitset 里，询问一个区间把前缀和直接加到答案。这样 bitset 的长度减小到原来的 $\dfrac{1}{2}$ 。 代码可读性极差 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#define __AVX__ 1#define __AVX2__ 1#define __SSE__ 1#define __SSE2__ 1#define __SSE2_MATH__ 1#define __SSE3__ 1#define __SSE4_1__ 1#define __SSE4_2__ 1#define __SSE_MATH__ 1#define __SSSE3__ 1// #pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")//神奇优化 #include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef unsigned long long uLL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; Rint ans=0,f=1;reg char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=ans*10+c-'0'; return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 100010, MX = 100000, BC = 145, ToT = 782; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;struct my_bitset&#123; uLL val[ToT]; inline void operator |= (const my_bitset &amp;A)&#123; FOR(i, 0, ToT - 1) val[i] |= A.val[i]; &#125; inline my_bitset operator | (const my_bitset &amp;A)const&#123; my_bitset res; FOR(i, 0, ToT - 1) res.val[i] = val[i] | A.val[i]; return res; &#125; inline void set(int k)&#123; val[k &gt;&gt; 6] |= (1ull &lt;&lt; (k &amp; 63)); &#125; inline void reset()&#123; FOR(i, 0, ToT - 1) val[i] = 0; &#125; inline int count()&#123; Rint res = 0; FOR(i, 0, ToT - 1) res += __builtin_popcountll(val[i]); return res; &#125;&#125;st[BC][8], ans;//手写 bitset int n, m, datatype, a[N], bl[N], loog[BC], blo, bcnt, cnt[N], real_num[N], rcnt, S[N];int Blo_L[BC], Blo_R[BC];struct Query&#123; int l, r; inline bool operator &lt; (const Query &amp;A)const&#123; return r == A.r ? l &lt; A.l : r &lt; A.r ; &#125;&#125;Q[N], RQ[N], *rtop;int main()&#123; Rint lastans = 0; n = read(), m = read(), datatype = read(), blo = ceil(n / 140.0); Rint cb = 1, qk; FOR(i, 1, n) cnt[a[i] = read()]++; FOR(i, 1, MX) real_num[i] = cnt[i] &gt; 1 ? rcnt++ : -1; FOR(i, 1, n)&#123; S[i] = S[i - 1] + (cnt[ a[i] ] == 1); a[i] = real_num[ a[i] ]; bl[i] = (i % blo) ? cb : cb++; if(a[i] != -1) st[ bl[i] ][0].set(a[i]); &#125; //把数量是 1 的数扔出来搞个前缀和 bcnt = bl[n], cb = -1; FOR(i, 1, bcnt)&#123; Blo_L[i] = (i - 1) * blo + 1; Blo_R[i] = (i == bcnt) ? n : i * blo ; if(i == 1) continue; loog[i] = loog[i &gt;&gt; 1] + 1; &#125; FOR(i, 1, loog[bcnt])&#123; FOR(j, 1, bcnt - (1 &lt;&lt; i) + 1) st[j][i] = st[j][i - 1] | st[j + (1 &lt;&lt; (i - 1))][i - 1]; &#125; FOR(qry, 1, m)&#123; ans.reset(), qk = read(); FORit(Query, Q, i, 0, qk - 1)&#123; i-&gt;l = read(), i-&gt;r = read(); if(datatype &amp;&amp; qry &gt; 1)&#123; i-&gt;l = (i-&gt;l ^ lastans) % n + 1, i-&gt;r = (i-&gt;r ^ lastans) % n + 1; if(i-&gt;l &gt; i-&gt;r) swap(i-&gt;l, i-&gt;r); &#125; &#125; if(qk &gt; 1) sort(Q, Q + qk); *(rtop = RQ) = Q[0]; FORit(Query, Q, i, 1, qk - 1)&#123; if(rtop-&gt;r == i-&gt;r &amp;&amp; rtop-&gt;l &lt;= i-&gt;l) continue; while(rtop != RQ - 1 &amp;&amp; rtop-&gt;l &gt;= i-&gt;l) --rtop; if(rtop != RQ - 1 &amp;&amp; rtop-&gt;r &gt;= i-&gt;l) rtop-&gt;r = i-&gt;r; else *(++rtop) = *i; &#125;//把 k 个区间排序再把这些区间的并分为不交的区间 Rint l, r, lb, rb, k_k; lastans = 0; FORit(Query, 0, i, RQ, rtop)&#123; l = i-&gt;l, r = i-&gt;r, lb = bl[l], rb = bl[r]; lastans += S[r] - S[l - 1]; if(lb == rb)&#123; FOR(i, l, r) if(a[i] != -1) ans.set(a[i]); &#125; else&#123; FOR(i, l, Blo_R[lb]) if(a[i] != -1) ans.set(a[i]); FOR(i, Blo_L[rb], r) if(a[i] != -1) ans.set(a[i]); k_k = loog[rb - lb - 1]; if(lb + 1 &lt;= rb - 1) ans |= st[lb + 1][k_k] | st[rb - (1 &lt;&lt; k_k)][k_k]; &#125; &#125; printf("%d\n", lastans += ans.count()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>卡常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zory的n0ip模拟赛题解]]></title>
    <url>%2Fblog%2FZory%E7%9A%84n0ip%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在这里必须吐槽一下组题人和出题人的语文水平……愣是把这场打成了语文场…… 「CEOI2019」Cubeword (D1T3)[LOJ 3164] [CF 1192C] 居然这个题是完全机翻的……怪不得难以理解…… 题意简述给定 $n$ 个互不相同的有意义的单词( $1\le n\le 10^5$ )，每个单词都是一个长度在 $[3,10]$ 间的字符串，单词中包含小写的a到z，大写的A到Z，数字0到9。 然后，你选定正方体的棱长 $a$ ，建立一个有 $a^3$ 单位的立方体。你要在这个大正方体的 $12$ 条边上的所有单位正方体上填上一个字母（这里字母的定义是小写的a到z，大写的A到Z，数字0到9）。边上的所有单位立方体填上字母后，每条边都必须是一个有意义的长度为 $a$ 的单词。每条边可以双向阅读，即只要从一个方向读起来是有意义的单词即可。 例如上图就是 $a=6$ 时，只填了 $3$ 条边时的情况。此时已填的三条边分别可以看出单词SUBMIT(或TIMBUS)、ACCEPT(或TPECCA)、TURING(或GNIRUT)。 如果一个立方体可以通过旋转或镜像变成另一个立方体，则认为这两个立方体是不同的。 主要思路以 $S$ 表示字符集。考虑如何处理长度为 $len$ 的单词。 当一个顶点所在的三条棱的另一端的顶点都已经确定填什么字母时，显然这三条棱的填法种类是固定的。这里使用 $f(i_1,i_2,i_3)$ 来描述。显然处理单个 $f(i_1,i_2,i_3)$ 的复杂度是 $O(|S|)$ 。 枚举正方体四个互不相邻的顶点该位置填什么字母。设这四个顶点分别填 $i_1,i_2,i_3,i_4$ ，则此时整个正方体满足要求的方案数是 $f(i_1,i_2,i_3)\times f(i_2,i_3,i_4) \times f(i_3,i_4,i_1) \times f(i_4,i_1,i_2)$ 。则最终的答案就是$$\sum\limits_{i_1\in S}\sum\limits_{i_2\in S}\sum\limits_{i_3\in S}\sum\limits_{i_4\in S} f(i_1,i_2,i_3)\times f(i_2,i_3,i_4) \times f(i_3,i_4,i_1) \times f(i_4,i_1,i_2)$$ 此时总时间复杂度是 $O(8 \times |S|^4)$ ，据说会被卡常。 考虑处理答案时可以钦定 $i_1\le i_2\le i_3\le i_4$ ，处理 $f(i_1,i_2,i_3)$ 时可以钦定 $i_1\le i_2\le i_3$ 。如此常数减小，完全可过。 注意最后求答案时需要处理 $i_1,i_2,i_3,i_4$ 的出现次数。 参考代码字符串正反去重处理使用了hash。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; Rint ans=0,f=1;reg char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=ans*10+c-'0'; return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 0x3B800001 , N = 100010; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;template &lt;typename Tp&gt; inline Tp mul_(Tp t)&#123; return t; &#125;template &lt;typename Tp,typename... Args&gt; inline Tp mul_(Tp t, Args ...args)&#123; return 1ll * t * mul_(args...) % mod; &#125;const LL mod1 = 0x3B800001 , mod2 = 0x3BE00001;const int board[2][2][2] = &#123; &#123; &#123;24 , 12&#125; , &#123;12 , 4&#125; &#125; , &#123; &#123;12 , 6&#125; , &#123;4 , 1&#125; &#125; &#125;;int n , cnt[62][62] , tot[62][62][62] , ans;char str[N][13] , len[N] , rev[N];map&lt;PII,int&gt; map_;inline int chg_chr(char csp)&#123; if(isdigit(csp)) return csp - '0'; if('a' &lt;= csp &amp;&amp; csp &lt;= 'z') return csp - 'a' + 10; return csp - 'A' + 36;&#125;inline void add_str(int x)&#123; reg LL tme1 = 0,tme2 = 0; FOR(i,0,len[x] - 1) (tme1 = tme1 * 233 + str[x][i]) %= mod1 , (tme2 = tme2 * 233 + str[x][i]) %= mod2; reg PII pr = MP(int(tme1),int(tme2)); if(map_[pr]) return; map_[pr] = 1; cnt[chg_chr(str[x][0])][chg_chr(str[x][len[x] - 1])] ++; if(!rev[x])&#123; tme1 = 0 , tme2 = 0; ROF(i,len[x] - 1,0) (tme1 = tme1 * 233 + str[x][i]) %= mod1 , (tme2 = tme2 * 233 + str[x][i]) %= mod2; pr = MP(int(tme1),int(tme2)); map_[pr] = 1; cnt[chg_chr(str[x][len[x] - 1])][chg_chr(str[x][0])] ++; &#125; return;&#125;inline void work_len(int now_len)&#123; MEM(cnt , 0) , MEM(tot , 0) , map_.clear(); FOR(i,1,n) if(len[i] == now_len) add_str(i); FOR(i1,0,61) FOR(i2,i1,61) FOR(i3,i2,61) FOR(i4,0,61)&#123; inc(tot[i1][i2][i3] , mul_(cnt[i1][i4],cnt[i2][i4],cnt[i3][i4]) ); &#125; Rint pre; FOR(i1,0,61) FOR(i2,i1,61) FOR(i3,i2,61) FOR(i4,i3,61)&#123; pre = mul_(tot[i1][i2][i3] , tot[i1][i2][i4] , tot[i1][i3][i4] , tot[i2][i3][i4]); inc(ans , 1ll * pre * board[i1 == i2][i2 == i3][i3 == i4] % mod); &#125;&#125;int main()&#123; n = read(); FOR(i,1,n)&#123; scanf("%s",str[i]); len[i] = strlen(str[i]); rev[i] = 1; FOR(j,0,len[i] - 1) if(str[i][j] != str[i][len[i] - 1 - j])&#123; rev[i] = 0; break; &#125; &#125; FOR(now_len,3,10) work_len(now_len); return printf("%d\n",ans),0;&#125; 「LOJ 6364」烂柯[LOJ 6364] 居然是原创题，然而还是很难懂…… 题意简述给定一棵 $n$ 个节点的树，其中 $m$ 个节点上有柿子。在这棵树上进行博弈。双方轮流操作，每次选择一个有柿子的节点，将上面至少一个柿子移动到相邻节点，或如果这个节点是叶子节点且与开始给定的一个节点 $k$ 的距离是奇数，将上面至少一个柿子删除。每个柿子都不能移动到该柿子曾经位于的节点上。最后不能操作的人就输了。 给出树的形态和开始 $m$ 个节点上柿子的位置及个数，求双方最优策略下先手胜负。 有 $case$ 组数据， $case \le 10,\ n,a_i \le 100,\ m\le 18$ 。 主要思路数据出得如此小，简直考验选手心理。 考虑以 $k$ 为根，能删除柿子的节点是深度为奇数的叶子（深度从 $0$ 开始）。这样，在节点上删柿子可以看作在该节点下挂了一个虚节点，将柿子移动到了该节点。所以当不能移动柿子时，柿子深度均为偶数。 发现每个柿子会被移动次数的奇偶性与深度的奇偶性相同，而游戏显然不能无限进行，因此该游戏和普通阶梯博弈等价。只需将所有距离 $k$ 为奇数的节点的柿子数量异或起来（记为 $cnt$ ）， $cnt &gt; 0$ 就是先手必胜， $cnt = 0$ 就是后手必胜。 代码难度小，不放代码了。 「CF 567F」Mausoleum[CF 567F] Zory说这是签到题，然而本人场上没想出来…… 题意简述一个长为 $2n$ 的数列，其中 $1,2,\dots,n$ 各出现两次，并且是单峰的（先一段不降再一段不升，长度可以为 $0$ ）。并且给出了 $k$ 个限制，要求第 $x_i$ 个位置的数必须 $\mathtt{sign_i}$ 第 $y_i$ 个位置上的数，其中 $\mathtt{sign_i}$ 是等于、大于、小于、大于等于、小于等于中的一种。 求该数列的可能种数。 $n \le 35, k\le 100$ 。 主要思路考虑 $f(l,r)$ 表示 $[l,r]$ 中的位置还没有填数并且峰顶在 $[l,r]$ 中时的方案总数，初始时 $f(0,2n + 1) = 0$ ，我们要求的答案是 $\sum\limits_{i=1}^{2n-1}f(i,i + 1)$ （因为剩下两个 $n$ 只能填在空缺的两个位置）。 $f(l,r)$ 可以转移到 $f(l+1,r+1),f(l+2,r),f(l,r-2)$ ，注意限制，具体实现见代码，大概就是每个位置开一个 $\text{vector}$ 存一下这个位置要等于哪些位置、小于等于哪些位置、小于哪些位置，然后转移时暴力判断。 参考代码细节有点多： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 120; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;int n, k;LL f[N][N], ans;vector&lt;PII&gt; lim[N];inline int read_sign()&#123; reg char scoi[5]; scanf("%s",scoi); if(scoi[0] == '=') return 0; if(scoi[1] == '=') return scoi[0] == '&lt;' ? -1 : 1; return scoi[0] == '&lt;' ? -2 : 2;&#125;// &lt; &lt;= = &gt;= &gt;//-2 -1 0 1 2inline int check_lim(int l, int r, int x, int y)&#123; Rint xx = (x - 1 &gt; l) ? x - 1 : y + 2 , yy = (y + 1 &lt; r) ? y + 1 : x - 2; Rint opt, pos; for(auto tmp : lim[xx])&#123; opt = tmp.fir, pos = tmp.sec; if(opt == 0 &amp;&amp; pos != xx &amp;&amp; pos != yy) return 0; if(opt == -1 &amp;&amp; (l + 1 &gt; pos || pos &gt; r - 1)) return 0; if(opt == -2 &amp;&amp; (x &gt; pos || pos &gt; y)) return 0; &#125; for(auto tmp : lim[yy])&#123; opt = tmp.fir, pos = tmp.sec; if(opt == 0 &amp;&amp; pos != xx &amp;&amp; pos != yy) return 0; if(opt == -1 &amp;&amp; (l + 1 &gt; pos || pos &gt; r - 1)) return 0; if(opt == -2 &amp;&amp; (x &gt; pos || pos &gt; y)) return 0; &#125; return 1;&#125;int main()&#123; n = read(), k = read(); Rint xx, yy, opt; FOR(i, 1, k)&#123; xx = read(), opt = read_sign(), yy = read(); lim[xx].push_back(MP(opt, yy)), lim[yy].push_back(MP(-opt, xx)); &#125; f[0][n &lt;&lt; 1 | 1] = 1; ROF(i, n, 1) for(Rint l = 0, r; l &lt;= ((n - i) &lt;&lt; 1); ++l)&#123;//i : n -&gt; 1 ; l &lt;= 2 * (n - i) ; r - l = 1 + 2 * i r = (i &lt;&lt; 1 | 1) + l; if(!f[l][r]) continue; if(i == 1)&#123; if(check_lim(l, r, l + 2, r - 2)) ans += f[l][r]; continue; &#125; if(check_lim(l, r, l + 2, r - 2)) f[l + 1][r - 1] += f[l][r]; if(check_lim(l, r, l + 3, r - 1)) f[l + 2][r] += f[l][r]; if(check_lim(l, r, l + 1, r - 3)) f[l][r - 2] += f[l][r]; &#125; printf("%I64d\n",ans); return 0;&#125; 「HDU 5181」numbers[HDU 5181] 实在是搞不懂为什么一个意义简明的题面可以被解释得如此难懂，导致本人在考试结束前 1h 才看懂题面。 题意简述你手上有个栈，你要将 $1,2,\dots,n$ 依次入栈，然后有 $m$ 个限制，限制 $A_i$ 必须早于 $B_i$ 出栈，其余出栈顺序不限。求有多少种合法的进出栈序列。 $case$ 组数据， $case \le 5,n \le 300,m \le 90000$ 。 主要思路我们添加一个数 $0$ ，让 $0$ 在所有数进栈之前进栈，所有数出栈之后出栈。这样进出栈序列可以写成一棵以 $0$ 为根的树，dfs 序为 $0,1,2,\dots,n$ ，每个元素 $x$ 将在自己子树内（除自己）的所有元素进栈前进栈，出栈后出栈。 如果没有限制，显然我们可以设 $dp(x,k)$ 为考虑 $[x,n]$ 的进出栈顺序， $x$ 的子树大小为 $k$ 的种数。枚举 $x$ 除最右子树外其他子树大小和 $t$，则有 $dp(x,k) = \sum\limits_{t=1}^{k-1}dp(x,t)\times dp(x+t,k-t)$ 。 考虑限制 $(A_i,B_i)$ 在这棵数上的意义。 如果 $A_i=B_i$ ，显然直接无解。 如果 $A_i&lt;B_i$ ， $A_i$ 的子树内不能包含 $B_i$ ，即 $A_i$ 的子树大小最大是 $\operatorname{Maxsiz}(A_i)=B_i - A_i$ 。 如果 $A_i&gt;B_i$ ， $B_i$ 的子树内必须包含 $A_i$ ，即 $B_i$ 的子树大小最小是 $\operatorname{Minsiz}(B_i)=A_i - B_i + 1$ 。 仍设 $dp(x,k)$ ，此时 $k\in [\operatorname{Minsiz}(x),\operatorname{Maxsiz}(x)]$ 时才有意义。 由于某个点在挂到别的点上时，子树大小并不改变，所以可以仍如上述方法做 dp ，在处理完 $dp(x,k)$ 后再把无意义的位置设为 $0$ 即可。 复杂度 $O(n^3)$ ，完全可过。 参考代码都9102年了HDU还是不支持万能头…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//#include&lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 1000000007, N = 310; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;int n, m, f[N][N], Mins[N], Maxs[N]/*Min_siz, Max_siz*/;inline void hdu5181()&#123; n = read(), m = read(); Rint flag = 1, xx, yy; FOR(i, 0, n) Mins[i] = 0, Maxs[i] = n + 1; FOR(i, 1, m)&#123; xx = read(), yy = read(); if(xx == yy) flag = 0; else (xx &lt; yy) ? chkmin(Maxs[xx], yy - xx) : chkmax(Mins[yy], xx - yy + 1); &#125; if(!flag) return void(puts("0")); ROF(x, n, 0)&#123; FOR(siz, 1, n + 1) f[x][siz] = 0; f[x][1] = 1; FOR(siz, 2, n - x + 1) FOR(t, 1, siz - 1) inc(f[x][siz], 1ll * f[x][t] * f[x + t][siz - t] % mod); FOR(siz, 1, Mins[x] - 1) f[x][siz] = 0; FOR(siz, Maxs[x] + 1, n + 1) f[x][siz] = 0; &#125; printf("%lld\n", f[0][n + 1]);&#125;int main()&#123; Rint esac = read(); while(esac--) hdu5181(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP-S2019第一轮游记]]></title>
    <url>%2Fblog%2F20191019%2F</url>
    <content type="text"><![CDATA[最后一次 NOIP 没写游记，简直亏大了…… 早上八点半不到就到考场了，由于没有熟识的外校同学所以没找人面基（然后被某神仙怼了说初赛面什么基）。 不一会几辆大巴把就读于考场中学的考生直接送进校园内（虽然不能进考室），羡慕就读于考场中学的考生居然可以先进考场。 大概九点才进考场，一堆人拥进考室然后在十分钟后被监考员叫了出去，又过了几分钟才给进，真实今日迷惑。 发卷。居然分AB卷，难道这些鸽子愿意出两套题了？ 九点半还没发完卷……然后答题卡还印错了，开考 45 分钟左右原来的答题卡被收回去了。今年怎么出锅那么多？ 奶了硬件、计算机架构、网络与协议、 NOIP 与 CSP-J/S 关系不考，结果真就没考。 今年最难的居然是看程序写结果……考场上做得头昏。 考试结束前半分钟感觉有道题做错了，刚想改就打铃收卷了。 一出考室发现AB卷题目完全一样，只有选项位置不同。就是，这些鸽子怎么会出两套题呢！ 感觉总体难度比较简单？ 下午对了答案，发现好像最后想改的那道题本来就是对的……]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2018」未来日记]]></title>
    <url>%2Fblog%2FYnoi2018-%E6%9C%AA%E6%9D%A5%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第二道 ynoi ……前前后后不知道写了多久。 Idea：fdy Solution：fdy&amp;lxl Std：lxl&amp;csy Data：lxl “望月悲叹的最初分块” （妈呀这名字好中二啊（谁叫我要用日本轻小说中的东西命名真是作死）） 这个是这个系列中第一个被出出来的题，当时给了多校（然后的确没人做出来耶），然后被搬到了毛营（然后还是没人做出来耶） 这个是我同学出的，不是我出的（当时问我我也不会这题来着），来源似乎是有个 cdqz 高新校区的小朋友看错了一个 cf 题，然后被加强造出来的 这里就直接挂csy的题解了，和我的不太一样，但是大概思路还是差不多的，我的做法是和T1有点类似的维护方法 对这题的评价：8.5/11 —— lxl 博客 [BZOJ 5145] bzoj怎么挂了 [Luogu 4119] [HDU 6079] 我是不是什么时候也该去看看未来日记 题意简述给定一个长 $n$ 的整数序列， $1\le n,m,a_i\le 100000$ ， $m$ 个操作，操作包括： 把区间 $[l,r]$ 中所有 $x$ 变为 $y$ ； 查询区间 $[l,r]$ 中的第 $k$ 小值。 没强制在线，然而好像并没有离线做法。 主要思路首先先分块，对序列与值域都分块。以下均在块长 $O(\sqrt{n})$ 下讨论。 分块无修区间第 k 大先考虑怎么分块做无修区间第 $k$ 大。可以维护两个数组 $C[val][d]$ 表示前 $d$ 块中值为 $val$ 的数的个数， $B[valid][d]$ 表示前 $d$ 块中值在第 $valid$ 个值域块里的数的个数。 询问时维护两个临时数组 $tc[val]$ 与 $tb[valid]$ ，用来处理零碎块的贡献。 然后枚举答案位于哪一个值域块，再在这一个块里暴力枚举答案就可以 $O(\sqrt{n})$ 求出区间第 $k$ 大。 维护修改操作如何实现将 $[l,r]$ 中 $x$ 变为 $y$ 的操作？ 发现 $x$ 变为 $y$ 的操作类似并查集。维护数组 $rt[val][d]$ 表示第 $d$ 块中某个为 $val$ 的数的位置（即任意时刻保证 $a[\ rt[val][d]\ ] = val$ ，若块中无 $val$ 则将 $rt[val][d]$ 设为 $0$）。 再维护并查集数组与函数 $fth[id],find(id)$ ，将第 $d$ 块的值为 $val$ 的数挂到 $rt[val][d]$ 子树上。 此时再来考虑如何实现修改操作。 对于散块，直接将 $x$ 与 $y$ 两棵子树重置。 对于整块 $bid$ ： 如果没有 $x$ ，直接跳了； 如果没有 $y$ ，把 $rt[y][bid]$ 设为 $rt[x][bid]$； 如果有 $y$ ，把 $fth[\ rt[x][bid]\ ]$ 设为 $rt[y][bid]$。 最后把$a[\ rt[x][bid]\ ]$ 设为 $y$ ，把 $rt[x][bid]$ 设为 $0$ ，大概想一下应该可以知道为什么。 还要修改 $C[val][d]$ 与 $B[valid][d]$ ，由于只涉及 $x$ 与 $y$ 这两个值，所以暴力修改这两个数组完全可以承受。 最后修改的时间复杂度就是 $O(\sqrt{n})$ 。 参考代码内存限制 $\text{500MB}$ ，所以块长不能取 $O(\sqrt{n})$ （会爆空间），要稍微开大一点。 记得判 $x$ 与 $y$ 相等的情况，如果不判会莫名挂。 更多细节参考代码。 至于函数名称和大常数就不要在意了…… 又长又丑的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(c&gt;'9'||c&lt;'0')&#123; f^=(c=='-'); c=getchar(); &#125; for(;c&lt;='9'&amp;&amp;c&gt;='0';c=getchar()) ans=ans*10+c-'0'; return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353 , N = 100010 , SN = 260 , Vmax = 100000; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;int n,m,a[N],B[SN][SN],C[N][SN],rt[N][SN],fth[N],tb[SN],tc[N];int find(int id)&#123; return fth[id] == id ? id : fth[id] = find(fth[id]) ; &#125;//B[valid][d] : 前 d 块中在值域第 valid 块的数的数量 ; C[val][d] : 前 d 块中值为 val 数的数量 //rt[val][d] : 第 d 块中第一个为 val 的数的位置 ; fth[id] / find(id) : 序号为 id 的位置的并查集数组/函数 const int vblo = 400, vBcnt = 250;int blo,bl[N],vbl[N],Bcnt;//blo , vblo : 块长 / 值域块长 ; Bcnt , vBcnt : 块数 / 值域块数 //bl[i] : 序列中第 i 个数所在块 ; vbl[val] : 权值 val 所在的值域块#define Blo_L(bk) (((bk) - 1) * blo + 1)//块的开头/结尾 #define Blo_R(bk) (min(n , (bk) * blo))#define Vblo_L(bk) (((bk) - 1) * vblo + 1)//值域块的开头/结尾 #define Vblo_R(bk) (min(Vmax , (bk) * vblo))int Q[vblo &lt;&lt; 1] , *Qt = Q;//手开队列, Q 存 tc[val] 有值的 val (便于下次使用时更新) int Tmp[vblo &lt;&lt; 1];//Tmp 暂存修改零散块时, a[i] 值为 x 或 y 的位置 inline void a_upd(int id)&#123; return void(a[id] = a[find(id)]); &#125;//a_upd : 字面意思, 将某个位置的值(可能不是当前值)更新为当前的实际值inline void SBadd(int val)&#123; if(!tc[val]) *(++Qt) = val; ++tc[val]; ++tb[ vbl[val] ]; return;&#125;//SBadd : 零散块(Scattered Block)求 tc[val] 和 tb[valid] 时加入一个值 val inline void CBupd(int bid,int x,int y,int res)&#123; C[x][bid] -= res , C[y][bid] += res; if(vbl[x] != vbl[y]) B[ vbl[x] ][bid] -= res , B[ vbl[y] ][bid] += res; return;&#125;//CBupd : 整块(Completed Block)中修改 C[val][bid] 和 B[valid][bid] (x -&gt; y)inline void SBupd(int bid,int l,int r,int x,int y,int &amp;res)&#123; Rint *top = Tmp; FOR(i,Blo_L(bid),Blo_R(bid))&#123; a_upd(i); if(a[i] == x || a[i] == y) *(top++) = i; &#125;//改 a[i] 和把 x 与 y 子树上的点拿出来 rt[x][bid] = rt[y][bid] = 0;//将这两棵子树重置 for(Rint *i = Tmp;i != top;++i)&#123; if(l &lt;= *i &amp;&amp; *i &lt;= r &amp;&amp; a[*i] == x) a[*i] = y , ++res; if(!rt[ a[*i] ][bid]) rt[ a[*i] ][bid] = *i; fth[ *i ] = rt[ a[*i] ][bid]; &#125;//更新这两棵子树 CBupd(bid,x,y,res); return;&#125;//SBupd : 散块(Scattered Block)修改 inline void update(int l,int r,int x,int y)&#123; if(x == y) return; Rint lb = bl[l] , rb = bl[r] , res = 0; if(lb == rb)&#123; SBupd(lb,l,r,x,y,res); FOR(bid,lb + 1,Bcnt) CBupd(bid,x,y,res);//更新后续的块 return; &#125; SBupd(lb,l,Blo_R(lb),x,y,res); FOR(bid,lb + 1,rb - 1)&#123;//改整块 if(!rt[x][bid])&#123;//块里没有 x CBupd(bid,x,y,res); continue; &#125; if(!rt[y][bid])&#123;//有 x 无 y a[ rt[y][bid] = rt[x][bid] ] = y; &#125; else&#123;//有 x 有 y fth[ rt[x][bid] ] = rt[y][bid]; &#125; res += C[x][bid] - (C[x][bid - 1] + res); rt[x][bid] = 0; CBupd(bid,x,y,res); &#125; SBupd(rb,Blo_L(rb),r,x,y,res); FOR(i,rb + 1,Bcnt) CBupd(i,x,y,res);//更新后续的块 return;&#125;inline int query(int l,int r,int k)&#123; Rint lb = bl[l] , rb = bl[r] , res = 0; Rint val = 1 , lim = vBcnt; FOR(i,1,vBcnt) tb[i] = 0; while(Qt != Q) tc[*(Qt--)] = 0;//清理 tc[val] , tb[valid] if(lb == rb)&#123; FOR(i,l,r) a_upd(i) , SBadd(a[i]); while(res + tb[val] &lt; k &amp;&amp; val &lt;= lim) res += tb[val++]; lim = Vblo_R(val) , val = Vblo_L(val); while(res + tc[val] &lt; k &amp;&amp; val &lt;= lim) res += tc[val++]; return val; &#125; ROF(i,Blo_R(lb),l) a_upd(i) , SBadd(a[i]); FOR(i,Blo_L(rb),r) a_upd(i) , SBadd(a[i]); while(res + tb[val] + B[val][rb - 1] - B[val][lb] &lt; k &amp;&amp; val &lt;= lim)&#123; res += tb[val] + B[val][rb - 1] - B[val][lb] , val++; &#125; lim = Vblo_R(val) , val = Vblo_L(val); while(res + tc[val] + C[val][rb - 1] - C[val][lb] &lt; k &amp;&amp; val &lt;= lim)&#123; res += tc[val] + C[val][rb - 1] - C[val][lb] , val++; &#125; return val;&#125;int main()&#123; n = read() , m = read();// , blo = ceil(sqrt(n)); blo = ceil(pow(n,0.5204)); Rint cb = 1; FOR(i,1,n) a[i] = read() , bl[i] = cb , cb += (!(i % blo));//处理 bl[i] cb = 1; FOR(i,1,Vmax) vbl[i] = cb , cb += (!(i % vblo));//处理 vbl[val] Bcnt = bl[n]; FOR(bid,1,Bcnt)&#123; FOR(val,1,Vmax) C[val][bid] = C[val][bid - 1]; FOR(valid,1,vBcnt) B[valid][bid] = B[valid][bid - 1]; FOR(i,Blo_L(bid),Blo_R(bid))&#123; if(!rt[ a[i] ][bid]) rt[ a[i] ][bid] = i; fth[i] = rt[ a[i] ][bid]; ++B[ vbl[a[i]] ][bid] , ++C[ a[i] ][bid]; &#125; &#125;//求出初始 B[valid][d] , C[val][d] , rt[val][d] , fth[id] Rint sta,ql,qr,qx; FOR(qry,1,m)&#123; sta = read() - 1 , ql = read() , qr = read() , qx = read(); sta ? (void)(printf("%d\n",query(ql,qr,qx))) : (update(ql,qr,qx,read())); &#125; return 0;&#125; 参考资料lxl 原博客 fr200110217102 的博客]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>Ynoi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode配置二三事]]></title>
    <url>%2Fblog%2FVSCode%E9%85%8D%E7%BD%AE%E4%BA%8C%E4%B8%89%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[自从半年前装了 VS Code (下称 VSC ) 以后，只用 VSC 来写一些yml,json,html啥的。从来没有用过来写cpp。 这几天突然心血来潮，在家里配置了一下 VSC ，现在可以在家使用 VSC 写代码了。 环境准备首先将MinGW-w64中bin的位置加入环境变量里的Path里。我个人由于以前都在用 Dev-C++ 所以直接添加了Dev-C++\Dev-Cpp\MinGW64\bin。 添加后就可以在cmd中使用g++ -o test test.cpp之类的命令来编译cpp文件了。 因为要写cpp，故在 VSC 的扩展商店( Extensions )里下载扩展C/C++，这个扩展是官方的C/C++扩展。 然后把User Settings随便改一改就进入正文了。 键盘快捷键等等忘记说快捷键了。 VSC 的快捷键和 Dev-C++ 的不太一样，所以这里指出一些常用快捷键。 编辑器与窗口管理 打开 Ctrl+O 新窗口 Ctrl+Shift+N 新标签页 Ctrl+N 关闭整个 VSC 窗口 Ctrl+Shift+W 关闭当前标签页 Ctrl+W 重新打开刚刚关闭的标签页 Ctrl+Shift+T 切换标签页 Ctrl+Tab 创建一个新编辑器并将当前页面复制过去 Ctrl+\ 在前三个编辑器之间切换 Ctrl+1 2 3 将焦点编辑器移动位置 先按下 Ctrl+K 左下角出现提示后用 ← → 移动 或者可以 Ctrl+Alt+←→ 在标签页之间切换 Alt+1~9 代码编辑 搜索 Ctrl+F 替换 Ctrl+H 复制光标所在行 只需Ctrl+C 去掉行尾空格 Ctrl+K 然后 Ctrl+X 切换行注释 Ctrl+/ 代码缩进 Ctrl+[ 与 Ctrl+] 当前行上下移动 Alt+↑↓ 当前行后插入一行 Ctrl+Enter 当前行前插入一行 Ctrl+Shift+Enter 选中下一行 Ctrl+i 撤销光标上次移动 Ctrl+U 选中下个高亮的匹配项 Ctrl+D 多光标模式 Atl+鼠标单击即可在单击处创建新的光标 速览定义 Alt+F12 转到定义 F12 Zen模式(一个奇怪的类似全屏的模式) Ctrl+K 然后 Z 打开自动保存 Ctrl+Shift+P之后输入AutoSave，选中，按下回车。 打开终端 Ctrl+~ 配置 .json 文件首先我搞了个文件夹做工作区。 在工作区里新建名为.vscode的文件夹，在里面创建launch.json,tasks.json,settings.json三个.json文件。 launch.json由于学疏才浅，这个文件(包括下面的其他文件)基本是直接从参考资料里抄的…… 个人配置： 123456789101112131415161718192021222324252627&#123; "version": "0.2.0", "configurations": [ &#123; "name": "(gdb) Launch", "type": "cppdbg", "request": "launch", "program": "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe", "args": [], "stopAtEntry": false, "cwd": "$&#123;workspaceFolder&#125;", "environment": [], "externalConsole": true, "internalConsoleOptions": "neverOpen", "MIMode": "gdb", "miDebuggerPath": "gdb.exe", "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": false &#125; ], "preLaunchTask": "Compile" &#125; ]&#125; tasks.json个人配置： 123456789101112131415161718192021222324252627282930313233&#123; "version": "2.0.0", "tasks": [ &#123; "label": "Compile", "command": "g++", //本人直接用的 g++ 编译 "args": [ "$&#123;file&#125;", "-o", "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe", //这东西必须要加，不然编译出来全是a.exe "-g", "-Wall", // "-static-libgcc", // "--target=x86_64-w64-mingw", "-std=c++11", //这里用 g++11 会出现不明错误，原因未知 "-O2", "-Wl,--stack=67108864", "-DVSC_Compile", ], "type": "process", "group": &#123; "kind": "build", "isDefault": true &#125;, "presentation": &#123; "echo": true, "reveal": "always", "focus": false, "panel": "shared" &#125; &#125; ]&#125; 至今不明白为什么使用std=g++11指令会不明错误。 setting.json配置了前两个.json文件后已经可以正常F5编译运行工作区的cpp文件了。原因本人未知，或许是因为我用的是g++？ 但是基本所有教程都有配置此文件，故本人也搞了一个。 个人配置： 123456789101112&#123; "files.defaultLanguage": "cpp", "code-runner.executorMap": &#123; "c": "cd $dir &amp;&amp; clang $fileName -o $fileNameWithoutExt.exe -Wall -g -O2 -static-libgcc --target=x86_64-w64-mingw -std=c11 &amp;&amp; $dir$fileNameWithoutExt", "cpp": "cd $dir &amp;&amp; clang++ $fileName -o $fileNameWithoutExt.exe -Wall -g -O2 -static-libgcc --target=x86_64-w64-mingw -std=c++11 &amp;&amp; $dir$fileNameWithoutExt" &#125;, "code-runner.saveFileBeforeRun": true, "code-runner.preserveFocus": true, "code-runner.clearPreviousOutput": false, "code-runner.ignoreSelection": true, "C_Cpp.clang_format_sortIncludes": true&#125; 其他因为搞完前三个(其实是前两个)之后已经可以正常编译，compile_flags.txt等文件并未配置。 使用反馈可能由于是刚开始使用，感觉并没有很方便。 也许用着用着就习惯了？ 参考资料及鸣谢知乎 谭九鼎 洛谷日报 现代编辑器食用指北-VSCode]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sqrt-Tree 学习笔记]]></title>
    <url>%2Fblog%2FSqrt-Tree-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[神仙p_b_p_b发现了一种神奇的分块思路，然后发现给别人造了轮子。 给你一个长度为 $n$ 的序列 $\left\langle a _i\right\rangle^{n} _{i=1}$和一个满足结合律的运算 $\circ$ 。Sqrt Tree可以在 $O(n \log_2\log_2n)$ 的时间内预处理，并在 $O(1)$ 的时间回答计算 $a _l\circ a _{l+1}\circ\cdots\circ a _r$ 的询问。 做法描述无论如何先分块首先给原序列分块，块大小 $\sqrt{n}$ 。对于每个块，计算： $P_i$ 块内的前缀询问答案 $S_i$ 块内的后缀询问答案 再维护一个额外的数组 $\left\langle B_{i,j}\right\rangle$ 表示第 $i$ 个块到第 $j$ 个块的答案。 预处理上述的值可以在 $O(n)$ 时间与空间内完成。然后我们就可以在 $O(1)$ 时间内回答跨块的询问。然而对于整个区间都在块内部的询问需要 $O(\sqrt{n})$ 的时间才能回答。 构建一棵树可以在每个块内递归地构造上述结构来支持块内的查询。此时我们相当于建出一棵树，每个节点代表序列的一个区间。由于大小为 $k$ 的结点有 $O(\sqrt{k})$ 个子节点，于是整棵树的高度是 $O(\log_2\log_2n)$ 的。而每一层的区间总长为 $n$ ，因此建树的复杂度是 $O(n\log_2\log_2n)$ 的。 于是我们可以在 $O(\log _2\log _2n)$ 时间内回答询问。只需要找到一个区间长度最小的结点使得其能包含询问区间 $[ l,r ]$ ，这样 $[ l,r ]$ 在 $u$ 的分块区间中一定是跨块的，就可以 $O(1)$ 计算答案了。所以查询一次复杂度相当于树 $O(\log _2\log _2n)$ 。然而还能继续优化此过程。 优化询问可以二分高度，再 $O(1)$ 判断合不合法。这样复杂度就被优化到 $O(\log _2\log _2\log _2n)$ 。然而我们希望能够优化到 $O(1)$ 。 我们假设 每一个块的大小都是 $2$ 的整数幂次； 相同层的块大小相同。 此时可以将原序列补成 $2$ 的幂次，预处理复杂度不变。 现在可以快速确定一个区间是否在同一个块中了。令序列的下标从 $0$ 开始，可以发现，一个大小为 $2^k$ 的块内，元素的下标（二进制表示）仅有后 $k$ 位不同。所以，对于询问区间 $[l,r]$ ，计算 $l\ \operatorname{xor}\ r$ 的最高位的 $1$ 就可以快速确定答案区间所在的层。 如此就可以在 $O(1)$ 时间内回答询问。 单点修改Sqrt Tree 支持单点修改。 朴素实现考虑长度为 $len$ 的结点中储存的信息（分块后的前缀询问数组 $P_i$ ，后缀询问数组 $S_i$ ，块间询问数组 $B_{i,j}$），可得 $P_i$ 及 $S_i$ 中都只有 $O(\sqrt{l})$ 个元素改变，而 $B_{i,j}$ 中有 $O(l)$ 个元素改变。因此，朴素地在Sqrt Tree上修改的时间复杂度是 $O(n+\sqrt{n}+\sqrt{\sqrt{n}}+\cdots)=O(n)$ 。 使用 Sqrt Tree 替代 B 数组发现复杂度瓶颈在于更新根节点的 $\left\langle B_{i,j}\right\rangle$ 。注意到 $\left\langle B_{i,j}\right\rangle$ 的作用：表示块 $i$ 到块 $j$ 的答案。把根节点分的每个块当做一个序列，在块上再开一棵 Sqrt Tree，称作 $\text{index}$ ，长度为 $O(\sqrt{n})$ 。此时，它就可以用来充当原树根节点上的 $\left\langle B_{i,j}\right\rangle$ 的作用了，而其他非根节点仍使用 $\left\langle B_{i,j}\right\rangle$ 来维护。 所以我们可以先 $O(\sqrt{n})$ 地更新原树上的结点（根节点只更新 $P_i$ 与 $S_i$），再对 $\text{index}$ 进行更新。由于 $\text{index}$ 也是单点更新（原序列单点修改只影响一个块的答案），需要 $O(\sqrt{n})$ 的时间。所以单点修改需要 $O(\sqrt{n})$ 。 同时仍能保证询问能在 $O(1)$ 时间内回答（即使调用 $\text{index}$ 也只会调用一次）。 参考代码鸽了。 参考资料OI Wiki]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强制在线不带修区间众数相关 学习笔记]]></title>
    <url>%2Fblog%2F%E5%BC%BA%E5%88%B6%E5%9C%A8%E7%BA%BF%E4%B8%8D%E5%B8%A6%E4%BF%AE%E5%8C%BA%E9%97%B4%E4%BC%97%E6%95%B0%E7%9B%B8%E5%85%B3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[区间众数是和分块脱不了干系的。 [BZOJ 2724][Violet 6]蒲公英 草怎么是权限题 [Luogu 4168][Violet]蒲公英 题意简述给出一个长为$n$的数列，$m$次询问一段区间内最小的区间众数，强制在线。 $1\leq l\leq r\leq40000,m\leq50000,1\leq a_i\leq 10^9$。 主要思路1引理1设$\operatorname{mode}(A)$为可重集合$A$的最小众数，则有$\operatorname{mode}(A\cup B)\in\operatorname{mode}(A)\cup B$。 引理1的证明几乎是显然的。令$t=\operatorname{mode}(A\cup B)$，若$t$既不是$\operatorname{mode}(A)$，也不属于$B$，则$t$的出现次数就是在$A$中出现的次数。而这个次数应是不大于$\operatorname{mode}(A)$出现的次数的，出现矛盾。故引理1成立。 算法离散化，分块，块大小$S$。 对于询问$[l,r]$，根据引理1，答案只可能是 $l,r$间所有完整块的最小众数 或 不完整块中出现的数。 对于一段完整块的最小众数$f[a][b]$，可以预处理，选定最左的块$a$后$O(n)$求出$f[a][i]$，其中$a\leq i$，总预处理复杂度$O(n\lfloor\frac{n}{S}\rfloor)$。 对于不完整的块，我们可以求出每种数在$[l,r]$中出现的次数。 怎么求出某种数在$[l,r]$中出现的次数？我们可以把每种数出现的位置按顺序丢到一个$\text{vector}$里，查找时找到第一个在$l$或其后出现的位置和最后一个在$r$或其前出现的位置即可，每次查询复杂度$O(\log_2cnt[a_i])=O(\log_2n)$。 所以每次询问区间$[l,r]$时间复杂度$O(Slog_2n)$。 平衡一下，块大小取$\sqrt{\frac{n}{\log_2n}}$，总复杂度$O(n\sqrt{n\log_2n})$（$n,m$同阶）。 若本人推错了请指出 优化有没有办法把这个$\sqrt{\log_2n}$去掉呢？ 观察发现这个常数来自求某种数在$[l,r]$中出现的次数。 设$Sum(i,x)$表示$[1,i]$间$x$的个数，我们需要回答的就是$Sum(r,x)-Sum(l-1,x)$。 处理$C[b][x]$表示第$1$到第$b$块中$x$出现的次数，需要$O(n\lfloor\frac{n}{S}\rfloor)$的空间与时间。 处理$A[b][i][x]$表示从第$b$块开头开始的$i$个数中$x$的出现次数。因为每个块最多只有$S$种数，故复杂度$O(S^2\lfloor\frac{n}{S}\rfloor)=O(nS)$。 然后就可以$O(1)$地回答$Sum(i,x)$，可以将块大小设为$\sqrt{n}$，时空复杂度均为$O(n\sqrt{n})$（$n,m$同阶）。 参考代码然后你就会发现这玩意难写得很，所以我放弃了…… 主要思路2我们希望找到一个空间可以较小，且码量也较小的方法。 仍然离散化分块，块大小$S$，仍求出$f[a][b]$为一段完整块的最小众数，并附带求出该数的出现次数$num[a][b]$。 仍把每种数$x$的出现位置开一个$\text{vector}$（名$pos[x]$）按顺序存起来，同时对于数列中每个位置标记该位置在$\text{vector}$中的下标$id[i]$。 什么？没看懂？那就多看几遍 算法设询问区间为$[l,r]$，包含完整块$[a,b]$。 首先$mode=f[a][b]$，出现次数$cnt=num[a][b]$。 然后处理两边的不完整块。 例如，对于$l$到块$a-1$的结尾处这部分： 假设处理到位置$i$，$a_i=x$。 那么，若$pos[x][id[i]+cnt]$仍存在且不在$r$的右边，显然可以更新$mode=x,cnt++$。 对于块$b+1$开头到$r$的这一部分，同理，只不过改成看$pos[x][id[i]-cnt]$是否不在$l$的左边。 可以发现，$cnt$最多更新$2S$次，若超过$2S$次则说明有数$x$在这段完整块$[a,b]$中出现次数大于$num[a][b]$，固然矛盾。所以每次询问时间复杂度$O(S)$。 预处理时间复杂度$O(n\lfloor\frac{n}{S}\rfloor)$，询问总时间复杂度$O(nS)$，故$S$取$\sqrt{n}$时复杂度降至最优$O(n\sqrt{n})$。 而空间复杂度，我们发现无论是$f,num$，还是$id,pos$，总共都只有$O(n)$的大小。 什么？没看懂？那就看看代码吧 参考代码由于STL依赖症心血来潮，直接写了个$\text{pair}$…… 码量确实不大…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define pb push_back #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 100010 , SN = 320; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;#define rsiz(h) ((int)((h)-&gt;size()))int n,blo,ary[N],a[N],bl[N],id[N],cnt[N],m;vector&lt;int&gt; pos[N];PII f[SN][SN];inline void checkR(int l,int r,int R,PII &amp;res)&#123; Rint ans = res.sec; FOR(i,l,r)&#123; while(id[i] + ans &lt; rsiz(pos + a[i]) &amp;&amp; pos[a[i]][id[i] + ans] &lt;= R) ++ans; if(ans &gt; res.sec) res = MP(a[i],ans); else if(a[i] &lt; res.fir &amp;&amp; id[i] + ans &lt;= rsiz(pos + a[i]) &amp;&amp; pos[a[i]][id[i] + ans - 1] &lt;= R) res.fir = a[i]; &#125; return;&#125;inline PII query(int l,int r)&#123; Rint lb = bl[l] , rb = bl[r] , ans; reg PII res = (rb - lb &lt; 2) ? MP(a[l],1) : f[lb + 1][rb - 1]; if(lb == rb)&#123; checkR(l,r,r,res); return res; &#125; checkR(l,blo * lb,r,res); ans = res.sec; FOR(i,blo*(rb-1)+1,r)&#123; while(id[i] - ans &gt;= 0 &amp;&amp; pos[a[i]][id[i] - ans] &gt;= l) ++ans; if(ans &gt; res.sec) res = MP(a[i],ans); else if(a[i] &lt; res.fir &amp;&amp; id[i] - ans &gt;= -1 &amp;&amp; pos[a[i]][id[i] - ans + 1] &gt;= l) res.fir = a[i]; &#125; return res;&#125;int main()&#123; n = read() , blo = ceil(sqrt(n)) , m = read(); Rint c = 1; FOR(i,1,n)&#123; ary[i] = a[i] = read(); bl[i] = c; if(!(i % blo)) ++c; &#125; sort(ary + 1,ary + n + 1); Rint siz = unique(ary + 1,ary + n + 1) - ary - 1 , l , r , lastans = 0; FOR(i,1,n)&#123; a[i] = lower_bound(ary + 1,ary + siz + 1,a[i]) - ary; pos[a[i]].pb(i); id[i] = rsiz(pos + a[i]) - 1; &#125; FOR(i,1,bl[n])&#123; MEM(cnt,0); reg PII res = MP(0,0); FOR(j,blo * (i - 1) + 1,n)&#123; ++cnt[a[j]]; if(cnt[a[j]] &gt; res.sec) res = MP(a[j],cnt[a[j]]); else if(cnt[a[j]] == res.sec &amp;&amp; a[j] &lt; res.fir) res.fir = a[j]; f[i][bl[j]] = res; &#125; &#125; FOR(i,1,m)&#123; l = (read() + lastans - 1) % n + 1 , r = (read() + lastans - 1) % n + 1; if(l &gt; r) swap(l,r); printf("%d\n",lastans = ary[query(l,r).fir]); &#125; return 0;&#125; 扩展[Ynoi2019模拟赛]Yuno loves sqrt technology III 这题是求区间众数的在区间中的出现次数。做法同上主要思路2（实际上$\text{lxl}$可能是国内第一个写这个思路的人？）。 注意卡常。 留下了卡不进总时间6.5s的泪水…… 参考代码最快的一次…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define pb push_back #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 500005 , SN = 1505; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;#define rsiz(h) ((int)((h)-&gt;size()))int n,blo,ary[N],a[N],bl[N],id[N],cnt[N],m;vector&lt;int&gt; pos[N];int f[SN][SN];inline int query(int l,int r)&#123; Rint lb = bl[l] , rb = bl[r] , ans = f[lb + 1][rb - 1]; if(!ans) ans = 1; if(lb == rb)&#123; FOR(i,l,r)&#123; while(id[i] + ans &lt; rsiz(pos + a[i]) &amp;&amp; pos[a[i]][id[i] + ans] &lt;= r) ++ans; &#125; return ans; &#125; FOR(i,l,blo * lb)&#123; while(id[i] + ans &lt; rsiz(pos + a[i]) &amp;&amp; pos[a[i]][id[i] + ans] &lt;= r) ++ans; &#125; FOR(i,blo*(rb-1)+1,r)&#123; while(id[i] - ans &gt;= 0 &amp;&amp; pos[a[i]][id[i] - ans] &gt;= l) ++ans; &#125; return ans;&#125;int main()&#123; n = read() , m = read() ; blo = ceil(sqrt(n)); Rint c = 1; FOR(i,1,n)&#123; ary[i] = a[i] = read(); bl[i] = c; if(!(i % blo)) ++c; &#125; sort(ary + 1,ary + n + 1); Rint siz = unique(ary + 1,ary + n + 1) - ary - 1 , l , r , lastans = 0; FOR(i,1,n)&#123; a[i] = lower_bound(ary + 1,ary + siz + 1,a[i]) - ary; pos[a[i]].pb(i); id[i] = rsiz(pos + a[i]) - 1; &#125; FOR(i,1,bl[n])&#123; MEM(cnt,0); FOR(j,i,bl[n])&#123; f[i][j] = f[i][j - 1]; FOR(k,(j - 1) * blo + 1,min(j * blo,n))&#123; f[i][j] = max(f[i][j] , ++cnt[a[k]]); &#125; &#125; &#125; FOR(i,1,m)&#123; l = read() ^ lastans , r = read() ^ lastans; if(l &gt; r) swap(l,r); printf("%d\n",lastans = query(l,r)); &#125; return 0;&#125; 参考区间众数解题报告 - 陈立杰 OldDriverTree(lxl)的博客 Tiger0132 Ynoi2019T3题解]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数列分块入门」系列]]></title>
    <url>%2Fblog%2F%E3%80%8C%E6%95%B0%E5%88%97%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8%E3%80%8D%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[谈到分块，不得不说说 $\text{hzwer}$ 学长的「数列分块入门」系列。 若未特别指出$\text{ML}$或$\text{TL}$，则$\text{ML:256MB,TL:500ms}$。 数列分块入门 1[LOJ 6277] 题意给出一个长为$n$的数列，有$n$个操作，操作涉及区间加法，单点查值。 $1\leq l\leq r\leq n\leq 50000$，输入的所有数均为$\text{int}$范围的整数。 $\text{TL:100ms}$ 思路啥？这题还要思路？ 代码码风丑见谅： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 50010 , SN = 230; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;int n,blo;int a[N],bl[N],tag[SN];inline void update(int l,int r,int x)&#123; Rint tem = min(bl[l] * blo , r); FOR(i,l,tem) a[i] += x; if(bl[l] != bl[r]) FOR(i,(bl[r] - 1) * blo + 1,r) a[i] += x; FOR(i,bl[l] + 1,bl[r] - 1) tag[i] += x; return;&#125;int main()&#123; n = read(),blo = sqrt(n); FOR(i,1,n) a[i] = read(); FOR(i,1,n) bl[i] = (i - 1)/blo + 1; Rint opt,l,r,c; FOR(i,1,n)&#123; opt = read() , l = read() , r = read() , c = read(); opt ? (void)(printf("%d\n",a[r] + tag[bl[r]])) : update(l,r,c); &#125; return 0;&#125; 数列分块入门 2[LOJ 6278] 题意给出一个长度为$n$的数列，以及$n$个操作，操作涉及区间加法，询问区间内小于某个值$x$的元素个数。 $1\leq l\leq r\leq n\leq 50000$，输入的所有数均为$\text{int}$范围的整数。 思路将数列分成长为$S$的块。 修改就对整块打$\text{tag}$，对不完整的块暴力修改、排序，复杂度$O(\lfloor\frac{n}{S}\rfloor+S\log_2S)$。 询问就对整块$\text{lower_bound}$，对不完整的块暴力，复杂度$O(\lfloor\frac{n}{S}\rfloor\log_2S+S)$。 然后平衡一下，$S$ 取$\sqrt{n}$就好了。 代码こ↑こ↓ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 50010 , SN = 250; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;int n,blo,bl[N],bid[SN];LL a[N],b[N],tag[SN];inline int query(int l,int r,LL val)&#123; Rint lb = bl[l] , rb = bl[r] , res = 0; if(lb == rb)&#123; FOR(i,l,r) res += a[i] &lt; (val - tag[lb]); return res; &#125; FOR(i,lb + 1,rb - 1) res += lower_bound(b + bid[i - 1] + 1,b + bid[i] + 1,val - tag[i]) - b - bid[i - 1] - 1; FOR(i,l,bid[lb]) res += a[i] &lt; (val - tag[lb]); ROF(i,r,bid[rb - 1] + 1) res += a[i] &lt; (val - tag[rb]); return res;&#125;inline void update(int l,int r,LL val)&#123; Rint lb = bl[l] , rb = bl[r]; if(lb == rb)&#123; FOR(i,bid[lb - 1] + 1,bid[lb])&#123; if(l &lt;= i &amp;&amp; i &lt;= r) a[i] += val; b[i] = a[i]; &#125; return sort(b + bid[lb - 1] + 1,b + bid[lb] + 1); &#125; FOR(i,lb + 1,rb - 1) tag[i] += val; FOR(i,bid[lb - 1] + 1,bid[lb])&#123; if(l &lt;= i) a[i] += val; b[i] = a[i]; &#125; FOR(i,bid[rb - 1] + 1,bid[rb])&#123; if(i &lt;= r) a[i] += val; b[i] = a[i]; &#125; return sort(b + bid[lb - 1] + 1,b + bid[lb] + 1),sort(b + bid[rb - 1] + 1,b + bid[rb] + 1);&#125;int main()&#123; n = read() , blo = sqrt(n); FOR(i,1,n) b[i] = a[i] = read(); Rint opt,l,r,c = 1; FOR(i,1,n - 1)&#123; bl[i] = c; if(!(i % blo)) bid[c++] = i; &#125; bl[n] = c , bid[c] = n; FOR(i,1,c) sort(b + bid[i - 1] + 1,b + bid[i] + 1); FOR(i,1,n)&#123; opt = read() , l = read() , r = read() , c = read(); if(opt) printf("%d\n",query(l,r,1ll * c * c)); else update(l,r,1ll * c); &#125; return 0;&#125; 数列分块入门 3[LOJ 6279] 题意给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，询问区间内$x$的前驱。 $1\leq l\leq r\leq n\leq 100000$，输入的所有数均为$\text{int}$范围的整数。 $\text{TL:1500ms}$ 思路基本同上「数列分块入门 2」，但是不能直接排序（复杂度$O(n\sqrt{n}\log_2n)$）而是需要用一些数据结构存储每个块的信息。 本人代码使用$set$存储每个块的信息。 微妙地调整块大小应该可以过吧……本人代码采用的是$S=n^{0.612}$ 代码こ↑こ↓ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 100010 , SN = 330; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;int n,blo,a[N],bl[N],bid[SN],tag[SN];set&lt;int&gt; s[SN];inline void update(int l,int r,int v)&#123; Rint lb = bl[l] , rb = bl[r]; if(lb == rb)&#123; FOR(i,l,r)&#123; s[lb].erase(a[i]); a[i] += v; s[lb].insert(a[i]); &#125; return; &#125; FOR(i,lb + 1,rb - 1) tag[i] += v; FOR(i,l,bid[lb]) s[lb].erase(a[i]),a[i] += v,s[lb].insert(a[i]); ROF(i,r,bid[rb-1]+1) s[rb].erase(a[i]),a[i] += v,s[rb].insert(a[i]); return;&#125;inline int query(int l,int r,int v)&#123; Rint lb = bl[l] , rb = bl[r] , ans = INT_MIN; if(lb == rb)&#123; FOR(i,l,r) if(a[i] + tag[lb] &lt; v &amp;&amp; ans &lt; a[i] + tag[lb]) ans = a[i] + tag[lb]; return ans &gt; INT_MIN ? ans : -1 ; &#125; FOR(i,lb + 1,rb - 1)&#123; reg auto it = s[i].lower_bound(v - tag[i]);//set&lt;int&gt;::iterator if(it == s[i].begin()) continue; --it; if(ans &lt; *it + tag[i]) ans = *it + tag[i]; &#125; FOR(i,l,bid[lb]) if(a[i] + tag[lb] &lt; v &amp;&amp; ans &lt; a[i] + tag[lb]) ans = a[i] + tag[lb]; ROF(i,r,bid[rb-1]+1) if(a[i] + tag[rb] &lt; v &amp;&amp; ans &lt; a[i] + tag[rb]) ans = a[i] + tag[rb]; return ans &gt; INT_MIN ? ans : -1;&#125;int main()&#123; n = read() , blo = ceil(pow(n,0.612)); FOR(i,1,n) a[i] = read(); Rint opt,l,r,c = 1; FOR(i,1,n - 1)&#123; bl[i] = c; if(!(i % blo)) bid[c++] = i; &#125; bl[n] = c , bid[c] = n; FOR(i,1,n) s[bl[i]].insert(a[i]); FOR(i,1,n)&#123; opt = read() , l = read() , r = read() , c = read(); if(opt) printf("%d\n",query(l,r,c)); else update(l,r,c); &#125; return 0;&#125; 数列分块入门 4[LOJ 6280] 题意给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，区间求和并对$c$取模(每个询问给出)。 $1\leq l\leq r\leq n\leq 50000,c&gt;0$,输入的所有数均为$\text{int}$范围的整数。 思路经典问题，经典中的经典。 代码こ↑こ↓ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 50010 , SN = 250; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;int n,blo,bl[N],bid[SN];LL a[N],tag[SN],sum[SN];int query(int l,int r,LL p)&#123; Rint lb = bl[l] , rb = bl[r]; reg LL ans = 0; if(lb == rb)&#123; FOR(i,l,r) ans += a[i] + tag[lb]; return (int)(((ans %= (p + 1)) &lt; 0) ? ans + p + 1 : ans); &#125; FOR(i,lb + 1,rb - 1) ans += sum[i]; FOR(i,l,bid[lb]) ans += a[i] + tag[lb]; ROF(i,r,bid[rb-1]+1) ans += a[i] + tag[rb]; return (int)(((ans %= (p + 1)) &lt; 0) ? ans + p + 1 : ans);&#125;inline void update(int l,int r,LL val)&#123; Rint lb = bl[l] , rb = bl[r]; if(lb == rb)&#123; FOR(i,l,r) a[i] += val , sum[lb] += val; return; &#125; FOR(i,lb + 1,rb - 1) tag[i] += val , sum[i] += val * blo; FOR(i,l,bid[lb]) a[i] += val , sum[lb] += val; ROF(i,r,bid[rb-1]+1) a[i] += val , sum[rb] += val; return;&#125;int main()&#123;// FILE("a13"); n = read() , blo = sqrt(n); FOR(i,1,n) a[i] = read(); Rint opt,l,r,c = 1; FOR(i,1,n - 1)&#123; bl[i] = c; if(!(i % blo)) bid[c++] = i; &#125; bl[n] = c,bid[c] = n; FOR(i,1,n) i[bl][sum] += a[i]; FOR(i,1,n)&#123; opt = read() , l = read() , r = read() , c = read(); opt ? (void)(printf("%d\n",query(l,r,(LL)c))) : update(l,r,(LL)c); &#125; return 0;&#125; 数列分块入门 5[LOJ 6281] 题意给出一个长为$n$的数列，以及$n$个操作，操作涉及区间开方，区间求和。 $1\leq l\leq r\leq n\leq 50000$,输入的所有数均为$\text{int}$范围的自然数。 思路什么这不是线段树题吗 代码只写了线段树的代码，就不放了…… 数列分块入门 6[LOJ 6282] 题意给出一个长度为$n$的数列，以及$n$个操作，操作涉及单点插入，单点查询。 $1\leq l\leq r\leq n\leq 100000$,输入的所有数均为$\text{int}$范围的整数。 输入输出： 第一行，一个数字$n$。 第二行$n$个数字，第$i$个数字为$a_i$。 接下来$n$行操作，每组操作输入四个数字$opt,l,r,c$。 若$opt=0$，表示在第$l$个数字前插入数字$r$。 若$opt=1$，表示询问$a_r$的值。 对每组$opt=1$的询问，输出一行一个整数，为$a_r$的值。 什么？你问我c干啥用的？我也想知道 思路先把原序列分块，块大小$S$，块数$Bl$。 使用$\text{vector}$存储每一块信息。插入时暴力插入，将该块后面的元素都后移一位，复杂度$O(S)$；查询也是暴力，复杂度$O(Bl)$。 但是可能在一个块里有大量插入，此时该块大小将远远超过$S$，复杂度退化。 可以当某个块过大时，将该块分为两个，暴力重构，时间复杂度$O(n)$（若使用链表，可以锐减至$O(S+Bl)$。） 也可以考虑每$m$次插入后对序列进行重构，复杂度也为$O(n)$。 喂这种要”保持平衡”的思想不是和平衡树差不多吗你怎么不写棵平衡树 代码本人采用的是$S=\sqrt{n}$，在块大小不小于$2S$时将该块分为两个，暴力拆块，复杂度$O(n)$。 由于最多只会拆$\sqrt{n}$次块，拆块复杂度$O(n\sqrt{n})$，可以通过此题。 指针恐惧症慎入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define pb push_back #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 200010 , SN = 650; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;int n,blo,bn;vector&lt;int&gt;a[SN];#define rsiz(h) ((int)((h)-&gt;size()))inline void update(int t,int val)&#123;//在序号t的数后面插入数val reg vector&lt;int&gt; *k = a; while(rsiz(k + 1) &lt;= t &amp;&amp; (k - a) &lt; bn) ++k,t -= rsiz(k); ++k; if((k - a) &gt; bn) return; if(t &lt; 0) return; k -&gt; insert((k -&gt; begin()) + t,val); if(rsiz(k) &gt;= 2 * blo)&#123; ROF(i,bn,k - a + 1) a[i + 1] = a[i]; (k + 1) -&gt; clear(); FOR(i,blo,rsiz(k) - 1) (k + 1) -&gt; pb((*k)[i]); while(rsiz(k) &gt; blo) k -&gt; erase((k -&gt; end()) - 1); ++bn; &#125; return;&#125;inline int query(int t)&#123;//查找序号为t的数 --t; reg vector&lt;int&gt; *k = a; while(rsiz(k + 1) &lt;= t &amp;&amp; (k - a) &lt; bn) ++k,t -= rsiz(k); ++k; if((k - a) &gt; bn) return 0; if(t &lt; 0) return 0; return (*k)[t];&#125;int main()&#123; n = read() , blo = sqrt(n); Rint opt,l,r = 0,c = 1; bn = ceil(sqrt(n)); FOR(i,1,n)&#123; a[c].pb(read()); ++r; if(r == blo) ++c,r = 0; &#125; FOR(i,1,n)&#123; opt = read() , l = read() , r = read() , read(); opt ? (void)(printf("%d\n",query(r))) : update(l - 1,r);// printf("Siz : "); FOR(i,1,bn) printf("%d ",rsiz(a + i)); puts("");// FOR(i,1,bn)&#123; printf("a[%d] : ",i); FOR(j,0,rsiz(a + i) - 1) printf("%d ",a[i][j]); puts(""); &#125; &#125; return 0;&#125; 数列分块入门 7[LOJ 6283] 题意给出一个长为$n$的数列，以及$n$操作，操作涉及区间加法，区间乘法，单点询问。 $1\leq l\leq r\leq n\leq 100000$,输入的所有数均为$\text{int}$范围的整数，询问对$10007$取模。 所以为什么不是查询区间和 思路右转线段树模板，请 反正分块的思路基本相同，只是tag不用下传 代码只写了线段树，所以不贴了。 数列分块入门 8[LOJ 6284] 题意给出一个长为$n$的数列，以及$n$个操作，操作涉及区间询问等于一个数 的元素，并将这个区间的所有元素改为$c$。 $1\leq l\leq r\leq n\leq 100000$,输入的所有数均为$\text{int}$范围的整数。 输入输出： 第一行，一个数字$n$。 第二行，$n$个数字，第$i$个为$a_i$。 接下来输入$n$行询问，每行三个数字$l,r,c$。 表示先查询位于$[l,r]$的数字有多少个是$c$，再将$[l,r]$内的数字都改为$c$。 数据不随机。 思路分块，块大小$\sqrt{n}$，每块记录一下是否全部相等，若是则$O(1)$处理，不是则暴力扫一遍。不完整的块也暴力处理。 这样复杂度看上去最坏是$O(n)$的。然而，当经过了一次$O(n)$的询问后，几乎所有块都变得相等了。而一次操作最多将$2$个块变得不等，所以至少需要$\sqrt{n}$次操作后才可能再次出现$O(n)$的最坏复杂度。综合一下，可得复杂度是$O(n\sqrt{n})$，可以通过此题。 本人的说法可能不够严谨，希望有人可以提供更好的解释方法！ 代码こ↑こ↓ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 100010 , SN = 450; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;int n,blo,a[N],sam[SN],bl[N],bid[SN];inline void update(int b)&#123;//更新某个块状态 if(!sam[b]) return; FOR(i,bid[b - 1] + 1,bid[b] - 1) a[i] = b[bid][a]; return (void)(sam[b] = 0);&#125;inline int slove(int l,int r,int val)&#123; Rint lb = bl[l] , rb = bl[r] , res = 0; if(lb == rb)&#123; update(lb); FOR(i,l,r) (a[i] == val) ? (++res) : (a[i] = val) ; sam[lb] = (l == bid[lb - 1] + 1 &amp;&amp; r == bid[lb]); return res; &#125; update(lb); ROF(i,bid[lb],l) (a[i] == val) ? (++res) : (a[i] = val) ; sam[lb] = (l == bid[lb - 1] + 1); update(rb); FOR(i,bid[rb-1]+1,r) (a[i] == val) ? (++res) : (a[i] = val) ; sam[rb] = (r == bid[rb]); FOR(i,lb + 1,rb - 1)&#123; if(sam[i])&#123; (i[bid][a] == val) ? (res += blo) : (i[bid][a] = val); continue; &#125; FOR(j,bid[i - 1] + 1,bid[i]) (a[j] == val) ? ++res : a[j] = val ; sam[i] = 1; &#125; return res;&#125;int main()&#123; n = read() , blo = sqrt(n); Rint l,r,c = 1; FOR(i,1,n - 1)&#123; a[i] = read() , bl[i] = c; if(!(i % blo)) sam[c] = 1,bid[c++] = i; &#125; a[n] = read() , bl[n] = c , bid[c] = n; FOR(i,1,c) FOR(j,bid[i-1] + 1,bid[i] - 1) if(a[j] != i[bid][a])&#123; sam[i] = 0; break; &#125; FOR(i,1,n)&#123; l = read() , r = read() , c = read(); printf("%d\n",slove(l,r,c)); &#125; return 0;&#125; 加强啊说起来本题还可以加强的来着。 给出一个长为$n$的数列，以及$n$个操作，操作涉及区间询问等于一个数 的元素，或将这个区间的所有元素改为$c$。 具体地： 第一行，一个整数$n$。 第二行，$n$个整数，第$i$个为$a_i$。 接下来输入$n$行询问，每行四个整数$opt,l,r,c$。 若$opt=0$，表示将$[l,r]$内的所有数改为$c$。 若$opt=1$，输出一行一个整数，表示$[l,r]$内有多少个数是$c$。 数据不随机。 $1\leq l\leq r\leq n\leq 100000$，所有输入的数均在$\text{int}$范围内，不强制在线。 $1\leq l\leq r\leq n\leq 50000$，所有输入的数均在$\text{int}$范围内，强制在线。 $\text{TL:1000ms}$ 思路好像和原题没什么关系了…… 不强制在线的话，可以先离散化，然后分成$\sqrt{n}$大小的块。 每个块用$O(n)$的空间存储每种数的数量，如果全部相同则打$\text{tag}$。 首先，单点修改是$O(1)$的（某种数的数量$+1$，某种数的数量$-1$），整块修改也是$O(1)$的（打$\text{tag}$）。 不完整的块的修改则是$O(\sqrt{n})$的（可能需要拆$\text{tag}$，拆掉后相当于整个块进行修改，也是$O(\sqrt{n})$的）。 查询时，显然对于整块是$O(1)$的，对于不完整的块暴力是$O(\sqrt{n})$的。 所以时间复杂度和空间复杂度都是$O(n\sqrt{n})$，可以通过此题。 强制在线的话，可以用$\text{map}$来使空间复杂度保持$O(n\sqrt{n})$，而时间复杂度将变为$O(n\sqrt{n}\log_2n)$，大概应该或许能通过此题。 因加强版未找到题目，对于强制在线的时间复杂度，若能在保证空间的情况下做到更优，欢迎在评论区指出或私信本人！ 代码こ↑こ↓ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 100010 , SN = 280; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;int n,blo,a[N],b[N &lt;&lt; 1],bl[N],bid[SN],siz,sam[SN];int num[SN][N &lt;&lt; 1],ql[N],qr[N],qc[N];inline void check(int b)&#123; if(!sam[b]) return; Rint v = b[bid][a]; FOR(i,bid[b - 1] + 1,bid[b] - 1) --num[b][a[i]] , a[i] = v , ++num[b][v]; return;&#125;inline int query(int l,int r,int val)&#123; Rint lb = bl[l] , rb = bl[r] , res = 0; check(lb); if(lb == rb)&#123; FOR(i,l,r) res += (a[i] == val); return res; &#125; check(rb); FOR(i,l,bid[lb]) res += (a[i] == val); ROF(i,r,bid[rb-1]+1) res += (a[i] == val); FOR(i,lb + 1,rb - 1) res += sam[i] ? ((i[bid][a] == val) ? blo : 0) : num[i][val] ; return res;&#125;inline void update(int l,int r,int val)&#123; Rint lb = bl[l] , rb = bl[r]; if(lb == rb)&#123; if(sam[lb])&#123; FOR(i,bid[lb - 1] + 1,bid[lb])&#123; --num[lb][a[i]]; a[i] = (l &lt;= i &amp;&amp; i &lt;= r) ? val : lb[bid][a] ; ++num[lb][a[i]]; &#125; return (void)(sam[lb] = (l == bid[lb - 1] + 1 &amp;&amp; r == bid[lb])); &#125; FOR(i,l,r) --num[lb][a[i]] , a[i] = val , ++num[lb][a[i]]; return (void)(sam[lb] = (l == bid[lb - 1] + 1 &amp;&amp; r == bid[lb])); &#125; if(sam[lb])&#123; FOR(i,bid[lb - 1] + 1,bid[lb]) --num[lb][a[i]] , a[i] = ((l &lt;= i) ? val : lb[bid][a]) , ++num[lb][a[i]]; &#125; else FOR(i,l,bid[lb]) --num[lb][a[i]] , a[i] = val , ++num[lb][val]; if(sam[rb])&#123; FOR(i,bid[rb - 1] + 1,bid[rb]) --num[rb][a[i]] , a[i] = ((i &lt;= r) ? val : rb[bid][a]) , ++num[rb][a[i]]; &#125; else FOR(i,bid[rb-1]+1,r) --num[rb][a[i]] , a[i] = val , ++num[rb][val]; sam[lb] = (l == bid[lb - 1] + 1) , sam[rb] = (r == bid[rb]); FOR(i,lb + 1,rb - 1)&#123; sam[i] = 1; --num[i][i[bid][a]] , i[bid][a] = val , ++num[i][val]; &#125; return;&#125;int main()&#123; n = read() , blo = ceil(pow(n,0.514)) , siz = n;// return printf("%d %d\n",blo,(int)(ceil(n / (DB)blo))),0; Rint t = 1; FOR(i,1,n - 1)&#123; b[i] = a[i] = read() , bl[i] = t; if(!(i % blo)) bid[t++] = i; &#125; b[n] = a[n] = read() , bl[n] = t , bid[t] = n; FOR(i,1,n) ql[i] = read() , qr[i] = read() , qc[i] = read() , b[++siz] = qc[i]; sort(b + 1,b + siz + 1); siz = unique(b + 1,b + siz + 1) - b - 1; FOR(i,1,n)&#123; a[i] = lower_bound(b + 1,b + siz + 1,a[i]) - b; qc[i] = lower_bound(b + 1,b + siz + 1,qc[i]) - b; t = bl[i]; num[t][a[i]]++; if(i == bid[t] &amp;&amp; num[t][a[i]] == bid[t] - bid[t - 1]) sam[t] = 1; &#125; FOR(i,1,n)&#123; printf("%d\n",query(ql[i],qr[i],qc[i])); update(ql[i],qr[i],qc[i]); #ifdef NTF_AK_IOI printf("Maybe the array : "); FOR(i,1,n) printf("%d ",a[i]); puts(""); FOR(i,1,bl[n])&#123; printf("block[%d] : ",i); if(sam[i])&#123; printf("same %d\n",i[bid][a]); continue; &#125; FOR(j,1,siz) printf("%d ",num[i][j]); puts(""); &#125; #endif &#125; return 0;&#125; 数列分块入门 9[LOJ 6285] 题意给出一个长为$n$的数列，以及$n$个询问，询问涉及求区间最小众数。 $1\leq l\leq r\leq n\leq 100000$,输入的所有数均为$\text{int}$范围的整数，不强制在线。 思路离线下来，做个莫队，块大小$\lfloor\frac{n}{\sqrt{n\log_2n}}\rfloor$。 具体实现我不会……啊啊我好菜 代码我不会啊 加强强制在线。见强制在线不带修区间众数。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫无止境的八月计划]]></title>
    <url>%2Fblog%2F20190801%2F</url>
    <content type="text"><![CDATA[八月来了。秉着鸽子的本能，写一个计划安排。 其实写不写都没什么关系，反正最后还是会咕的。 绝对不能咕的东西刷分块、莫队等各种其他根号算法。 被迫写Ynoi。 CF上分。 大概会咕的东西改漫无止境的集训题目。 学字符串，刷网络流，学数论并被线性代数搞自闭。 洛谷AC数达到150。 做完文化课作业。 多写平衡树直到像mj一样熟练。 把这个计划写到250字。 事后统计果然所有计划都咕掉了……]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>计划与总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello_World]]></title>
    <url>%2Fblog%2FHello-World%2F</url>
    <content type="text"><![CDATA[瞎搞了一整天终于大概搞好了。 首先感谢ouuan的博客给我提供了大量美化教程。 安装sudo npm install hexo-cli -g装 hexo。 hexo init创建 blog。 改的各种东西到 source 分支去找就行。 然后用的是 v6.6.0 的 NexT 主题。 目前实现的功能常用命令好像并不多，放在这里只是为了防止忘记。下面所有命令都是在根目录使用Git Bash输入的。 hexo new: 后面接一个模板名和用&quot;&quot;括起来的新文件名，就可以新建一个文件。 hexo cl: hexo clean的简写，大概是个更新缓存？反正每次 deploy 前用一下就好了。 hexo g: hexo generate的简写， deploy 之前用一下。 hexo d: hexo deploy的简写，使用后即发布博客。 hexo s: hexo server的简写，输入后可以在localhost:4000本地预览博客。 网站内部有了网站的图标、背景、页脚、站内搜索、关于、标签和分类。 也有了友链。 一言（ヒトコト）懒得弄，先咕了。 博文支持 $\LaTeX$ 语法和markdown。不知道有没有未发现的锅。 $f_{f_i}$ ， $a * b * c$ ， $[x,y] (0&lt;x&lt;y&lt;1)$ 均正常。 支持折叠块： 这是一个折叠块。 也可以引用图片。 网络上的图片： 本地图片： 还有这种引用方式： 1&#123;% asset_img 图片地址(可以本地) 图片描述 %&#125; 然后鼠标放在上面就能看到描述。 书签咕了，复制提醒咕了。 README 与 404页面咕了。 搭建博客时遇到的问题关于$\LaTeX$关于双下划线匹配问题： f_{f_i} : $f_{f_i}$ 这个好像本来就没问题？ （如果锅了大不了每个下划线前后都空格就行了，参见下文） 关于双星号匹配问题： a * b * c : $a * b * c$ 加空格就没问题了。 关于方括号后接圆括号匹配问题： [x,y] (0&lt;x&lt;y&lt;1) : $[x,y] (0&lt;x&lt;y&lt;1)$ 还是加空格…… 关于双斜杠匹配问题： 这个要单独拎出来说一下。例如下面这条： \begin{bmatrix}{1,0,0\\0,1,0\\0,0,1}\end{bmatrix} 正常情况应该是这样的：$\begin{bmatrix}{1,0,0\\0,1,0\\0,0,1}\end{bmatrix}$ 但由于神奇的Hexo博客先渲染Markdown，\\就会被转译为\（在需要在正文使用这类字符的时候可以在前面加入一个\来表示） 所以将\\改为\\\\即可。（上面那个没锅的矩阵就是这么来的） 历史遗留问题deploy 后仓库内显示账号名错误曾经这个博客 deploy 之后在仓库内显示的 deploy 账户是 name ，而且没有邮箱，不能点进个人页面。 从这个博客诞生以来（2019.7.21）日就一直在困扰着本人的问题，已经提交了上百次后（2020.1.10）才解决。 尝试了诸多方法，比如重置 ssh ，重新登录 git ，把 deployer 删了重装……无果。 解决方式也很奇葩：把本地博客转移到另一个文件夹里，重新hexo init，然后提交。 然而这样就导致以前的所有提交记录没了，不过那大概不重要？ 参考资料及鸣谢ouuan的博客]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
</search>
