<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「CF506E」Mr. Kitayuta's Gift]]></title>
    <url>%2Fblog%2FCF506E%2F</url>
    <content type="text"><![CDATA[队爷的 pdf 题解根本看不懂，，， 题意简述给定一个小写字符串 $s$ 与正整数 $n$。$|s|\le 200, n\le 10^9$。 要求在 $s$ 中插入恰好 $n$ 个小写字符使其为回文串的方案数，对 $10^4 + 7$ 取模。 主要思路在这里只考虑 $n + |s|$ 为偶数的情况（因为实际上两者差不多）。 考虑 dp。设 $f(i, l, r)$ 为只考虑最终回文串的前 $i$ 与后 $i$ 个字符，它们与 $s$ 尽可能匹配后还剩下 $[l, r]$ 这段区间的方案数。然后顺便设 $g(i)$ 为只考虑最终回文串的前 $i$ 与后 $i$ 个字符已经将 $s$ 完全匹配的方案数。 显然转移有： $s_l = s_r, r - l\le 1$:$$\begin{aligned} g(i + 1)&amp;\leftarrow f(i, l, r)\\ f(i + 1, l, r)&amp;\leftarrow 25\cdot f(i, l, r)\end{aligned}$$ $s_l = s_r, r - l &gt; 1$:$$\begin{aligned} f(i + 1, l + 1, r - 1)&amp;\leftarrow f(i, l, r)\\ f(i + 1, l, r)&amp;\leftarrow 25\cdot f(i, l, r)\end{aligned}$$ $s_l \ne s_r$:$$\begin{aligned} f(i + 1, l + 1, r)&amp;\leftarrow f(i, l, r)\\ f(i + 1, l, r - 1)&amp;\leftarrow f(i, l, r)\\ f(i + 1, l, r)&amp;\leftarrow 24\cdot f(i, l, r)\end{aligned}$$ $g$:$$g(i + 1)\leftarrow 26\cdot g(i)$$ 把这个状态数 $O(|s|^2)$ 的 dp 强行矩乘优化可得到 $O(|s|^6\log n)$ 的复杂度，但显然无法通过此题。 观察，可以发现这个 dp 可以表示为在一个有限状态自动机上匹配的过程。我们不妨将终点设为 $T$，转移过程的点设为 $(l, r)$。 例如如下为abaac的转移图： 令对于所有 $(l, r)$ 满足 $s_l = s_r$，设其为一类点（上图粉色），否则设为二类点（上图蓝色）。 由于除了 $l = r$ 以外，经过一个一类点会使得未匹配长度减少 $2$，故若一条链上经过了 $x$ 个二类点，则应经过 $\lceil\frac{|s| - i}{2}\rceil$ 个一类点。所以本质不同的链只有 $O(|s|)$ 条。 不妨设 $h(i, l, r)$ 为起点到 $(l, r)$ 经过 $i$ 个二类点的路径的数量。显然 $h(i, l, r)$ 可以 $O(|s|^3)$ 记忆化搜索求出。 此时对每一条链矩乘优化即可得到 $O(|s|^4\log n)$ 的总复杂度，仍无法通过此题。 考虑能否将这 $O(|s|)$ 条链压缩成 $O(|s|)$ 个点。 答案是能的。只要我们先各作一条一类点、二类点的链，再将每两个二类点连向一个对应的一类点即可。 转移系数等类似地可以 $O(|s|^3)$ 求出。故矩乘优化总时间复杂度为 $O(|s|^3\log n)$。 不要忘记上述讨论均基于 $n + |s|$ 为偶数。若 $n + |s|$ 为奇数如何？ 不难发现，除了最后一步转移（即最终串只剩中间位没有确定时）不能从 $s_l = s_r, l + 1 = r$ 的点转移过来其他均相同。 故在上述图中去掉 $T$ 的自环，并仅保留最后从未匹配长度为 $2$ 的一类点转移至终点的链，再做一次矩乘优化即得到多算的方案数。 参考代码难写，，， （作上面两幅图的素材被扔到graph.7z里了，不过都是 mspaint 手撸大概也没什么保存的必要）]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构题的一些小trick]]></title>
    <url>%2Fblog%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8Ftrick%2F</url>
    <content type="text"><![CDATA[鉴于许多数据结构题都是一些套路的组合，把一些坑过本人的 trick 记录下来。 在没有特别说明的情况下，$n$ 均为维护元素个数，$W = 10^9$。 可重集$O(1)$ 单点加删，$O(\sqrt{n})$ 第k大，值域 $O(n)$对值域分块，询问枚举答案在哪一块即可。 $O(\sqrt{n})$ 单点加删，$O(1)$ 第k大，值域 $O(W)$按顺序每 $\sqrt{n}$ 个数分一块，块状链表保证加删点后每个块长不变即可。 $O(1)$ 单点删除，均摊 $O(1)$ 查某数前驱，值域 $O(n)$维护下每个数的前驱与这个数是否仍存在，不存在就继续往前跳，每个数被删只会改变 1 个数的前驱，故均摊 $O(1)$。（没发现怎么搞单点加入） $O(\sqrt{n})$ 单点加删，均摊 $O(1)$ 查某数前驱，值域 $O(n)$对值域分块，对每一块维护这一块之前有数的第一块，块内每个数维护块内前驱。加入删除暴力重构该块内部关系与该块与其他块之间关系。 至于能不能做到两种操作均 $O(1)$，我也不知道。 $O(\log W)$ 全体加值，$O(\log W)$ 查与某数异或所得最值，值域 $O(W)$一棵 trie 搞定，细节可以现场推。（记这个是因为某次把全体加值当成了两个log的） 树对每个节点最大化其子树外大小 $O(1)$ 点集的价值假如我们可以复杂度较优地维护节点的集合，并支持加入节点与求出节点集合中价值最大的点集，则可以先对全树求出价值最大的点集。容易发现只有价值最大的点集中的 $O(1)$ 个节点到根的路径的答案不确定。 对于一条从根出发的路径，显然可以再次维护节点集合，在 $O(n)$ 次加入后得出该路径上每个节点的答案。 其他小东西一些和为 $n$ 的非负整数中，不小于 $\sqrt{n}$ 的最多 $\sqrt{n}$ 个。 $\sum\limits_{x\cdot y\le n} 1 = O(n\log n)$]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>log数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成函数学习笔记(2)]]></title>
    <url>%2Fblog%2F%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%2F</url>
    <content type="text"><![CDATA[坑]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>生成函数</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[果然我的正则表达式写错了]]></title>
    <url>%2Fblog%2F%E6%9E%9C%E7%84%B6%E6%88%91%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%86%99%E9%94%99%E4%BA%86%2F</url>
    <content type="text"><![CDATA[Q：为什么玩春物哏，你不是还没看吗？A：因为我整这玩意就是为了下载春物啊…… 没错，为了在 wenku8 上下载全篇小说，这个人用 C++ 写了个小脚本。 甚至这人不会多线程，下载只会用curl。 然后下载速度巨慢，爬爬爬。 我们姑且不提某个已经完善然而只能下epub的下载器。 wenku8 除了无版权小说的插图下载以外都被人研究透彻了。现在下载无版权小说插图还是只能跑几十万次请求。 已解决问题正则表达式从不会到不会有人说用正则表达式徒增负担，但没正则我更不会写。 于是 30min 修炼正则表达式基础，玩 RegExr（顺带一提这网站在今天下午证书过期了，真是够巧的）。 curl从不会到略懂啊这个东西好像还真是学学就行。 大概就主要看了这一篇。 在C++中实现编码互转至今不会，所以脚本中完全没有关于这个的。 code过程经历太多，只留下这份代码来表示我的付出终于有了些回报。 编译后运行，输入文章 id 即可观察到它慢慢爬爬爬。 顺带一提由于上面说的原因不能下载无版权小说的插图。 命名格式不规范警告.webp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//author: Okazaki Yumemi//v0.0.1//c++11#include&lt;bits/stdc++.h&gt;using namespace std;inline string IntToString(const int &amp;x)&#123; if(x &lt; 0) return "-" + IntToString(-x); if(x &lt; 10) return string(1, char(x ^ 48)); return IntToString(x / 10) + char((x % 10) ^ 48);&#125;inline int StringToInt(const string &amp;x)&#123; const int &amp;len = x.length(); assert(isdigit((char)x[len - 1])); if(len == 1)&#123; return (char)x[0] ^ 48; &#125; return StringToInt(x.substr(0, len - 1)) * 10 + ((char)x[len - 1] ^ 48);&#125;const regex ChapterPattern("href=\"\\d&#123;1,9&#125;.htm\""), VolumePattern("colspan=\"4\""), IllustPattern("src=\"http://picture.wenku8.com/pictures/\\d&#123;1,9&#125;/\\d&#123;1,9&#125;/\\d&#123;1,9&#125;/\\d&#123;1,9&#125;.(jpg|png)\""), IllustNamePattern("\\d&#123;1,9&#125;.(jpg|png)");typedef string::const_iterator iter;ifstream Origin;string Contents;smatch ChapterResult, VolumeResult, VolumeNextResult;string BasicUrl, ArticleName;void IllustDownload(const string &amp;VolumeName)&#123; ifstream IllustOrigin(".\\illust.htm"); string IllustContents((istreambuf_iterator&lt;char&gt;(IllustOrigin)), istreambuf_iterator&lt;char&gt;()); smatch IllustResult, FileNameResult; iter IllustBegin = IllustContents.begin(), IllustEnd = IllustContents.end(); while(regex_search(IllustBegin, IllustEnd, IllustResult, IllustPattern))&#123; string IllustGet(IllustResult[0], 5, IllustResult[0].length() - 6); regex_search(iter(IllustGet.begin()), iter(IllustGet.end()), FileNameResult, IllustNamePattern); string DownloadIllust = "curl -o .\\" + VolumeName + "\\" + string(FileNameResult[0]) + " " + IllustGet; // cout &lt;&lt; DownloadIllust &lt;&lt; "\n"; system(DownloadIllust.c_str()); // puts(DownloadIllust.c_str()); IllustBegin = IllustResult[0].second; &#125;&#125;void ArticleInit()&#123; int ArticleId; puts("Article id:"); // scanf("%d", &amp;ArticleId); cin &gt;&gt; ArticleId; ArticleName = IntToString(ArticleId); BasicUrl = "https://www.wenku8.net/novel/" + IntToString(ArticleId / 1000) + "/" + ArticleName + "/"; // string ArticleDescriptionDownload = "curl -v " + BasicUrl + "index.htm &gt; origin.htm"; string ArticleDescriptionDownload = "curl " + BasicUrl + "index.htm &gt; origin.htm"; // system("rm origin.htm"); system(ArticleDescriptionDownload.c_str());&#125;void ArticleDownload()&#123; Origin = ifstream(".\\origin.htm"); Contents = string((istreambuf_iterator&lt;char&gt;(Origin)), istreambuf_iterator&lt;char&gt;()); int VolumeNow = 0; iter VolumeIterBegin = Contents.begin(), VolumeIterEnd = Contents.end(); iter ChapterIterBegin, ChapterIterEnd; VolumeIterBegin = regex_search(VolumeIterBegin, VolumeIterEnd, VolumeNextResult, VolumePattern) ? VolumeNextResult[0].second : VolumeIterEnd; while(VolumeIterBegin &lt; VolumeIterEnd)&#123; ++VolumeNow; string VolumeName = IntToString(VolumeNow); // printf("Vol: %d\n", VolumeNow); string MkVolumeDir = "mkdir " + VolumeName; system(MkVolumeDir.c_str()); VolumeResult = VolumeNextResult; bool LastVolume = !regex_search(VolumeIterBegin, VolumeIterEnd, VolumeNextResult, VolumePattern); ChapterIterBegin = VolumeIterBegin; VolumeIterBegin = ChapterIterEnd = LastVolume ? VolumeIterEnd : VolumeNextResult[0].second; string ChapterGet, UrlName; while(regex_search(ChapterIterBegin, ChapterIterEnd, ChapterResult, ChapterPattern))&#123; ChapterGet = string(ChapterResult[0], 6, ChapterResult[0].length() - 11); UrlName = IntToString(StringToInt(ChapterGet) - 1); // cout &lt;&lt; UrlName &lt;&lt; "\n"; string DownloadUTF8 = "curl -o \".\\" + VolumeName + "\\" + ChapterGet + " utf8.txt\" \"http://dl.wenku8.com/packtxt.php?aid=" + ArticleName + "&amp;vid=" + UrlName + "&amp;charset=utf8\""; string DownloadGBK = "curl -o \".\\" + VolumeName + "\\" + ChapterGet + " gbk.txt\" \"http://dl.wenku8.com/packtxt.php?aid=" + ArticleName + "&amp;vid=" + UrlName + "&amp;charset=gbk\""; string DownloadBIG5 = "curl -o \".\\" + VolumeName + "\\" + ChapterGet + " big5.txt\" \"http://dl.wenku8.com/packtxt.php?aid=" + ArticleName + "&amp;vid=" + UrlName + "&amp;charset=big5\""; system(DownloadUTF8.c_str()); system(DownloadGBK.c_str()); system(DownloadBIG5.c_str()); // puts(DownloadUTF8.c_str()); // puts(DownloadGBK.c_str()); // puts(DownloadBIG5.c_str()); ChapterIterBegin = ChapterResult[0].second; &#125; // system("rm illust.htm"); // string DownloadIllust = "curl -v " + BasicUrl + ChapterGet + ".htm &gt; illust.htm"; string DownloadIllust = "curl " + BasicUrl + ChapterGet + ".htm &gt; illust.htm"; system(DownloadIllust.c_str()); IllustDownload(VolumeName); // cout &lt;&lt; DownloadIllust &lt;&lt; "\n"; &#125;&#125;int main()&#123; ArticleInit(); ArticleDownload(); return 0;&#125; 未解决多线程下载不会，咕了。 部分文章的vid非章节号减去1正解也许是章节号 -1,0,+1 都有可能。 这个下次来修。 断点续传偶尔来个网不稳就会出现 Time Out，被迫全部重下。 所以啥时候写个断点续传啊（]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摆脱辣鸡cmd]]></title>
    <url>%2Fblog%2F%E6%91%86%E8%84%B1%E8%BE%A3%E9%B8%A1cmd%2F</url>
    <content type="text"><![CDATA[我，一直有个梦想，就是在 Windows 下摆脱 cmd。 终于我这一天被它弄得心态崩溃，整了一个 cmder 来玩。 这啥这里有个详细的初步介绍。 好吧，这大概是个 Win 下的可移植的终端的整合包，让你随身携带命令别名、颜色主题之类的。 然后这里主要用来记录使用 cmder 遇到的一些问题。 λ很炫，但也很屑由于 cmder 将λ作为命令提示符，稍微上下键查看下前后的命令就会多出来一个无法删除的符号，令人谔谔。 于是vendor\clink.lua里面把某一行（因版本不同而不同，行开头是local cmder_prompt =）中的{lamb}改为$即可解决 cmd 的命令提示符问题。 bash 的命令提示符就麻烦些，要在vendor\git-for-windows\etc\profile.d\git-prompt.sh把某一行PS1=&quot;$PS1&quot;&#39;λ &#39; # prompt: always λ改为PS1=&quot;$PS1&quot;&#39;$ &#39; # prompt: always $就好了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Vim里摸爬滚打]]></title>
    <url>%2Fblog%2F%E5%9C%A8Vim%E9%87%8C%E6%91%B8%E7%88%AC%E6%BB%9A%E6%89%93%2F</url>
    <content type="text"><![CDATA[你校曾经全是 Emacs 党，直到近两年出现了我这个用 Vim 的沙雕，和某个进队的 Gedit 神必壬。 至于为什么使用 Vim，一方面是想改善你校只有 Emacs 人的环境，一方面是想找点乐子。 于是开始看简明 Vim 练级攻略，顺便把基本操作扔到自己博客里。 简易使用安装 Vim 并启动后在 Normal 模式下，这个模式下所有的键就是功能键。 注意&lt;Ctrl&gt;-λ我会写成C-λ，以:开始的命令需要回车执行，&lt;n&gt;表示该处应输入一个数。 从 Normal 模式转至 Insert 模式 i：在光标前插入。a：在光标后插入。o/O：在当前行后/前插入一个新行并将光标跳到行头处。 删除字符 &lt;delete&gt;：真忘了怎么删就 delete 键。x：删除当前光标所在位置的一个字符。 复制粘贴 dd：删除当前行，并存入剪贴板里。p/P：在当前位置之后/前粘贴。yy：拷贝当前行。 怎么从外部剪贴板粘贴或复制到外部剪贴板呢？目前记住&quot;+p和&quot;+y就够了。 其实选中一部分内容后，y就是复制，d就是删除。 撤销恢复 u：Undo.&lt;C-r&gt;：Redo. 打开/保存/退出/改变文件 :e &lt;path/to/file&gt;：打开一个文件。:w：存盘。:saveas &lt;path/to/file&gt;：将当前文件另存为&lt;path/to/file&gt;。ZZ/:wq：保存并退出。:x：保存（仅在需要时）并退出。:q：退出，若选择不保存则需后附!强制执行（即命令为:q!），强制退出所有的文件可以使用:qa!。:bn/:bp：若打开了多个文件，使用其来切换到上/下一个文件。 移动光标 所谓 blank 字符，就是空格、tab、换行等。 hjkl：向左下上右移动光标。0：到行头。^：到本行第一个不是 blank 字符的位置。$：到本行行尾。g_：到本行最后一个不是 blank 字符的位置。:&lt;n&gt;：到第&lt;n&gt;行。 自动补全 &lt;C-n&gt;：体验不算太好，也许我没找到真正的使用方法（ 选择 v：选择一段。&lt;Shift-v&gt;：按行选择。 一些基本配置Vim 安装目录和用户主目录下有.vimrc，那是配置文件。 设置编码123set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936set termencoding=utf-8set encoding=utf-8 显示行号1set number nu是缩写。 突出显示当前行1set cursorline cul是缩写。 突出显示当前列1set cursorcolumn cuc是缩写。 启用鼠标123set mouse=aset selection=exclusiveset selectmode=mouse,key 不过其实没啥人愿意用鼠标，毕竟大部分人都是为了解放鼠标才来玩 Vim 的（ 缩进与 tab以下分别为设置将输入的 tab 转为空格、设置 tab 长度为 4 空格、设置自动缩进长度为 4 空格、继承前一行的缩进方式、 1234set expandtabset tabstop=4set shiftwidth=4set autoindent 对于我来说，暂时已经能够在 Vim 下存活了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同一局域网下文件互传]]></title>
    <url>%2Fblog%2F%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8B%E6%96%87%E4%BB%B6%E4%BA%92%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[世界上最遥远的距离，不是生与死的距离，而是明明大家都在一个局域网下，却还要用 QQ 传文件。 我一直很不理解，明明都在同一个局域网下，传个文件怎么要么 QQ 要么 u 盘，多不优雅。但是又一直安于现状，懒得麻烦。终于有一天受不了了，开始研究如何优雅地传文件。 Windows传这个其实是最简单的。 打开高级共享设置(控制面板\网络和 Internet\网络和共享中心\高级共享设置)，启用网络发现，启用文件和打印机共享，启用公用文件夹共享，使用 128 位加密帮助保护文件共享连接。密码开不开随意。 然后右键把需要共享的文件夹设为共享。如果希望所有人都可以访问，可以添加一个 Everyone 账户。 Windows收打开网络就能看到局域网内其他 Windows 设备了，点开得了。 当然直接访问该设备局域网下的 IPv4 地址也行。（Windows+R，\\url） 要输账户就用自己账户密码。 Mac收打开 Finder，Command+K，smb://url。 Linux收mount 挂载由于需求不大，个人只用这个。 1sudo mount -t cifs -o username=&lt;username&gt;,password=&lt;password&gt; //&lt;url&gt;/&lt;folder&gt; &lt;folder&gt; 啊不过每次重新开机都要重新挂载。 samba装个 samba，然后随便搞（确信） ssh大家都会（确信） Android传我发现一个叫File Explorer的软件非常好用。 FTP服务器的选项会在当前局域网开启一个ftp服务器，然后就可以文件互传了。下面的加号里面也可以挂载各种其他协议。当然优秀的文件管理功能就不提了。 Mac和Linux传暂时没有需求，有时间再来研究。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020省选游]]></title>
    <url>%2Fblog%2F2020%E7%9C%81%E9%80%89%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[今年咋是联考啊。 没有停课的日子除了最后一周，都只占用下午下课后与晚上的时间。我寻思倒不如多整点停课，划走晚上算什么嘛。 稳定每天一套模拟赛，每天被吊打。 学会了多项式的卡常技巧。 终于停课了才发现 0202 年了你校还有一个机房是 32 位 win。 咋只剩一周了。 根据惯例（¿）最后一周不会天天有模拟赛。 信心场也打得和屎一样。没救了啊。 想复习点分、串串、网络流、数论、计算几何。算了先写个 LCT 吧。 各种模板题写挂，为啥码力退步巨大多，我人傻了。 随便学了学 k-D Tree，SAM。 考前补知识点简直是女娲补天。 奶一口都不会考算了。 最后一天你校留生工作傻逼，初三自招壬填报志愿把我们赶来赶去。 最后到了「数学研究室」，其实就是颓废室啦。大量无系统的机，几台设了密码的机。有个老哥密码提示「好啊！来啊！」，输入114514进去了。 于是试图在某无系统电脑装个 UBuntu 18.04，然而失败。 就这样白费了一早上。 下午机房的人都开始颓。我也想颓，然而还在复习（预习）知识点，算了。 晚上受不了了开始看神仙扫雷。 走之前打印了准考证，和几个板子。试图在宿舍看看，然而还是睡觉好。 商店里冰火人在问问题开场 1min 输奇怪的密码，10min 把题看了一遍。怎么这么 CSP2019 day 1。 icefire 看起来就是区间加减和维护一个非严格单峰函数的右峰。 $Q\le 2\times 10^6$，-lm。怎么省选还考卡常的，差评。 二分？好像我会 $O(Q\log^2 Q)$。然而只有 60 分。 三个.cpp开好了，测一些输入输出，发现文操错了： 12freopen(".in", "r", stdin);freopen(".out", "w", stdin); 怎么俩stdin，赶紧改。 于是开始看 problem。草怎么模数不是质数，昨天谁奶的来着。 $$\sum\limits_{i = 0}^{n} x^i \binom{n}{i} = (x + 1)^n$$ 开始推。 $$\begin{aligned}S_m &amp;=\sum\limits_{i = 0}^{n} i^{\underline{m}} k^i \binom{n}{i}\\ &amp;=\sum\limits_{i = m}^{n}\dfrac{n!}{(i - m)!(n - i)!}\cdot k^i\\ &amp;=n^{\underline{m}} k^m\sum\limits_{i = 0}^{n - m} \binom{n - m}{i} k^i\\ &amp;=n^{\underline{m}} k^m (k + 1)^{n - m}\end{aligned}$$ 想了想 $n^{\underline{m}}$ 按 $m$ 从小到大计算可以 $O(m^2)$ 求出所有要用的。好啊，只要把 $f$ 转下降幂多项式就可以 $O(m^2)$ 了。 如何转下降幂？ 设 $f(x) = \sum\limits_{i = 0}^{m} b_i x^{\underline{i}}$。 假如我知道了 $b_i$($i &lt; x$)，那可以求出 $x!b_x$，不妨设 $c_x = x!b_x$。发现 $x^{\underline{i}}b_i = \dfrac{x^{\underline{i}}}{i!}c_i$。 假如我可以 $O(m^2)$ 处理 $\dfrac{x^{\underline{i}}}{i!}$($x, i\le m$)和 $\dfrac{n^{\underline{i}}}{i!}$($i\le m$)岂不做完了？ 后面那个我会！直接搞 $m$ 个数，每次要除一个数的时候就遍历这 $m$ 个数除可以除的，直到把这个数除到 $1$，$O(m^2)$。 前面那个，乘的数和除的数都 $O(m)$ 有啥用？只能 $O(m^3)$？没这部分分啊！ 自闭了，我也不知道浪费了多久。 随手写下一个式子：$\dfrac{(x + 1)^{\underline{i}}}{i!} - \dfrac{x^{\underline{i}}}{i!} = \dfrac{x^{\underline{i - 1}}}{(i - 1)!}$ 哦 $\dfrac{x^{\underline{i}}}{i!} = \dbinom{x}{i}$ 啊，那没事了。 于是又写了 10min 走人，写完都十一点半了。 自闭的途中试图写 shop 的最低档暴力，未果。想了想 icefire，还是只会俩 $\log$，人没了。 没办法只能写。 瞎搞过了第一个样例，第二个死活过不去。十二点三十了，我觉得我在冒汗，头脑也已经将近停止转动了。 全机房好像只剩我的键盘在响。 看了看自己的写法，发现二分的时候没有取到温度最大的。 又补了一个二分。补的时候监考员已经表示只剩十分钟了。 距离考试结束只剩几分钟，过了第二个样例。 认真看了看感觉没错，最后三分钟啥都没干，考试结束了。 大概 60 + 100 + 0 罢。 出考场一想，icefire 那个东西好像完全可以直接树状数组上二分，省掉一个 $\log$。 也会了 shop 的 10 分暴力。 还是考场降智啊。 顺便用自己傻瓜的 problem 的心路历程逗笑了整个机房。 明明我昨晚刚看过斯特林数，结果 problem 推导完全没用上。 某神仙拿草稿纸在场上写游记结果草稿纸回收了，草。 吃中午饭大家疯狂奶明天考啥。毕竟今天没串串没计数没树。 下午在「数学研究室」划水划了一下午，发现テトリス(Tetris)底力下降巨大多。 晚上在 32 位机房又划水划了一晚上。 作业是在树上传递信号反正 CSP 成绩和昨天 icefire 笑话已经决定我进不了 E 的事实，今天决定随便考。 transfer 看起来是个 $O(m2^m)$ 之类的，然而我想了 20min 只会阶乘做法。 count 看起来暴力分好足。 第一个包 10min，第二个包 3min。 矩阵树定理是啥来着……行列式怎么算来着…… 于是成功在第三个包浪费巨久。 等等第四个包怎么搞啊，怎么求必须选某条边的树的个数啊！！！ 于是只拿了前三个包跑路了。 tree 一看就是个工业题，大概要维护一个数据结构支持： 插入一个数 一个结构内全加 1 求一个结构内的异或和 合并两个结构 这不是 ynoi trick 吗，反正就 Trie 合并完事。 于是敲了 80min 左右搞出来了。 数组卡紧开，反正值域到就完事了。(flag) 还有大量时间搞 transfer。 先把第一个包拿了。 剩下 40min，找个暴力拍拍拍。 $5\times 10^4$ 两份代码都跑得飞快，$5\times 10^5$ 两份代码都跑不出来。 怎么回事啊！ $1\times 10^5$ 也能跑。$2\times 10^5$ 也能跑。 自闭了，直到考试结束都不知道发生了啥。 一出来发现 transfer 可以把边的贡献拆在点上，然后随便 $O(m^2 2^m)$。 发现 tree 只开了 $2^{19}$，凉了。 发现 count 第四个包只要算全图生成树个数和去掉某条边之后生成树个数，一减就是包含某条边的生成树个数。 又降智了。预估 30 + 80 + 50。 两天串串没考，计数没考，奇怪的数据结构没考，计算几何没考。我怀疑我来的是 CSP 2019 Round 2。 一上你谷看到 lxl 发的听说省选考了Ynoi题一样的trick，想到考场上自己好像第一反应也是这个。 滚回文化课考完两天出分了。 类型 icefire problem shop transfer tree count 实际得分 60 100 0 30 35 50 考场上会，但是写挂了 0 0 0 0 65 0 出了考场不久会了 40 0 10 30~40 0 20 再肝多久也搞不出来 0 0 90 10 0 0~30 考场上降智（即表中第三行）是主要丢分点。 至于写挂的 65 分…… tree 暴毙是因为它看起来开了 $2^{19}$ 实际上只开了 $2^{18}$。（实际上是被某人奶死的（确信）） 算是买了个「值域要仔细看」的教训吧。 并且考场造数据的时候，值域可以尽量开到上限（比如在 $[\dfrac{1}{2}W_{max}, W_{max}]$ 之间随机而不要在 $[1, W_{max}]$ 随，或者直接测几个全开 $W_{max}$ 的数据）。如果这么干了，考场上是不是也能救回来那 65 呢。 发现考场我不愿意去洗手间，其实 4.5h 的比赛去一去转换一下思路也许确实能一定程度上避免降智吧。 感觉睡好确实挺重要的，精神状态比 CSP 好太多了。 距离中考只剩一个月。 暂别。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k-D Tree学习笔记]]></title>
    <url>%2Fblog%2Fk-D-Tree%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[某人奶了一口省选会考，于是认真学了学。 形态k-D Tree 是一棵二叉搜索树，每个结点都对应 $k$ 维空间中的一个点，每个子树中的点都在且都仅在一个 $k$ 维超长方体内。 构建假设已知 $k$ 维空间中的 $n$ 个互不相同的点的坐标，要将其构建为一棵 k-D Tree。 当前超长方体中只有一个点时直接返回该点。 选择一个维度与该维度上的一个切割点，将当前超长方体按这个维度及这个切割点分为两个超长方体。 将选择的切割点作为该子树的根，递归处理分出的两个超长方体。 容易发现，对于步骤 2，每次切割点选为该维度上的中位数，树高可以在 $O(\log n)$。 如何寻找中位数？可以使用类似快速排序的方法，并且每次只递归包含中位数的一侧，对于 $n$ 个元素的序列期望时间复杂度即为 $O(n)$。（可用algorithm库中的nth_element()实现） 每次选什么维度来割？理论上应当每次选方差最大的维度割常数应当最小，然而算法竞赛中较常用且方便的写法是直接轮流按每一维割。 插入与删除点集可变，可以利用替罪羊树不平衡重构的方法把树高稳定在 $O(\log n)$。 然而实验证明定期整树重构通常来说常数更小。 查询超长方体若该结点完全被包含于超长方体内，或完全与其无交可直接返回。 否则应递归两边。 可以证明复杂度最坏为 $O(n^{1-\frac{1}{k}})$。 习题[Luogu 4148]简单题 初值全为 0 的 $n\times n$ 二维矩阵上， $q$ 个操作： 单点修改。 矩形查询和。 强制在线，内存限制20M，答案及过程量均int范围内。$n\le 5\times 10^5, q\le 2\times 10^5$。空间卡树套树，强制在线卡 CDQ 分治，于是只能 KDT。 不要不平衡重构，定期重构常数更小。 写写写，写就完事了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define FORit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b) + 1; i != ed_##i; ++i)#define ROFit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b)-1; i != ed_##i; --i)#define GO(x, p, e, i, v) for (register int i = p[x].head, v; i; i = e[i].link)#define MEM(x, v) memset(x, v, sizeof(x))#define fir first#define sec second#define pq priority_queue#define PB push_back#define MP make_pairtypedef long long LL;typedef double DB;typedef pair&lt;int, int&gt; PII;#define Templ(T) template &lt;typename T&gt;inline int read() &#123; reg int ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) f ^= (c == '-'), c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define using_modconst int mod = 998244353;#ifdef using_modinline void inc(int &amp;x, const int &amp;y) &#123; x += y; if (x &gt;= mod) x -= mod; &#125;inline void dec(int &amp;x, const int &amp;y) &#123; x -= y; if (x &lt; 0) x += mod; &#125;inline int ksm(int x, LL y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = 1ll * x * x % mod) if (y &amp; 1) res = 1ll * res * x % mod; return res;&#125;inline int qmo(const int &amp;x) &#123; return x + ((x &gt;&gt; 31) ? mod : 0); &#125;#endifTempl(_Tp) inline _Tp gcd(_Tp x, _Tp y) &#123; return y ? gcd(y, x % y) : x; &#125;#define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout)#define PBTXDY&#125; // namespace my_stdusing namespace my_std;const int N = 200010;struct Node&#123; int e[2][2], b[2], c[2], val, sum, siz;&#125;;namespace KDT&#123;Node a[N];static const DB alpha = 0.75;int ldr[N], ccnt, root;static int d_d;inline bool c_d(const Node &amp;l, const Node &amp;r)&#123; return l.b[d_d] != r.b[d_d] ? l.b[d_d] &lt; r.b[d_d] : l.b[d_d ^ 1] &lt; r.b[d_d ^ 1];&#125;#define lc a[t].c[0]#define rc a[t].c[1]inline void Print(const int &amp;t)&#123; printf("Node[%d]: --- &lt;%d, %d&gt;\n", t, lc, rc); printf("[%d, %d, %d], [%d, %d, %d], %d, %d, %d\n", a[t].e[0][0], a[t].b[0], a[t].e[0][1], a[t].e[1][0], a[t].b[1], a[t].e[1][1], a[t].val, a[t].sum, a[t].siz);&#125;inline void PushUp(const int &amp;t)&#123; a[t].siz = a[lc].siz + a[rc].siz + 1; a[t].sum = a[lc].sum + a[rc].sum + a[t].val; if(lc)&#123; chkmin(a[t].e[0][0], a[lc].e[0][0]); chkmax(a[t].e[0][1], a[lc].e[0][1]); chkmin(a[t].e[1][0], a[lc].e[1][0]); chkmax(a[t].e[1][1], a[lc].e[1][1]); &#125; if(rc)&#123; chkmin(a[t].e[0][0], a[rc].e[0][0]); chkmax(a[t].e[0][1], a[rc].e[0][1]); chkmin(a[t].e[1][0], a[rc].e[1][0]); chkmax(a[t].e[1][1], a[rc].e[1][1]); &#125;&#125;inline bool CanRbu(const int &amp;t)&#123; return alpha * a[t].siz &lt;= (DB)max(a[lc].siz, a[rc].siz);&#125;inline void Build(const int &amp;l, const int &amp;r, const int &amp;d)&#123; if(l &gt; r) return; const int t = (l + r) &gt;&gt; 1; d_d = d, nth_element(a + l, a + t, a + r + 1, c_d); a[t].e[0][0] = a[t].e[0][1] = a[t].b[0]; a[t].e[1][0] = a[t].e[1][1] = a[t].b[1]; a[t].siz = 1, a[t].sum = a[t].val; Build(l, t - 1, d ^ 1), Build(t + 1, r, d ^ 1); lc = l &gt; t - 1 ? 0 : (l + t - 1) &gt;&gt; 1; rc = t + 1 &gt; r ? 0 : (t + r + 1) &gt;&gt; 1; return PushUp(t);&#125;//inline void Flatten(int &amp;ldc, const int &amp;t)&#123;// if(!t) return;// Flatten(ldc, lc);// ldr[ldc++] = t;// Flatten(ldc, rc);//&#125;//inline int Build(const int &amp;l, const int &amp;r, const int &amp;d)&#123;// if(l &gt;= r) return 0;// const int mid = (l + r) &gt;&gt; 1;// d_d = d, nth_element(ldr + l, ldr + mid, ldr + r, c_d);// const int t = ldr[mid];// lc = Build(l, mid, d ^ 1), rc = Build(mid + 1, r, d ^ 1);// return PushUp(t), t;//&#125;//inline void Rebuild(int &amp;t, const int &amp;d)&#123;//// printf("Rebuild: %d\n", t);// int ldc = 0;// Flatten(ldc, t);// t = Build(0, ldc, d);//&#125;inline void Insert(int &amp;t, const Node &amp;v, const int &amp;d)&#123; if(!t)&#123; t = ++ccnt; a[t] = v; a[t].e[0][0] = a[t].e[0][1] = a[t].b[0]; a[t].e[1][0] = a[t].e[1][1] = a[t].b[1]; return; &#125; if(v.b[0] == a[t].b[0] &amp;&amp; v.b[1] == a[t].b[1])&#123; a[t].val += v.val; a[t].sum += v.sum; return; &#125; if(v.b[d] &lt;= a[t].b[d]) Insert(lc, v, d ^ 1); else Insert(rc, v, d ^ 1); PushUp(t);// if(CanRbu(t)) Rebuild(t, d);&#125;inline int Query(const int &amp;t, const Node &amp;v)&#123; if(!t) return 0;// Print(t); if(v.e[0][0] &lt;= a[t].e[0][0] &amp;&amp; a[t].e[0][1] &lt;= v.e[0][1] &amp;&amp; v.e[1][0] &lt;= a[t].e[1][0] &amp;&amp; a[t].e[1][1] &lt;= v.e[1][1])&#123; return a[t].sum; &#125; if(v.e[0][0] &gt; a[t].e[0][1] || a[t].e[0][0] &gt; v.e[0][1] || v.e[1][0] &gt; a[t].e[1][1] || a[t].e[1][0] &gt; v.e[1][1])&#123; return 0; &#125; int res = 0; if(v.e[0][0] &lt;= a[t].b[0] &amp;&amp; a[t].b[0] &lt;= v.e[0][1] &amp;&amp; v.e[1][0] &lt;= a[t].b[1] &amp;&amp; a[t].b[1] &lt;= v.e[1][1])&#123; res = a[t].val; &#125; return res + Query(lc, v) + Query(rc, v);&#125;#undef lc#undef rc&#125;int n;int main() &#123; n = read(); Rint opt, lst = 0, tot = 0; reg const int blo = 6666; reg Node v; v.siz = 1, v.c[0] = v.c[1] = 0; while(1)&#123; opt = read(); if(opt == 3) break; if(opt == 1)&#123; ++ tot; v.b[0] = read() ^ lst, v.b[1] = read() ^ lst; v.val = v.sum = read() ^ lst; KDT::Insert(KDT::root, v, 0); if(tot == blo)&#123; tot = 0; KDT::Build(1, KDT::ccnt, 0); KDT::root = (1 + KDT::ccnt) &gt;&gt; 1; &#125; &#125; else&#123; v.e[0][0] = read() ^ lst, v.e[1][0] = read() ^ lst, v.e[0][1] = read() ^ lst, v.e[1][1] = read() ^ lst;// printf("Qn: [%d, %d], [%d, %d]\n",// v.e[0][0], v.e[0][1], v.e[1][0], v.e[1][1]); printf("%d\n", lst = KDT::Query(KDT::root, v)); &#125; &#125; return 0;&#125; 参考资料OI Wiki]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KDT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「十二省联考2019」字符串问题]]></title>
    <url>%2Fblog%2F%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[重工业，，， 题意简述给定一个字符串 $S$，再给定 $n_A$ 个 A 类串和 $n_B$ 个 B 类串（均为 $S$ 的字串）。定义 A 类串的权值为该串长，B 类串的权值为 0。 将这些字串抽象为点，给定 $m$ 条 A 类连向 B 类的边。定义一个 B 类串向某个 A 类串连边当且仅当其为该 A 类串的一个前缀。 求一条最长的路径（路径长度定义为路径上经过所有点的权值和），需判断无解。$|S|, n_A, n_B, m\le 2\times 10^5$。 [LOJ 3049] [Luogu 5284] 主要思路由于不会 SAM，此处只讲 SA 做法。 假设 $x$ 为 $y$ 的前缀，那么 $x$ 的字典序必定小于 $y$，且 $\operatorname{lcp}(x, y) = |x|$。 于是只需要把 A 串和 B 串一起按字典序排好序，然后对每个 B 串二分一下它为前缀的区间，线段树优化建图，拓扑排序，就喜提 $O(n\log n)$。 怎么按字典序排序？对于俩串，lcp 为较短的，则短的排在长的前面；lcp 比最短的还短，直接按SA::rk[]排即可。 参考代码注意细节，比如 B 串应该在有相同 A 串时居于前面。 不知道为啥常数巨大，可能我写丑了？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define FORit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b) + 1; i != ed_##i; ++i)#define ROFit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b)-1; i != ed_##i; --i)#define GO(x, p, e, i, v) for (register int i = p[x].head, v; i; i = e[i].link)#define fir first#define sec second#define pq priority_queue#define MP make_pairtypedef long long LL;typedef double DB;typedef pair&lt;int, int&gt; PII;#define Templ(T) template &lt;typename T&gt;inline int read() &#123; reg int ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) f ^= (c == '-'), c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define using_modconst int mod = 998244353;#ifdef using_modinline void inc(int &amp;x, const int &amp;y) &#123; x += y; if (x &gt;= mod) x -= mod; &#125;inline void dec(int &amp;x, const int &amp;y) &#123; x -= y; if (x &lt; 0) x += mod; &#125;inline int ksm(int x, LL y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = 1ll * x * x % mod) if (y &amp; 1) res = 1ll * res * x % mod; return res;&#125;#endifTempl(_Tp) inline _Tp gcd(_Tp x, _Tp y) &#123; return y ? gcd(y, x % y) : x; &#125;#define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout)#define PBTXDY&#125; // namespace my_stdusing namespace my_std;const int N = 200010;int l2g[N];inline void init()&#123; FOR(i, 2, 200000) l2g[i] = l2g[i &gt;&gt; 1] + 1;&#125;int n, nA, nB, m;#define CLR(x) memset(x, 0, sizeof(x))char str[N];namespace SA&#123;int sa[N], rk[N], oldrk[N &lt;&lt; 1], cnt[N], px[N], id[N], ht[N];int st[20][N];inline int cmp(const int &amp;x, const int &amp;y, const int &amp;w)&#123; return oldrk[x] == oldrk[y] &amp;&amp; oldrk[x + w] == oldrk[y + w];&#125;inline void build()&#123; CLR(sa), CLR(rk), CLR(oldrk), CLR(cnt), CLR(px), CLR(id); CLR(ht), CLR(st); Rint m = 127, p, w; FOR(i, 1, n) ++cnt[rk[i] = str[i]]; FOR(i, 1, m) cnt[i] += cnt[i - 1]; ROF(i, n, 1) sa[cnt[rk[i]]--] = i; for(w = 1; p &lt; n; w &lt;&lt;= 1, m = p)&#123; p = 0; ROF(i, n, n - w + 1) id[++p] = i; FOR(i, 1, n) if(sa[i] &gt; w) id[++p] = sa[i] - w; memset(cnt, 0, sizeof(cnt)); FOR(i, 1, n) ++cnt[px[i] = rk[id[i]]]; FOR(i, 1, m) cnt[i] += cnt[i - 1]; ROF(i, n, 1) sa[cnt[px[i]]--] = id[i]; p = 0; memcpy(oldrk, rk, sizeof(rk)); FOR(i, 1, n)&#123; rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p; &#125; &#125; //build sa[], rk[] p = 0; FOR(i, 1, n)&#123; if(p) --p; while(str[i + p] == str[sa[rk[i] - 1] + p]) ++p; ht[rk[i]] = p; &#125; //build ht[] //ht[i] = lcp(sa[i], sa[i - 1]) FOR(i, 1, n) st[0][i] = ht[i]; FOR(i, 1, l2g[n])&#123; FOR(j, 1, n - (1 &lt;&lt; i) + 1)&#123; st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 &lt;&lt; (i - 1))]); &#125; &#125;// FOR(i, 1, n)&#123;// FOR(j, sa[i], n) putchar(str[j]);// putchar('\n');// &#125;&#125;inline int st_q(Rint x, Rint y)&#123; Rint k = l2g[y - x + 1]; y -= (1 &lt;&lt; k) - 1; return min(st[k][x], st[k][y]);&#125;inline int lcp(Rint x, Rint y)&#123; if(x == y) return n - x + 1; x = rk[x], y = rk[y]; if(x &gt; y) swap(x, y); return st_q(x + 1, y);&#125;&#125;struct Sub_str&#123; int p, len, id, rk; inline bool operator &lt;(const Sub_str &amp;x)const&#123; if(SA::lcp(p, x.p) &gt;= min(len, x.len)) return len == x.len ? rk &lt; x.rk : len &lt; x.len; else return SA::rk[p] &lt; SA::rk[x.p]; &#125;&#125;dt[N &lt;&lt; 1];int a_rk[N], b_l[N], b_r[N], a_p[N], b_id[N], a_len[N];inline void build_sub()&#123; nA = read(); FOR(i, 1, nA)&#123; dt[i].p = read(); a_len[i] = dt[i].len = read() - dt[i].p + 1; dt[i].id = i, dt[i].rk = 1; &#125; nB = read(); FOR(i, nA + 1, nA + nB)&#123; dt[i].p = read(), dt[i].len = read() - dt[i].p + 1; dt[i].id = i, dt[i].rk = 0; &#125; // printf("nA, nB: %d, %d\n", nA, nB); sort(dt + 1, dt + nA + nB + 1); // FOR(i, 1, nA + nB)&#123; // printf("%d: %c -- ", dt[i].id, dt[i].id &lt;= nA ? 'A' : 'B'); // FOR(j, dt[i].p, dt[i].p + dt[i].len - 1) putchar(str[j]); // putchar('\n'); // if(dt[i].id &gt; nA)&#123; // FOR(j, 1, nA + nB)&#123; // if(i != j &amp;&amp; SA::lcp(dt[j].p, dt[i].p) &gt;= dt[i].len) printf("%d ", dt[j].id); // &#125; // puts(""); // &#125; // &#125; Rint cA = nA; // dt[nA + nB + 1].rk = dt[nA + nB + 2].rk = cA; ROF(i, nA + nB, 1)&#123; if(dt[i].id &lt;= nA)&#123; dt[i].rk = a_rk[dt[i].id] = cA--; &#125; else&#123; dt[i].rk = cA; // b_l[dt[i].id - nA] = cA + 1; // Rint j = i + 1; // while(SA::lcp(dt[j].p, dt[i].p) &gt;= dt[i].len) ++j; // b_r[dt[i].id - nA] = dt[j - 1].rk; // printf("b[%d]: %d -- [%d, %d]\n", dt[i].id, dt[j - 1].id, b_l[dt[i].id - nA], b_r[dt[i].id - nA]); b_l[dt[i].id - nA] = cA + 1; Rint l = i + 1, r = nA + nB + 1, mid = (l + r) &gt;&gt; 1; while(l &lt; r)&#123; if(SA::lcp(dt[mid].p, dt[i].p) &gt;= dt[i].len)&#123; l = mid + 1; &#125; else r = mid; mid = (l + r) &gt;&gt; 1; &#125; --mid; // if(SA::lcp(dt[mid + 1].p, dt[i].p) &gt;= dt[i].len) ++mid; // if(SA::lcp(dt[mid].p, dt[i].p) &lt; dt[i].len) --mid; b_r[dt[i].id - nA] = dt[mid].rk; // printf("b[%d]: %d -- [%d, %d]\n", dt[i].id, dt[mid].id, b_l[dt[i].id - nA], b_r[dt[i].id - nA]); &#125;// printf("cA: %d\n", cA); &#125; FOR(i, 1, nA) a_p[a_rk[i]] = i; FOR(i, 1, nB) b_id[i] = i + (nA &lt;&lt; 2);// FOR(i, 1, nA) printf("a_rk[%d] = %d\n", i, a_rk[i]);// FOR(i, 1, nB) printf("b(%d): [%d, %d]\n", i, b_l[i], b_r[i]);&#125;struct Vertice&#123; int head, ind; LL val;&#125;;struct Edge&#123; int to, link;&#125;;namespace GR&#123;Vertice p[N &lt;&lt; 3];Edge e[N &lt;&lt; 4];int ecnt, tcnt;int Que[N &lt;&lt; 3];inline void A_E(const int &amp;u, const int &amp;v)&#123; e[++ecnt] = (Edge)&#123;v, p[u].head&#125;; p[u].head = ecnt, ++p[v].ind;&#125;inline void build(const int &amp;t, const int &amp;l, const int &amp;r)&#123; if(l == r)&#123; a_rk[a_p[l]] = t; p[t].val = a_len[a_p[l]]; return; &#125; reg const int mid = (l + r) &gt;&gt; 1; build(t &lt;&lt; 1, l, mid), build(t &lt;&lt; 1 | 1, mid + 1, r); A_E(t, t &lt;&lt; 1), A_E(t, t &lt;&lt; 1 | 1);&#125;inline void update(const int &amp;t, const int &amp;l, const int &amp;r, const int &amp;L, const int &amp;R, const int &amp;x)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) return A_E(x, t); reg const int mid = (l + r) &gt;&gt; 1; if(L &lt;= mid) update(t &lt;&lt; 1, l, mid, L, R, x); if(R &gt; mid) update(t &lt;&lt; 1 | 1, mid + 1, r, L, R, x);&#125;inline void build()&#123; ecnt = 0; memset(p, 0, sizeof(p)); memset(e, 0, sizeof(e)); build(1, 1, nA);// FOR(i, (nA &lt;&lt; 2) + 1, (nA &lt;&lt; 2) + nB) p[i].val = 1; m = read(); Rint a_, b_; FOR(i, 1, m)&#123; a_ = read(), b_ = read(); A_E(a_rk[a_], b_id[b_]); &#125; FOR(i, 1, nB)&#123; if(b_l[i] &lt;= b_r[i])&#123; update(1, 1, nA, b_l[i], b_r[i], (nA &lt;&lt; 2) + i); &#125; &#125; tcnt = (nA &lt;&lt; 2) + nB;// FOR(u, 1, tcnt)&#123;// printf("p[%d]: %d, %d\ne[%d]: ", u, p[u].val, p[u].ind, u);// GO(u, p, e, i, v) printf("%d ", e[i].to);// puts("");// &#125;&#125;inline int Topo_sort()&#123; Rint l = 0, r = 0; FOR(i, 1, tcnt) if(!p[i].ind) Que[r++] = i; while(l &lt; r)&#123; reg const int u = Que[l++]; GO(u, p, e, i, v)&#123; v = e[i].to; --p[v].ind; if(!p[v].ind) Que[r++] = v; &#125; &#125; return r == tcnt;&#125;inline LL dp()&#123; reg LL res = 0; ROF(i, tcnt - 1, 0)&#123; reg const int u = Que[i]; reg LL mx = 0; GO(u, p, e, i, v)&#123; v = e[i].to; chkmax(mx, p[v].val); &#125; p[u].val += mx; chkmax(res, p[u].val); &#125; return res;&#125;&#125;inline void work()&#123; scanf("%s", str + 1); n = strlen(str + 1); // printf("n: %d\n", n); SA::build(); build_sub(); GR::build(); if(!GR::Topo_sort()) return puts("-1"), void(); printf("%lld\n", GR::dp());&#125;int main() &#123; init(); int esac = read(); while(esac--) work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>线段树</tag>
        <tag>省选</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF843D」Dynamic Shortest Path]]></title>
    <url>%2Fblog%2FCF843D%2F</url>
    <content type="text"><![CDATA[题意简述[CF 843D] 给定 $n$ 个点 $m$ 条边的有向图，边带权。$q$ 个操作，可能是求目前 $1$ 到 $u$ 的最短路或是将 $c$ 条边的权加 $1$。 $n, m\le 10^5, q\le 2000, \sum c\le 10^6$。 主要思路$q$ 这么小，看起来像是 $O(nq)$。 先跑一遍 Dijkstra 来取得 $\langle dis_i\rangle$，表示 $1$ 到 $i$ 的最短路长度。 每次修改边权， $1$ 到任意其他点的距离比原先都不降。 那么求增量 $\langle f_i\rangle$。设 $e(u, v)$ 表示 $u, v$ 之间连边，$w(u, v)$ 表示 $u, v$ 之间边的边权。 显然对于点 $v$ 有 $f_v = \min\limits_{e(u, v)}(dis_u + f_u + w(u, v) - dis_v)$。 增量有上限 $c$，所以可以直接用桶 $O(n + m)$ bfs 做。 总时间复杂度 $O(n\log n + m + (n + m)q)$。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define FORit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b) + 1; i != ed_##i; ++i)#define ROFit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b)-1; i != ed_##i; --i)#define GO(x, p, e, i, v) for (register int i = p[x].head, v; i; i = e[i].link)#define MEM(x, v) memset(x, v, sizeof(x))#define fir first#define sec second#define MP make_pairtypedef long long LL;typedef double DB;typedef pair&lt;int, int&gt; PII;typedef pair&lt;LL, int&gt; PLLI;#define Templ(T) template &lt;typename T&gt;inline int read() &#123; reg int ans = 0; reg char c = getchar(); while (!isdigit(c)) c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return ans;&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define using_modconst int mod = 998244353;#ifdef using_modinline void inc(int &amp;x, const int &amp;y) &#123; x += y; if (x &gt;= mod) x -= mod; &#125;inline void dec(int &amp;x, const int &amp;y) &#123; x -= y; if (x &lt; 0) x += mod; &#125;inline int ksm(int x, LL y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = 1ll * x * x % mod) if (y &amp; 1) res = 1ll * res * x % mod; return res;&#125;#endifTempl(_Tp) inline _Tp gcd(_Tp x, _Tp y) &#123; return y ? gcd(y, x % y) : x; &#125;#define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout)#define PBTXDY&#125; // namespace my_stdusing namespace my_std;const int N = 100010;#define inf (0x3f3f3f3f3f3f3f3fll)struct Vertice&#123; int head;&#125;p[N];struct Edge&#123; int link, to, wgh;&#125;e[N];LL dis[N], f[N];int vis[N];static int ecnt;inline void A_E(const int &amp;u, const int &amp;v, const int &amp;w)&#123; e[++ecnt] = (Edge)&#123;p[u].head, v, w&#125;; p[u].head = ecnt;&#125;int n, m, q;priority_queue&lt;PLLI&gt; pq;inline void dijkstra()&#123; memset(dis + 1, 0x3f, sizeof(LL) * n); memset(vis + 1, 0, sizeof(int) * n); dis[1] = 0; pq.push(MP(0, 1)); Rint u; while(!pq.empty())&#123; u = pq.top().sec, pq.pop(); if(vis[u]) continue; vis[u] = 1; GO(u, p, e, i, v)&#123; v = e[i].to; if(chkmin(dis[v], dis[u] + e[i].wgh))&#123; pq.push(MP(-dis[v], v)); &#125; &#125; &#125;&#125;queue&lt;int&gt; bar[N];inline void bfs(const int &amp;cnt)&#123; memset(f + 1, 0x3f, sizeof(LL) * n); f[1] = 0, bar[0].push(1); reg LL lim = 0, val = 0; while(val &lt;= lim)&#123; Rint u; while(!bar[val].empty())&#123; u = bar[val].front(), bar[val].pop(); if(f[u] &lt; val) continue; GO(u, p, e, i, v)&#123; v = e[i].to; if(chkmin(f[v], f[u] + dis[u] - dis[v] + e[i].wgh))&#123; if(f[v] &lt;= cnt)&#123; bar[f[v]].push(v); chkmax(lim, f[v]); &#125; &#125; &#125; &#125; ++val; &#125; FOR(i, 2, n) dis[i] = min(dis[i] + f[i], inf);&#125;int main()&#123; n = read(), m = read(), q = read(); Rint u, v, w; FOR(i, 1, m)&#123; u = read(), v = read(), w = read(); A_E(u, v, w); &#125; dijkstra(); while(q--)&#123; u = read(); if(u == 1)&#123; v = read(); printf("%lld\n", dis[v] &gt;= inf ? -1 : dis[v]); &#125; else&#123; v = read(); FOR(i, 1, v) ++e[read()].wgh; bfs(min(v, n - 1)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1364E」X-OR]]></title>
    <url>%2Fblog%2FCF1364E%2F</url>
    <content type="text"><![CDATA[手造 rand 太烂，换成mt19937过了。 题意简述[CF 1364E] 你需要猜一个 $0$ 到 $n - 1$ 的排列 $\langle a_n\rangle$，每次可以询问二元组 $(x, y)$($x\neq y$) ，表示询问 $a_x | a_y$ 的值，其中 $|$ 为按位或。 $3\le n\le 2048$，询问次数不能超过 $4269$ 次。 主要思路本题有许多做法，下面放送本人认为最妙的一种方法。 假设现在有两个可能是 0 的位置 $x$ 与 $y$，设 $A(x, y) = a_x | a_y$。 考虑现在新加入一个可能是 0 的位置 $z$，如何排除一个呢？ 如果 $A(z, y) &lt; A(x, y)$，则 $x &gt; 0$，否则 $A(x, y) = y \le A(z, y)$ 矛盾。 如果 $A(z, y) &gt; A(x, y)$，则同理 $z &gt; 0$。 如果 $A(z, y) = A(x, y)$，则 $y &gt; 0$，否则 $A(z, y) = z = x = A(x, y)$ 非排列。 每个数都会被查询 1 次，并且如果出现上述最后一种情况，还应额外查询 $(x, z)$。 然后就得到了两个可能是 0 的位置。如何确定哪个是 0？随机一个 $d$，询问 $(x, d)$ 与 $(y, d)$ 直到二者答案不同，小的那个即为 0。 最后再让每个数都与 0 询问一次来获得整个排列。 明明有比 $2n$ 多的查询次数，为什么总次数是正确的？容易证明当我们按随机顺序判断每个数是否可能为 0 时，出现最后一种状况的概率极小。同样地，判断最后两个数哪个是 0 时，期望询问次数也不大。有兴趣的读者可以自己尝试证明。 由此可见，利用随机算法获取优秀的复杂度是解题的常用技巧之一。在数据结构中，典型的示例是随机堆。 参考代码注意找到两个可能是 0 的位置也要随机顺序，否则可能导致最后一种情况过多导致询问次数超限。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;#define reg registertypedef pair&lt;int, int&gt; PII;#define MP(x, y) make_pair(x, y)inline int read() &#123; reg int ans = 0, f = 1; reg char c = getchar(); while (!isdigit(c)) f ^= (c == '-'), c = getchar(); for (; isdigit(c); c = getchar()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return f ? ans : -ans;&#125;inline int chkmin(int &amp;x, const int &amp;y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;inline int chkmax(int &amp;x, const int &amp;y) &#123; return x &lt; y ? x = y, 1 : 0; &#125; #define F_O fflush(stdout)mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());const int N = 2050;int n, dd[N], p[N];//睦月、如月、弥生、卯月、皐月、水無月、文月、葉月、長月、神無月、霜月、師走map&lt;PII, int&gt; Q; inline int query(const int &amp;x, const int &amp;y)&#123; if(Q.count(MP(x, y))) return Q[MP(x, y)]; printf("? %d %d\n", x, y), F_O; return Q[MP(x, y)] = Q[MP(y, x)] = read();&#125;inline int rnd(const int &amp;lim)&#123; return mt() % lim;&#125; int main() &#123; n = read(); reg int mutsuki, kisaragi, yayoi; reg int uzuki, satsuki, minazuki; reg int fumizuki, hazuki, nagatsuki; reg int kannazuki, shimotsuki, shiwasu; for(kannazuki = 1; kannazuki &lt;= n; ++kannazuki)&#123; p[kannazuki] = kannazuki; &#125; for(shimotsuki = 1; shimotsuki &lt;= n; ++shimotsuki)&#123; swap(p[shimotsuki], p[rnd(n) + 1]); &#125; mutsuki = p[1], kisaragi = p[2], uzuki = query(p[1], p[2]); for(nagatsuki = 3; nagatsuki &lt;= n; ++nagatsuki)&#123; yayoi = p[nagatsuki]; satsuki = query(kisaragi, yayoi); if(chkmin(uzuki, satsuki))&#123; mutsuki = yayoi; &#125; else if(uzuki == satsuki)&#123; uzuki = query(mutsuki, kisaragi = yayoi); &#125; &#125; for(shiwasu = 1; shiwasu &lt;= n; ++shiwasu)&#123; swap(p[shiwasu], p[rnd(n) + 1]); &#125; fumizuki = hazuki = nagatsuki = 0; do&#123; minazuki = p[++nagatsuki]; if(minazuki == mutsuki || minazuki == kisaragi) continue; fumizuki = query(mutsuki, minazuki); hazuki = query(kisaragi, minazuki); &#125;while(fumizuki == hazuki); if(fumizuki &gt; hazuki) mutsuki = kisaragi; for(nagatsuki = 1; nagatsuki &lt;= n; ++nagatsuki)&#123; if(nagatsuki == mutsuki) continue; dd[nagatsuki] = query(nagatsuki, mutsuki); &#125; printf("! "); for(nagatsuki = 1; nagatsuki &lt;= n; ++nagatsuki)&#123; printf("%d ", dd[nagatsuki]); &#125; puts(""), F_O; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>交互题</tag>
        <tag>随机算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式板子]]></title>
    <url>%2Fblog%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[某一天发现自己的多项式板子好像全机房最慢唉。 于是找了些博客来学习卡常。 然后喜提目前全机房最快。 如何卡常取模优化众所周知 C++ 取模慢得出奇，想优化常数，自然而然想到在取模上下工夫。 曾经为了避免加减取模写了这样的东西： 123const int mod = 998244353;inline void inc(int &amp;x, const int &amp;y)&#123;if((x += y) &gt;= mod) x -= mod;&#125;inline void dec(int &amp;x, const int &amp;y)&#123;if((x -= y) &lt; 0) x += mod;&#125; 后来发现加一加减一减比一比也挺慢，于是就有了这样的东西： 12const int mod = 998244353;inline int qmo(const int &amp;x)&#123;return x + ((x &gt;&gt; 31) &amp; mod);&#125; 大概就是用了下对int型右移 31 位会使其全部变成符号位的性质。 预处理原根每次还要根据长度重新处理蝴蝶变换的数组？这里要做大量的乘法和取模，不如直接一次处理出来优化常数。 预处理要 $O(n\log n)$？长度总是 2 的次幂，完全可以只用 $O(n)$。 清空与移动数组memset与memcpy无论是否在-O2下都有优秀的表现。 DFT时使用64位无符号整数稍微算算，发现在模数是int范围内是不会爆unsigned long long的。 无符号整数在做加减乘的时候会稍微快一些。 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define FORit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b) + 1; i != ed_##i; ++i)#define ROFit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b)-1; i != ed_##i; --i)#define GO(x, p, e, i, v) for (register int i = p[x].head, v; i; i = e[i].link)#define fir first#define sec second#define pq priority_queue#define MP make_pairtypedef unsigned int uint;typedef long long LL;typedef unsigned long long uLL;typedef double DB;typedef pair&lt;int, int&gt; PII;#define Templ(T) template &lt;typename T&gt;#ifdef LOCAL#define gcr() getchar()#define pcr(x) putchar(x)#define F_In void()#define F_Out void()#elsestatic char InB[1 &lt;&lt; 21], *In_s = InB;static char OutB[1 &lt;&lt; 21], *Out_s = OutB;#define gcr() (*In_s ++)#define pcr(x) (*Out_s ++ = x)#define F_In (fread(InB, 1, 1 &lt;&lt; 21, stdin))#define F_Out (fwrite(OutB, 1, Out_s - OutB, stdout), Out_s = OutB)#endifinline int read() &#123; // reg int ans = 0, f = 1; reg int ans = 0; reg char c = gcr(); // while (!isdigit(c)) f ^= (c == '-'), c = gcr(); while (!isdigit(c)) c = gcr(); for (; isdigit(c); c = gcr()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); // return f ? ans : -ans; return ans;&#125;inline void write(int x)&#123; static int sta[12]; // if(x &lt; 0) return pcr('-'), write(-x); Rint top = 0; do&#123; sta[top ++] = x % 10, x /= 10; &#125;while(x); while(top) pcr(sta[-- top] ^ 48);&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define using_modconst int mod = 998244353;#ifdef using_modinline void inc(int &amp;x, const int &amp;y) &#123; if ((x += y) &gt;= mod) x -= mod; &#125;inline void dec(int &amp;x, const int &amp;y) &#123; if ((x -= y) &lt; 0) x += mod; &#125;inline int ksm(int x, int y) &#123; reg int res = 1; for (; y; y &gt;&gt;= 1, x = 1ll * x * x % mod) if (y &amp; 1) res = 1ll * res * x % mod; return res;&#125;inline int qmo(const int &amp;x)&#123; return x &gt;&gt; 31 ? x + mod : x;&#125;#endifTempl(_Tp) inline _Tp gcd(_Tp x, _Tp y) &#123; return y ? gcd(y, x % y) : x; &#125;#define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout)#define PBTXDY&#125; // namespace my_stdusing namespace my_std;#define swap(x, y) (x ^= y ^= x ^= y)// const int N = 270010;const int N = 2100010;int LMT = 1;int rev[N], omg[N], inv[N];int l2g[N];inline void init(const int &amp;n)&#123; inv[1] = 1; FOR(i, 2, n) inv[i] = (LL)(mod - mod / i) * inv[mod % i] % mod; l2g[1] = 0; FOR(i, 2, n &lt;&lt; 1)&#123; l2g[i] = l2g[i &gt;&gt; 1] + 1; &#125;&#125;inline int get_len(const int &amp;n)&#123; return 1 &lt;&lt; (l2g[n] + 1);&#125;inline void poly_init(const int &amp;n)&#123; Rint l = 0; while(LMT &lt;= n) LMT &lt;&lt;= 1, ++ l; FOR(i, 1, LMT - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)); reg const int t = ksm(3, (mod - 1) &gt;&gt; l); omg[LMT &gt;&gt; 1] = 1; FOR(i, (LMT &gt;&gt; 1) + 1, LMT - 1) omg[i] = (LL)omg[i - 1] * t % mod; ROF(i, (LMT &gt;&gt; 1) - 1, 1) omg[i] = omg[i &lt;&lt; 1]; LMT = l;&#125;inline void DFT(int *a, const int &amp;n)&#123; // static LL tmp[N]; static uLL tmp[N]; reg const int fix = LMT - l2g[n]; Rint t; FOR(i, 0, n - 1) tmp[i] = a[rev[i] &gt;&gt; fix]; for(Rint i = 1; i &lt; n; i &lt;&lt;= 1)&#123; for(Rint j = 0; j &lt; n; j += i &lt;&lt; 1)&#123; FOR(k, j, j + i - 1)&#123; t = tmp[i + k] * omg[i + k - j] % mod; // tmp[i + k] = qmo(tmp[k] - t); // tmp[k] = qmo(tmp[k] - mod + t); tmp[i + k] = tmp[k] + mod - t; tmp[k] += t; &#125; &#125; &#125; FOR(i, 0, n - 1) a[i] = tmp[i];&#125;inline void IDFT(int *a, const int &amp;n)&#123; reverse(a + 1, a + n); DFT(a, n); reg const int bk = mod - (mod - 1) / n; FOR(i, 0, n - 1) a[i] = (LL)a[i] * bk % mod;&#125;//c &lt;- a * binline void poly_mul(int *a, int *b, int *c, const int &amp;deg)&#123; static int tmp1[N], tmp2[N]; reg const int len = get_len(deg); memcpy(tmp1, a, sizeof(int) * len), memcpy(tmp2, b, sizeof(int) * len); DFT(tmp1, len), DFT(tmp2, len); FOR(i, 0, len - 1) c[i] = (LL)tmp1[i] * tmp2[i] % mod; IDFT(c, len);&#125;//b &lt;- a ^ (-1)inline void poly_inv(int *a, int *b, const int &amp;deg)&#123; static int tmp[N]; if(deg == 1)&#123; b[0] = ksm(a[0], mod - 2); return; &#125; poly_inv(a, b, (deg + 1) &gt;&gt; 1); reg const int len = get_len(deg &lt;&lt; 1); memcpy(tmp, a, sizeof(int) * deg); memset(tmp + deg, 0, sizeof(int) * (len - deg)); DFT(b, len), DFT(tmp, len); FOR(i, 0, len - 1)&#123; b[i] = (LL)qmo(2 - (LL)b[i] * tmp[i] % mod) * b[i] % mod; &#125; IDFT(b, len); memset(b + deg, 0, sizeof(int) * (len - deg));&#125;//b(x) &lt;- \d a(x) / \d xinline void poly_der(int *a, int *b, const int &amp;deg)&#123; FOR(i, 0, deg - 2) b[i] = (LL)a[i + 1] * (i + 1) % mod; b[deg - 1] = 0;&#125;//b(x) &lt;- \int a(x) \d xinline void poly_int(int *a, int *b, const int &amp;deg)&#123; FOR(i, 1, deg - 1) b[i] = (LL)a[i - 1] * inv[i] % mod; b[0] = 0;&#125;//b &lt;- \ln ainline void poly_ln(int *a, int *b, const int &amp;deg)&#123; static int tmp[N]; poly_inv(a, tmp, deg); poly_der(a, b, deg); reg const int len = get_len(deg &lt;&lt; 1); DFT(b, len), DFT(tmp, len); FOR(i, 0, len - 1) tmp[i] = (LL)tmp[i] * b[i] % mod; IDFT(tmp, len); poly_int(tmp, b, deg); memset(b + deg, 0, sizeof(int) * (len - deg)); memset(tmp, 0, sizeof(int) * len);&#125;//b &lt;- \exp ainline void poly_exp(int *a, int *b, const int &amp;deg)&#123; static int tmp[N]; if(deg == 1)&#123; b[0] = 1; return; &#125; poly_exp(a, b, (deg + 1) &gt;&gt; 1); poly_ln(b, tmp, deg); reg const int len = get_len(deg &lt;&lt; 1); FOR(i, 0, len - 1)&#123; if(i &lt; deg) tmp[i] = qmo(a[i] - tmp[i]); else tmp[i] = 0; &#125; ++tmp[0]; DFT(b, len), DFT(tmp, len); FOR(i, 0, len - 1)&#123; b[i] = (LL)tmp[i] * b[i] % mod; &#125; IDFT(b, len); memset(b + deg, 0, sizeof(int) * (len - deg)); memset(tmp + deg, 0, sizeof(int) * (len - deg));&#125;int main() &#123; F_In; F_Out; return 0;&#125; 即使在你谷巨慢的评测机下都能够跑过机房其他人在你谷评测机还没那么慢的时候跑的 exp 。 参考资料yurzhang’s blog]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>卡常</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2011」竞赛实验班]]></title>
    <url>%2Fblog%2FYnoi2011-%E7%AB%9E%E8%B5%9B%E5%AE%9E%E9%AA%8C%E7%8F%AD%2F</url>
    <content type="text"><![CDATA[算是 Ynoi 里面较简单和套路的一题吧。 题意简述给定一个初始长为 $n$ 的数组 $A$ ，有 $m$ 个操作： 在末尾加入 $x$。 求 $\sum\limits_{i=l}^{r} A_i$。 将整个数组异或上 $x$。 将整个数组排序。 $n, m\le 10^5, 0\le x, a_i \le 10^9$，不必强制在线。 [Luogu 5312] 主要思路没有操作 1 的话大家都会，只要建棵 Trie 就能 $O(\log^2 W)$ 求最小的 $k$ 个数的和。（$O(W)$ 为值域） 大概就是每个点 $O(\log W)$ 空间存一下子树内每一位分别为 $1$ 的数的个数。 那么现在加上在末尾插入的操作，显然整个数列是前面一段有序的和后面一段无序的。无序的显然可以直接前缀和一下，$O(\log W)$ 求出某一段的和。 如果需要排序整个序列，就把前缀和清零一下，然后把每个未排序的数扔到 Trie 里去，单次 $O(\log^2 W)$。每个数只会进入 Trie 一次，故总复杂度 $O((n + m) \log^2 W)$ 。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define FORit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b) + 1; i != ed_##i; ++i)#define ROFit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b)-1; i != ed_##i; --i)#define GO(x, p, e, i, v) for (register int i = p[x].head, v; i; i = e[i].link)#define MEM(x, v) memset(x, v, sizeof(x))#define fir first#define sec second#define pq priority_queue#define MP make_pairtypedef long long LL;typedef double DB;typedef pair&lt;int, int&gt; PII;#define Templ(T) template &lt;typename T&gt;static char InB[1 &lt;&lt; 21], *In_s = InB, *In_t = InB;static char OutB[1 &lt;&lt; 21], *Out_s = OutB;inline void FGO()&#123; fwrite(OutB, 1, Out_s - OutB, stdout), Out_s = OutB; return;&#125;inline char gcr()&#123; if(In_s == In_t)&#123; In_t = (In_s = InB) + fread(InB, 1, 1 &lt;&lt; 21, stdin); if(In_s == In_t) return EOF; &#125; return *In_s ++;&#125;inline void pcr(const char &amp;c)&#123; if(Out_s - OutB == 1 &lt;&lt; 21) fwrite(OutB, 1, 1 &lt;&lt; 21, stdout), Out_s = OutB; *Out_s ++ = c;&#125;inline int read() &#123; reg int ans = 0; reg char c = gcr(); while (!isdigit(c)) c = gcr(); for (; isdigit(c); c = gcr()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return ans;&#125;inline void write(LL x)&#123; static int sta[12]; if(x &lt; 0) return pcr('-'), write(-x); Rint top = 0; do&#123; sta[top ++] = x % 10, x /= 10; &#125;while(x); while(top) pcr(sta[-- top] ^ 48);&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define using_modconst int mod = 998244353;#ifdef using_modinline void inc(int &amp;x, const int &amp;y) &#123; x += y; if (x &gt;= mod) x -= mod; &#125;inline void dec(int &amp;x, const int &amp;y) &#123; x -= y; if (x &lt; 0) x += mod; &#125;inline int ksm(int x, LL y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = 1ll * x * x % mod) if (y &amp; 1) res = 1ll * res * x % mod; return res;&#125;#endifTempl(_Tp) inline _Tp gcd(_Tp x, _Tp y) &#123; return y ? gcd(y, x % y) : x; &#125;#define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout)&#125; // namespace my_stdusing namespace my_std;const int N = 200020, M = 31, NM = 33;int n, m, sn;//sn: sorted_lengthLL sn_q;int a[N], pre[N][NM];//pre[p][k]: 现在未排序段到第 p 个数中有多少个第 k 位为 1 的数int ch[N &lt;&lt; 5][2], cnt[N &lt;&lt; 5][NM], siz[N &lt;&lt; 5], node_cnt = 1;//cnt[u][k]: 节点 u 子树内有多少个第 k 位为 1 的数int rev[NM], xr;//rev[i]: （对 trie）第 i 位是否交换; xr: 整个序列被 xor 的值//trie 应按位从大到小操作inline LL soq(int p)&#123;//sorted_query if(!p) return 0; reg LL res = 0; Rint v = 0, u = 1; ROF(k, M - 1, 0)&#123; if(p &lt;= siz[ch[u][rev[k]]])&#123; u = ch[u][rev[k]], v |= rev[k] &lt;&lt; k; &#125;//没有该位置为 1 的数 else&#123; Rint id = ch[u][rev[k]], tmp; p -= siz[id]; FOR(t, 0, M - 1)&#123; tmp = cnt[id][t]; res += (LL)(((xr &gt;&gt; t) &amp; 1) ? siz[id] - tmp : tmp) &lt;&lt; t; &#125; u = ch[u][rev[k] ^ 1]; v |= (rev[k] ^ 1) &lt;&lt; k; &#125; &#125; //最后剩下的都是 v return res + (LL)p * (v ^ xr);&#125;inline LL scq(int l, int r)&#123;//scattered_query Rint len = r - l + 1, tmp; reg LL res = 0; FOR(k, 0, M - 1)&#123; tmp = pre[r][k] - pre[l - 1][k]; res += (LL)(((xr &gt;&gt; k) &amp; 1) ? len - tmp : tmp) &lt;&lt; k; &#125; return res;&#125;inline LL query(int l, int r)&#123; if(r &lt;= sn) return soq(r) - soq(l - 1); if(l &gt; sn) return scq(l, r); return soq(sn) - soq(l - 1) + scq(sn + 1, r);&#125;inline void insert(int x)&#123; ++ siz[1]; FOR(t, 0, M - 1) cnt[1][t] += (x &gt;&gt; t) &amp; 1; Rint u = 1, d; ROF(k, M - 1, 0)&#123; d = (x &gt;&gt; k) &amp; 1; u = ch[u][d] ? ch[u][d] : ch[u][d] = ++ node_cnt; ++ siz[u]; FOR(t, 0, M - 1) cnt[u][t] += (x &gt;&gt; t) &amp; 1; &#125; return;&#125;int main()&#123; n = read(), sn = 0; FOR(i, 1, n)&#123; a[i] = read(); FOR(k, 0, M - 1) pre[i][k] = pre[i - 1][k] + ((a[i] &gt;&gt; k) &amp; 1); &#125; m = read(); Rint sta, l, r; while(m --)&#123; sta = read(); if(sta == 1)&#123; a[++ n] = read() ^ xr; FOR(k, 0, M - 1) pre[n][k] = pre[n - 1][k] + ((a[n] &gt;&gt; k) &amp; 1); &#125;else if(sta == 2)&#123; l = read(), r = read(); // printf("%lld\n", query(l, r)); write(query(l, r)), pcr('\n'); &#125;else if(sta == 3)&#123; l = read(), xr ^= l; &#125;else if(sta == 4)&#123; while(sn &lt; n) insert(a[++ sn]); FOR(k, 0, M - 1) rev[k] = (xr &gt;&gt; k) &amp; 1; FOR(k, 0, M - 1) pre[n][k] = 0; sn_q = soq(sn); &#125; &#125; return FGO(), 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Ynoi</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2010」y-fast trie]]></title>
    <url>%2Fblog%2FYnoi2010-y-fast-trie%2F</url>
    <content type="text"><![CDATA[我谔谔，被卡常力，，， 题意简述给定一个数 $C$ ，维护一个集合 $S$，支持 $n$ 次操作，操作是加入或删除一个数 $x$。 每次操作结束后求集合中两个数的和模 $C$ 的最大值，强制在线。 $n\le 5\times 10^5$。 [Luogu 6105] 主要思路首先把数都模 $C$，然后答案只有可能是两数的和或两数的和减去 $C$。 后者直接把两个最大的数拎出来求一下得了，非常好搞。 考虑前者如何处理。 再把这里的答案分成两个相等数和两个不等数，前者显然也随便做。 对于每个 $x\in S$，容易找到 $y\in S, y\neq x$ 使得对于 $x$ 答案最优（即 $x + y$ 最接近 $C$）。 试图对每个 $x\in S$ 维护一个匹配 $(x, y)$。 此时发现删除 $x$ 不好删，万一有一大堆数的最优匹配都是 $x$ 呢？复杂度退化。 于是考虑令每个数只在一个匹配中，即令匹配为双向的。这样复杂度可以保证，那么正确性呢？ 考虑 $(y, z)$ 为匹配，此时加入 $x$，其最优匹配为 $y$ 且 $x &gt; z$。此时若 $x$ 不删去，$z$ 永远不能成为 $y$ 的最优解。 所以每次删除数对其匹配更新一下即可保证正确性。 复杂度 $O(n\log n)$。 参考代码比较卡常，搞了好久才过，，， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;bits/stdc++.h&gt;namespace my_std &#123;using namespace std;#define reg register#define Rint register int#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i &lt;= ed_##i; ++i)#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i &gt;= ed_##i; --i)#define FORit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b) + 1; i != ed_##i; ++i)#define ROFit(templ, arr, i, a, b) \for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b)-1; i != ed_##i; --i)#define GO(x, p, e, i, v) for (register int i = p[x].head, v; i; i = e[i].link)#define MEM(x, v) memset(x, v, sizeof(x))#define fir first#define sec second#define Templ(T) template &lt;typename T&gt;static char InB[1 &lt;&lt; 23], *In_s = InB, *In_t = InB;static char OutB[1 &lt;&lt; 23], *Out_s = OutB;inline void FGO()&#123; fwrite(OutB, 1, Out_s - OutB, stdout), Out_s = OutB; return;&#125;inline void FGI()&#123; In_t = (In_s = InB) + fread(InB, 1, 1 &lt;&lt; 23, stdin); return;&#125;inline char gcr()&#123; // if(In_s == In_t)&#123; // In_t = (In_s = InB) + fread(InB, 1, 1 &lt;&lt; 23, stdin); // if(In_s == In_t) return EOF; // &#125; return *In_s ++;&#125;inline void pcr(const char &amp;c)&#123; // if(Out_s - OutB == 1 &lt;&lt; 23) fwrite(OutB, 1, 1 &lt;&lt; 23, stdout), Out_s = OutB; *Out_s ++ = c;&#125;inline int read() &#123; reg int ans = 0; reg char c = gcr(); while (!isdigit(c)) c = gcr(); for (; isdigit(c); c = gcr()) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + (c ^ 48); return ans;&#125;inline void write(int x)&#123; static int sta[12]; if(x &lt; 0) return pcr('-'), write(-x); Rint top = 0; do&#123; sta[top ++] = x % 10, x /= 10; &#125;while(x); while(top) pcr(sta[-- top] ^ 48);&#125;Templ(_Tp) inline int chkmin(_Tp &amp;x, _Tp y) &#123; return x &gt; y ? x = y, 1 : 0; &#125;Templ(_Tp) inline int chkmax(_Tp &amp;x, _Tp y) &#123; return x &lt; y ? x = y, 1 : 0; &#125;#define PBTXDY&#125; // namespace my_stdusing namespace my_std;typedef map&lt;int, int&gt;::iterator m_it;typedef multiset&lt;int&gt;::iterator ms_it;int n, C, siz;map&lt;int, int&gt; cnt;unordered_map&lt;int, int&gt; pr;multiset&lt;int&gt; df;set&lt;int&gt; sm;inline int match(int x)&#123; reg m_it it = --cnt.lower_bound(C - x); if(it-&gt;fir == x) --it; return it-&gt;fir;&#125;inline void init(int x)&#123; Rint y = match(x), z; if(y == -1) return; if(pr.count(y))&#123; z = pr[y]; if(z &lt; x)&#123; pr.erase(z), pr[x] = y, pr[y] = x; df.erase(df.find(z + y)), df.insert(x + y); //把 z 从匹配中删去 &#125; &#125; else&#123; pr[y] = x, pr[x] = y; df.insert(x + y); &#125; return;&#125;inline void add(int x)&#123; Rint cnt_ = ++ cnt[x]; if(cnt_ == 1) return init(x);//第一次出现 if(cnt_ == 2 &amp;&amp; 2 * x &lt; C) sm.insert(2 * x);&#125;inline void del(int x)&#123; Rint cnt_ = -- cnt[x]; if(!cnt_)&#123; cnt.erase(x); Rint y; if(pr.count(x))&#123; y = pr[x]; pr.erase(y), pr.erase(x); df.erase(df.find(x + y)), init(y); //把整个匹配都删了，再把 y 加回去 &#125; return; &#125; if(cnt_ == 1 &amp;&amp; 2 * x &lt; C) sm.erase(2 * x);&#125;inline int query()&#123; Rint ans = 0; reg m_it it = --cnt.end(); ans = (it-&gt;sec &gt; 1) ? 2 * it-&gt;fir % C : (it-&gt;fir + (--it)-&gt;fir) % C; if(!sm.empty()) chkmax(ans, *(--sm.end())); if(!df.empty()) chkmax(ans, *(--df.end())); return ans;&#125;int main() &#123; FGI(); cnt[-1] = 1; n = read(), C = read(); Rint opt, x, lastans = 0; while(n --)&#123; opt = read(), x = (read() ^ lastans) % C; opt == 1 ? (add(x), ++siz) : (del(x), --siz); // if(siz &gt; 1) printf("%d\n", lastans = query()); // else puts("EE"), lastans = 0; if(siz &gt; 1) write(lastans = query()); else pcr('E'), pcr('E'), lastans = 0; pcr('\n'); &#125;//我谔谔，，， return FGO(), 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Ynoi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调和专题]]></title>
    <url>%2Fblog%2F%E8%B0%83%E5%92%8C%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[调和太有意思了，所以就有了这篇博客。 基本定义调和点列【定义1.1】对于线段 $AB$ 的内分点 $C$ 和外分点 $D$，若满足 $\dfrac{AC}{BC}=\dfrac{AD}{BD}$，即内分比等于外分比，则称点 $C, D$ 调和分割线段 $AB$，或者点 $A, B, C, D$ 为调和点列。 若直线 $l$ 上，点 $C, D$ 调和分割线段 $AB$，$M$ 为 $AB$ 中点，则有： 【性质1.1】点 $A, B$ 调和分割线段 $CD$。 【性质1.2】$\dfrac{1}{AC} + \dfrac{1}{AD} = \dfrac{2}{AB}$。 【性质1.3】$AB\cdot CD = 2AD\cdot BC$。 【性质1.4】$CA\cdot CB = CM\cdot CD$，$DA\cdot DB = DM\cdot DC$。 【性质1.5】$MA^2 = MB^2 = MC\cdot MD$。这说明，任意做过点 $C, D$ 的 $\odot \Gamma$ 及与直线 $l$ 相切于点 $B$ 的 $\odot O$，则点 $M$ 对 $\odot \Gamma, \odot O$ 的幂相等，即其在 $\odot \Gamma, \odot O$ 的根轴上。 证明非常显然。 【性质1.6】如下图，$\triangle{ABC}$ 的内切圆 $\odot I$ 与三边分别切于 $D, E, F$，直线 $EF, BC$ 交于点 $P$，则 $B, C, D, P$ 成调和点列。 证明： 对 $\triangle{ABC}$ 及其截线 $FEP$ 用 Menelaus 定理得$\dfrac{AF}{FB}\cdot\dfrac{BP}{PC}\cdot\dfrac{CE}{EA} = 1$。又 $AE = AF, BF = BD, CE = CD$，故 $\dfrac{BD}{DC} = \dfrac{BP}{PC}$，根据【定义1.1】$B, C, D, P$ 成调和点列。 调和线束【定义2.1】若一条直线上的点 $A, B, C, D$ 为一组调和点列，点 $P$ 不在直线上，连接 $PA, PB, PC, PD$，则 $PA, PB, PC, PD$ 为一组调和线束。 【性质2.1】对于直线 $l$ 上顺序四点 $A, C, B, D$ 与直线 $l$ 外一点 $P$，则 $\dfrac{\sin\angle{APC}}{\sin\angle{BPC}}=\dfrac{\sin\angle{APD}}{\sin\angle{BPD}}$ 等价于 $A, B, C, D$ 成调和点列。 证明： $A, B, C, D$ 成调和点列 $\iff \dfrac{AC}{BC} = \dfrac{AD}{BD}$而 $\dfrac{AC}{BC} = \dfrac{PA\sin\angle{APC}}{PB\sin\angle{BPC}}, \dfrac{AD}{BD} = \dfrac{PA\sin\angle{APD}}{PB\sin\angle{BPD}}$故 $\dfrac{\sin\angle{APC}}{\sin\angle{BPC}}=\dfrac{\sin\angle{APD}}{\sin\angle{BPD}}\iff\dfrac{AC}{BC} = \dfrac{AD}{BD}$，证毕。 在一些地方【性质2.1】被作为调和线束的定义，但本处我们用调和点列来定义调和线束。 【性质2.2】对于调和点列 $PA, PB, PC, PD$，作不过 $P$ 的另一直线截该调和点列于点 $A’, B’, C’, D’$，则 $A’, B’, C’, D’$ 也为调和点列。 观察到【性质2.1】仅与 $PA, PB, PC, PD$ 四条直线间夹角有关而与直线 $l$ 的选取无关，故显然正确。 【性质2.3】对于直线 $l$ 上顺次四点 $A, C, B, D$ 及直线 $l$ 外一点 $P$，以下四个条件中任意两个可推出另外两个： $A, B, C, D$ 成调和点列； $CP\perp PD$； $PC$ 平分 $\angle{APB}$； $PD$ 平分 $\angle{APB}$ 外角。 证明： 均较显然，以下仅给出1,2推3,4及3,4推1,2的证明。 1,2推3,4: 由1,2知 $\dfrac{\sin\angle{APC}}{\sin\angle{BPC}}=\dfrac{\sin\angle{APD}}{\sin\angle{BPD}} = \dfrac{\sin(\frac{\pi}{2}+\angle{APC})}{\sin(\frac{\pi}{2}-\angle{BPC})}=\dfrac{\cos\angle{APC}}{\cos\angle{BPC}}$，易得3,4。 3,4推1,2: 2显然成立。由3知 $\dfrac{AC}{BC}=\dfrac{S_{\triangle{APC}}}{S_{\triangle{BPC}}}=\dfrac{AP}{BP}$由4知 $\dfrac{AD}{BD}=\dfrac{S_{\triangle{APD}}}{S_{\triangle{BPD}}}=\dfrac{AP}{BP}$故 $\dfrac{AC}{BC}=\dfrac{AD}{BD}$，得证。 调和四边形【定义3.1】设 $ABCD$ 为圆内接四边形，若满足 $AB\cdot CD = AD\cdot BC$，则称四边形 $ABCD$ 为调和四边形。 【性质3.1】$ABCD$ 为 $\odot O$ 的内接四边形，则过 $A, C$ 作切线 $PA, PC$，且 $P, B, D$ 共线为 $ABCD$ 是调和四边形的充分必要条件。 【性质3.2】$ABCD$ 为 $\odot O$ 的内接四边形，则取 $\odot O$ 上任意一点 $P$，$PA, PB, PC, PD$ 为调和线束为 $ABCD$ 是调和四边形的充分必要条件。 证明： 极点与极线设 $\odot O$ 半径为 $R$。 【定义4.1】对于不同于 $\odot O$ 的任意一点 $P$，作一直线 $l$ 通过 $P$ 的反演像 $P’$（即 $O, P, P’$ 共线且 $OP\cdot OP’ = R^2$）且垂直于射线 $OP$，则称直线 $l$ 为点 $P$ 的极线，点 $P$ 为直线 $l$ 的极点。 【性质4.1】显然，对于 $\odot O$ 外的一点 $P$，做切线 $PQ_1, PQ_2$，则 $P$ 的极线为 $Q_1Q_2$。 【性质4.2】（配极定理）若点 $A$ 的极线穿过点 $D$，则点 $D$ 的极线也穿过点 $A$，一般称 $A, D$ 互为共轭点。设 $\operatorname{cp}(A, \odot O)$ 为点 $A$ 对 $\odot O$ 的幂，则此时有 $AD^2 = \operatorname{cp}(A, \odot O) + \operatorname{cp}(D, \odot O)$。 证明： 陪位中线阿波罗尼斯圆稍微深入些的性质回到内切圆构型以下构型在内切圆基础上延伸。 【性质5.1】 如图，过点 $D$ 作 $EF$ 的垂线，垂足为 $K$，则 $DK$ 平分 $\angle{BKC}$。 证明： 由【性质1.6】与【性质2.3】既得。 【性质5.2】 在上图的基础上，$H$ 是 $\triangle{ABC}$ 垂心，则直线 $KH$ 与 $KI$ 关于直线 $KD$ 对称。 证明： 设直线 $BH, EF$ 交于 $X$，直线 $CH, EF$ 交于 $Y$。 由【性质5.1】易得 $\triangle{BFK}\sim\triangle{CEK}$由于 $BX\parallel IE, CY\parallel IF$，故 $\triangle{EIF}\sim\triangle{YHX}$且知 $\triangle{BFX}\sim\triangle{CEY}\Rightarrow\dfrac{FX}{EY}=\dfrac{BF}{CE}=\dfrac{FK}{EK}=\dfrac{FX-FK}{EY-EK}=\dfrac{KX}{KY}$则 $\triangle{EIF}\sim\triangle{YHX}$，且 $K$ 与 $K$ 是对应点，故 $\angle{FKI}=\angle{EKH}$又 $DK\perp EF$，故直线 $KH$ 与 $KI$ 关于直线 $KD$ 对称 （$I, H$ 未必在直线 $EF$ 的同一侧，但以上证明对于是否在同一侧均适用） 例题]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeChef FGTREE」Forgotten Tree 9]]></title>
    <url>%2Fblog%2FCodeChef-FGTREE%2F</url>
    <content type="text"><![CDATA[很妙的一道交互。 [CodeChef FGTREE] 题意简述一棵 $n$ 个点的有根二叉树，树中节点编号为中序遍历中的 dfs 序。其中 $n \le 100$ 。 你可以询问不超过 $300$ 次形如 $(i, l, r)$ 的问题，表示询问 $i$ 子树内编号最小值是否为 $l$ 且最大值是否为 $r$ 。 请回答每个点的父亲的编号。 主要思路考虑按照编号从小到大尝试确定父亲。维护一个栈来存储还没有确定父亲的节点。不妨设我们已经加入到点 $x$ 。 先判断其是否在栈顶的子树中，若是则直接压入栈中；否则弹出栈顶并继续直到可压入栈中。 考虑过程中弹出的点按弹出先后为 $\langle v_m\rangle$，则弹出的点子树中的最大编号均为 $x - 1$，故 $\mathrm{fth}(v_i) = v_{i + 1}$（$v_{m + 1} = x$）。 加入所有点后，若栈非空，不难发现这些点子树中最大编号均为 $n$，故也相邻两点有父子关系。 那么在此过程中如何判断 $x$ 是否在某个点 $y$ 的子树内？可以询问 $(y, l_y, x - 1)$，若返回值为假则在子树中。而 $l_y$ 显然可以在过程中更新。 于是做完，查询次数 $O(n)$，据说可以卡满。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;#define F_O fflush(stdout)const int N = 110;class Stack&#123;private: int a[N], t;public: inline bool empty()&#123; return t == 0; &#125; inline int size()&#123; return t; &#125; inline int top()&#123; return t ? a[t - 1] : -1; &#125; inline bool pop()&#123; return t ? (-- t, 1) : 0; &#125; inline void push(int x)&#123; a[t ++] = x; &#125; inline void clear()&#123; t = 0; &#125; inline void print()&#123; puts("Stack:"); for(int i = 0; i &lt; t; ++i)&#123; printf("%d, ", a[i]); &#125; puts(""); &#125;&#125;;int n, f[N], l[N];Stack S, T;inline bool query(int x, int l, int r)&#123; printf("Q %d %d %d\n", x, l, r); F_O; char c[5]; scanf("%s", c); return *c == 'Y';&#125;inline void work()&#123; scanf("%d", &amp;n); S.clear(), T.clear(); memset(f, 0, sizeof(f)); int t; for(int x = 1; x &lt;= n; ++x) l[x] = x; for(int x = 1; x &lt;= n; ++x)&#123; while(!S.empty())&#123; t = S.top(); S.pop(); bool g = query(t, l[t], x - 1); if(!g)&#123; S.push(t); break; &#125; T.push(t); &#125; if(!T.empty())&#123; l[x] = l[T.top()]; T.push(x); t = 0; while(!T.empty())&#123; f[T.top()] = t; t = T.top(); T.pop(); &#125; &#125; S.push(x); &#125; while(!S.empty())&#123; t = S.top(); S.pop(); f[t] = S.top(); &#125; printf("A "); for(int x = 1; x &lt; n; ++x) printf("%d ", f[x]); printf("%d\n", f[n]); F_O; return;&#125;int main()&#123; int esac; scanf("%d", &amp;esac); while(esac --) work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>猜结论</tag>
        <tag>交互题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF793F」Julia the snail]]></title>
    <url>%2Fblog%2FCF793F%2F</url>
    <content type="text"><![CDATA[《关于本弱智为了减小常数而手动讨论导致写错调到死这件事》 [CF 793F] 题意简述有一只蜗牛在树干上爬，有两种移动方式，沿着某根绳子向上爬，或者顺着树干往下溜。 树干高度为 $n$，有 $m$ 根绳子，第 $i$ 条连接了高度 $l_i$ 至 $r_i$，保证 $r_i$ 互不相同。 有 $q$ 次询问，每次给出两个数 $L, R$ ，问蜗牛从高度 $L$ 开始爬，只考虑被包含在 $[L, R]$ 间的绳子（即若一条绳子的区间超出询问范围即不能使用），蜗牛能够爬到的最大高度。 $1 \le n, m, q \le 10^5$ ，输入均为正整数。 主要思路$O(n\sqrt{n})$ 做法假设我们要处理右端点为 $R_0$ 的所有询问，则可以将右端点不超过 $R_0$ 的绳子按左端点降序排序，依次插入，用单调栈维护当前被绳子覆盖的区间，在 $O(n)$ 时间内解决。 则考虑回滚莫队，块长为 $\sqrt{n}$ 。我们现在试图一次处理完右端点在某个块 $b$ 中的所有询问。定义该块前最右点为 $R_0$，右端点落在该块中的绳子称为「该块中的绳子」，落在该块前的称为「已处理的绳子」。 显然对于一个从 $x$ 出发的询问，必定先沿着已处理的绳子走到最右端后，再试图沿着该块中的绳子走。所以将该块中的绳子按左端点升序排序后，能走就走即可。 $O(n\log{n})$ 做法考虑按右端点从左到右地处理每个询问。设当前处理到的右端点为 $R_0$ ，当前从 $x$ 出发的询问的答案为 $a_x$ 。 假设右端点右移一格，加入一条绳子 $[L_0, R_0 + 1]$。对于 $x &gt; L_0$，这条绳子因不在询问区间内而不会产生任何影响。对于 $x \le L_0$，若 $a_x &lt; L_0$ ，则因本来就无法碰到该线段所在位置而不会产生任何影响；而对于 $a_x \ge L_0$，有 $a_x\gets R_0 + 1$。 形式化地，相当于维护序列 $\langle a\rangle$，有两个操作： 将区间中不小于 $x$ 的数设为 $y$； 单点求值。 这不是 jiry_2 老师的线段树么。 大概就是对每个节点记录最大值与严格次大值 $fir, sec$，和一个二元的 tag $(x, y)$，即将不小于 $x$ 的数改为 $y$。 下传标记操作的时候就将儿子的 $y$ 改成自己的 $y$（由于绳子按右端点升序排序，这样显然更优），而在 $x$ 已有值时应改为较小值。 然后本人因为上传节点操作试图卡常写挂了 于是 $O(n\log n)$ 了。（复杂度证明详见 jls 原课件） 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue // #define MP make_pair typedef long long LL; typedef double DB; // typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout) #define PBTXDY&#125;using namespace my_std;struct my_pair&#123; int first, second; inline my_pair(int f = 0, int s = 0)&#123; first = f, second = s; &#125;&#125;;#define MP(a, b) my_pair(a, b)const int N = 100010, inf = 1145141919;int n, m, q;int lft[N], ans[N];vector&lt;my_pair&gt; Q[N];my_pair a[N &lt;&lt; 2], tag[N &lt;&lt; 2];inline void merge_node(int x, int y)&#123; reg my_pair res = a[y]; if(res.fir &gt; a[x].fir)&#123; a[x].sec = a[x].fir, a[x].fir = res.fir; chkmax(a[x].sec, res.sec); &#125; else if(res.fir &lt; a[x].fir)&#123; chkmax(a[x].sec, res.fir); &#125; else&#123; chkmax(a[x].sec, res.sec); &#125;&#125;inline void merge_tag(int x, int y)&#123; reg my_pair res = tag[y]; if(a[x].fir &gt;= res.sec)&#123; a[x].fir = res.fir; if(!tag[x].sec) tag[x].sec = res.sec; else chkmin(tag[x].sec, res.sec); tag[x].fir = res.fir; &#125;&#125;inline void push_up(int t)&#123; a[t] = a[t &lt;&lt; 1], merge_node(t, t &lt;&lt; 1 | 1);&#125;inline void push_down(int t)&#123; if(tag[t].fir)&#123; merge_tag(t &lt;&lt; 1, t), merge_tag(t &lt;&lt; 1 | 1, t); tag[t] = MP(0, 0); &#125; return;&#125;void build(int t, int l, int r)&#123; if(l == r) return a[t] = my_pair(l, -inf), void(); Rint mid = (l + r) &gt;&gt; 1; build(t &lt;&lt; 1, l, mid), build(t &lt;&lt; 1 | 1, mid + 1, r); return push_up(t);&#125;void update(int t, int l, int r, int L, int R, my_pair x)&#123; if(a[t].fir &lt; x.sec) return; if(L &lt;= l &amp;&amp; r &lt;= R &amp;&amp; a[t].sec &lt; x.sec) return *tag = x, merge_tag(t, 0); push_down(t); Rint mid = (l + r) &gt;&gt; 1; if(L &lt;= mid) update(t &lt;&lt; 1, l, mid, L, R, x); if(R &gt; mid) update(t &lt;&lt; 1 | 1, mid + 1, r, L, R, x); return push_up(t);&#125;int query(int t, int l, int r, int x)&#123; if(l == r) return a[t].fir; push_down(t); Rint mid = (l + r) &gt;&gt; 1; return x &lt;= mid ? query(t &lt;&lt; 1, l, mid, x) : query(t &lt;&lt; 1 | 1, mid + 1, r, x);&#125;int main()&#123; n = read(); m = read(); Rint l, r; FOR(i, 1, m)&#123; l = read(), r = read(); lft[r] = l; &#125; q = read(); FOR(i, 1, q)&#123; l = read(), r = read(); Q[r].push_back(MP(l, i)); &#125; build(1, 1, n); FOR(i, 1, n)&#123; if(lft[i]) update(1, 1, n, 1, lft[i], MP(i, lft[i])); for(my_pair &amp;x : Q[i])&#123; ans[x.sec] = query(1, 1, n, x.fir); &#125; &#125; FOR(i, 1, q) printf("%d\n", ans[i]); return 0;&#125; 参考资料Segment Tree Beats! ZigZagK 的博客]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>log数据结构</tag>
        <tag>莫队</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aria2和BT下载]]></title>
    <url>%2Fblog%2Faria2%E5%92%8CBT%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[下 gal 被屑度网盘限速了，在再次寻找对抗限速的方法时顺带搞好了 aria2 环境和 BT 下载环境。可惜没有公网 ip ，否则「下载」二字即可去掉。 然而最后也没有成功对抗限速。 aria2aria2 GitHub仓库AriaNg GitHub仓库Aria2 for Chrome 参考资料Aria2 &amp; YAAW 使用说明老王的自留地 | 关于aria2最完整的一篇悠然 | Aria2基础上手指南andforce | aria2使用教程 下载先到 releases 去下载需要的版本。 本人 windows 64 位机下解压所得如下： 123456789aria2│ aria2c.exe│ AUTHORS│ ChangeLog│ COPYING│ LICENSE.OpenSSL│ NEWS│ README.html│ README.mingw 以下所指操作位置，若未特别说明，均在 aria2 文件夹下。 创建 3 个空文件：aria2.conf, aria2.log, aria2.session，分别作为配置文件、日志文件、会话文件。 aria2.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118## &apos;#&apos;开头为注释内容, 选项都有相应的注释说明, 根据需要修改 #### 被注释的选项填写的是默认值, 建议在需要修改时再取消注释 #### 文件保存相关 ### 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置dir=./downloads/# 日志的保存路径log=./aria2.log# 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M#disk-cache=32M# 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc# 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc# falloc和trunc则需要文件系统和内核支持# NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项file-allocation=falloc# 断点续传continue=true## 下载连接相关 ### 最大同时下载任务数, 运行时可修改, 默认:5max-concurrent-downloads=4# 同一服务器连接数, 添加时可指定, 默认:1max-connection-per-server=8# 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M# 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载min-split-size=8M# 单个任务最大线程数, 添加时可指定, 默认:5split=32# 整体下载速度限制, 运行时可修改, 默认:0max-overall-download-limit=0# 单个任务下载速度限制, 默认:0max-download-limit=0# 整体上传速度限制, 运行时可修改, 默认:0max-overall-upload-limit=0# 单个任务上传速度限制, 默认:0max-upload-limit=0# 禁用IPv6, 默认:falsedisable-ipv6=true# 连接超时时间, 默认:60timeout=60# 最大重试次数, 设置为0表示不限制重试次数, 默认:5max-tries=0# 设置重试等待的秒数, 默认:0retry-wait=0## 进度保存相关 ### 从会话文件中读取下载任务input-file=./aria2.session# 在Aria2退出时保存`错误/未完成`的下载任务到会话文件save-session=./aria2.session# 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0#save-session-interval=60## RPC相关设置 ### 启用RPC, 默认:falseenable-rpc=true# 允许所有来源, 默认:falserpc-allow-origin-all=true# 允许非外部访问, 默认:falserpc-listen-all=true# 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同#event-poll=select# RPC监听端口, 端口被占用时可以修改, 默认:6800rpc-listen-port=6800# 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项#rpc-secret=&lt;TOKEN&gt;# 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-user=&lt;USER&gt;# 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-passwd=&lt;PASSWD&gt;# 是否启用 RPC 服务的 SSL/TLS 加密,# 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接#rpc-secure=true# 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,# 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥#rpc-certificate=/path/to/certificate.pem# 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件#rpc-private-key=/path/to/certificate.key## BT/PT下载相关 ### 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true#follow-torrent=true# BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999listen-port=51413# 单个种子最大连接数, 默认:55#bt-max-peers=55# 打开DHT功能, PT需要禁用, 默认:trueenable-dht=false# 打开IPv6 DHT功能, PT需要禁用#enable-dht6=false# DHT网络监听端口, 默认:6881-6999#dht-listen-port=6881-6999# 本地节点查找, PT需要禁用, 默认:false#bt-enable-lpd=false# 种子交换, PT需要禁用, 默认:trueenable-peer-exchange=false# 每个种子限速, 对少种的PT很有用, 默认:50K#bt-request-peer-speed-limit=50K# 客户端伪装, PT需要peer-id-prefix=-TR2770-user-agent=Transmission/2.77peer-agent=Transmission/2.77# 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0seed-ratio=0# 强制保存会话, 即使任务已经完成, 默认:false# 较新的版本开启后会在任务完成后依然保留.aria2文件#force-save=false# BT校验相关, 默认:true#bt-hash-check-seed=true# 继续之前的BT任务时, 无需再次校验, 默认:falsebt-seed-unverified=true# 保存磁力链接元数据为种子文件(.torrent文件), 默认:falsebt-save-metadata=true 大概的设置都在这里了。 几个重要的： dir似乎必须要有，log建议改成你的aria2.log的位置，input-file和save-session建议改成aria2.session的位置。 max-concurrent-downloads, max-connection-per-server, min-split-size, split根据需求自行修改。 你是否在上述过程中试图打开 aria2.exe ？正常情况下，应该会出现一个立即消失的命令行窗口，并且该进程立即消失。 开启 aria2.exe再创建一个文件 HideRun.vbs ，写入以下代码： 1CreateObject("WScript.Shell").Run "aria2c.exe --conf-path=aria2.conf",0 运行 HideRun.vbs ，现在应该可以找到进程 aria2.exe 了。 可是没有 GUI 啊，怎么下载啊？ 控制台可以使用 yaaw(zh-hans) 来看到自己的 aria2 状态。为了证明您的 aria2 已经正常运行，可以试着下载一个小文件。 然而界面不好看并且每次使用要打开网页太慢了（恼），所以本人换了一个 WebUI ，改成了 AriaNg 。 怕麻烦，直接在 releases 里下载了一个 all-in-one 包，解压之后打开 index.html 即可。 对我而言这个界面舒服多了。 插件自行安装即可（感觉效果不佳啊……）。 qBittorrent Q：为什么选择 qBittorrent ？A：大佬推荐的。 qbittorrent 下载官网下载所需版本即可。个人使用4.1.9。 然后相信大部分操作应该都一看就会了。 trackersngosangnewtrackon 在 工具&gt;选项&gt;BitTorrent 里添加即可。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[瞎搞Hexo博客]]></title>
    <url>%2Fblog%2F%E7%9E%8E%E6%90%9EHexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[没错我又开始瞎搞我的 blog 了。 源码问题看了 yansheng836 的 README.md （smwy）和某个 issue ，觉得自己也应该把源码一并传到 github 上。 我在 git 仓库里开了个名为 source 的 branch，本地也开了个仓库，现在每次更改之后就将源码推送到 source 。 然后每次搞完 blog 在 commit 的时候就要多写几行。 1234hexo cl &amp;&amp; hexo g &amp;&amp; hexo dgit add *git commit -m "~"git push origin master:source 不妨顺便把 .gitignore 也贴在这里： 12345678.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/.gitignore 渲染问题总有时候不想让 hexo 渲染某些 blog 里的 html 或者 md 文件。 于是可以改根目录下的 _config.yml 。 查了一下，发现只用改 skip_render 即可。 好像路径匹配用的是 glob 表达式，感觉和正则表达式有些相像，但规则简单得多。 这里就不放了，可以去阮一峰的博客学习。 隐藏博文大概知道怎么搞了，然而咕了。 怎么我老是咕啊 多地编辑经笔者尝试多地编辑后，出现了一些小问题。 不用hexo init！啊，git clone -b source &lt;my_repo&gt;之后，可以不用hexo init。 不如说不应该用，否则会多出令人烦躁的一些初始化的产物。 直接 123npm installnpm install hexo-cli -gnpm install hexo-deployer-git --save 就好了。 拯救自定义排序首先，我的自定义排序没了。 这是因为原本自定义排序是通过更改node_modules\hexo-generator-index\lib\generator.js实现的。 123456789101112131415161718192021222324252627282930313233'use strict';var pagination = require('hexo-pagination');module.exports = function(locals) &#123; var config = this.config; var posts = locals.posts.sort(config.index_generator.order_by); posts.data = posts.data.sort(function (a, b) &#123;//这里是排序 if (a.top &amp;&amp; b.top) &#123; if (a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if (a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if (!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; &#125;); var paginationDir = config.pagination_dir || 'page'; var path = config.index_generator.path || ''; return pagination(path, posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 恢复font-awesome咋 font-awesome 也没了。 一看，这东西在public\lib，现已将整个文件夹打包到lib.zip。 拉取更新啊这个大概不用提吧。 12git fetch origin sourcegit merge origin/source]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪内切圆专题学习]]></title>
    <url>%2Fblog%2F%E4%BC%AA%E5%86%85%E5%88%87%E5%9C%86%E4%B8%93%E9%A2%98%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[这是学习纯几何吧里的伪内切圆专题之后写的一些笔记。 然而能看懂的东西不多 前置知识给定 $\triangle{ABC}$ 与其外接圆 $\odot{\Omega}$ ，$\triangle{ABC}$ 的 $A-$伪内切圆 $\odot{\omega_A}$ 分别切 $\odot{\Omega}, AC, AB$ 于点 $T, E, F$ 。$I$ 为 $\triangle{ABC}$ 内心，$N, M$ 分别为 $\overset{\LARGE{\frown}}{AB}, \overset{\LARGE{\frown}}{AC}$ 中点。$AT$ 交 $\odot{\omega_A}$ 于点 $P$ 。 有以下几个经典结论： $I, E, F$ 共线且 $EI = FI$ 。 $N, F, T$ 共线， $M, E, T$ 共线。 $\angle{BTI} = \angle{CTI}$ 。 $TBFI\sim TFPE\sim TIEC$ 。 例题A给定 $\triangle{ABC}$ 与其外接圆 $\odot{O}$ ，三个伪内切圆 $\odot{O_A}, \odot{O_B}, \odot{O_C}$ 分别切 $\odot{O}$ 于点 $T_A, T_B, T_C$ 。证明 $AT_A, BT_B, CT_C$ 共点。 A-sol只需证 $\dfrac{AT_B}{T_BC}\dfrac{CT_A}{T_AB}\dfrac{BT_C}{T_CA} = 1$ 。 不妨只看 $\dfrac{CT_A}{BT_A}$ 。 由 Mannheim 定理易证 $\triangle{BIT_A}\sim \triangle{ICT_A}$ ，即有 $\dfrac{BI^2}{CI^2} = \dfrac{BT_A}{IT_A}\times \dfrac{IT_A}{CT_A} = \dfrac{BT_A}{CT_A}$ 。 所以 $\dfrac{AT_B}{T_BC}\dfrac{CT_A}{T_AB}\dfrac{BT_C}{T_CA} = 1$ ，证毕。 B给定 $\triangle{ABC}$ 外接圆 $\odot{\Omega}$ ，过 $A$ 作 $AA^\prime\parallel BC$ 交外接圆于点 $A^\prime$ ，$L$ 为 $\overset{\LARGE{\frown}}{BAC}$ 的中点。 $\triangle{ABC}$ 内切圆 $\odot{I}$ 与 $BC$ 切于点 $D$ 。射线 $A^\prime D, LI$ 交于点 $T$，证明 $T$ 在 $\odot{\Omega}$ 上。 B-sol作 $\triangle{ABC}$ 的 $A-$伪内切圆 $\odot{\omega_A}$ ，切点分别为 $F, E, T$ 。设点 $N$ 为 $AT$ 与 $BC$ 交点。下证 $TI$ 延长线与 $\odot{\Omega}$ 交于 $L$ 为 $\overset{\LARGE{\frown}}{BAC}$ 的中点， $TD$ 延长线交 $\odot{\Omega}$ 于点 $A^\prime$ 且 $A^\prime A\parallel BC$ 。 证明 $L$ 为 $\overset{\LARGE{\frown}}{BAC}$ 中点由 Mannheim 定理，显然 $TF$ 延长线过 $\overset{\LARGE{\frown}}{AB}$ 的中点，即有 $\angle{BTF} = \dfrac{C}{2}$ 。又 $\angle{FIB} = \angle{BIA} - \dfrac{\pi}{2} = \dfrac{C}{2} = \angle{BTF}$ ，可得 $B, T, I, F$ 共圆。同理得 $C, T, I, E$ 共圆。倒角，显然有 $BFIT\sim IECT$ 。 故 $\angle{BTI} = \angle{CTI} = \dfrac{\pi - A}{2}$ ，得证。 证明 $AA^\prime\parallel BC$ 原命题等价于证明 $TL$ 为 $\angle{DTN}$ 角平分线，即 $\angle{BTD} = \angle{CTN}$。 注意到此时有 $\dfrac{BD}{CD} = \dfrac{BT\sin\angle{BTD}}{CT\sin\angle{CTD}}, \dfrac{BN}{CN} = \dfrac{BT\sin\angle{BTN}}{CT\sin\angle{CTN}}$ ，即 $\dfrac{BD}{CD}\times \dfrac{BN}{CN} = \dfrac{BT^2}{CT^2}$ 。易证上式也为为 $\angle{BTD} = \angle{CTN}$ 的充分条件。 导面积： $\dfrac{BN}{CN} = \dfrac{S_{\triangle{ABT}}}{S_{\triangle{ACT}}} = \dfrac{AB\times BT}{AC\times CT}$ 。 导边： $\dfrac{BD}{CD} = \dfrac{BI\sin\angle{BID}}{CI\sin\angle{CID}} = \dfrac{BI\sin{\frac{\pi + B}{2}}}{CI\sin\frac{\pi + C}{2}}$ 注意到 $\triangle{ABI}, \triangle{ACI}$ 中有 $\dfrac{AB}{AC} = \dfrac{BI\sin\angle{\frac{\pi + C}{2}}}{CI\sin\angle{\frac{\pi + B}{2}}}$ ，所以有 $\dfrac{BD}{CD} = \dfrac{BI^2}{CI^2}\times \dfrac{AC}{AB}$ 。 利用上一题的结论可得 $\dfrac{BD}{CD} = \dfrac{BT}{CT}\times \dfrac{AC}{AB}$ 。 $\therefore \dfrac{BD}{CD} \times \dfrac{BN}{CN} = \dfrac{BT^2}{CT^2}$ ，得证。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[庚子弥生月的瞎扯]]></title>
    <url>%2Fblog%2F%E5%BA%9A%E5%AD%90%E5%BC%A5%E7%94%9F%E6%9C%88%E7%9A%84%E7%9E%8E%E6%89%AF%2F</url>
    <content type="text"><![CDATA[我也不知道我为啥要起一个如此迷惑的标题 今年二月多了一天，但仍然没能让笔者不咕。 于是三月也咕了！ 本文中所有时间均为 UTC+8。 20200229现在是 2 月 29 日 23:59 ，目前无事发生。 20200301现在是 3 月 1 日 00:00 ，目前无事发生。 20200326下午一上课，某群突然开始传国内 github pages 被 mitm 的消息。一看，复现成功，出现巨大多「非私密连接」错误，噔噔咚。联想 25 日 RSSHub 的倒地，不安感，流了出来，，， 20200327现在是 3 月 27 日 00:30 ， github pages 还在被 mitm 。 现在是 3 月 27 日 08:00 ， github 也被 mitm 了。 草（辱骂）。 现在是 3 月 27 日 09:45 ， github 突然好了。 草（辱骂）。真就 *** 在测试？ 现在是 3 月 27 日 10:35 ， github 又被 mitm 了。 草（梅开三度） 现在是 3 月 27 日 11:00 ， 这 mitm 还换证书了。 ****（直球）。 睡了个午觉，全 好 了。 这不是在调试 *** 功能是在干啥呢¿ 草。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>计划与总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF512D」Fox and Travelling]]></title>
    <url>%2Fblog%2FCF512D%2F</url>
    <content type="text"><![CDATA[题意简述[CF 512D] 给定一张 $n$ 个点 $m$ 条边的简单无向图，每次可以选择一个度数为 $1$ 的点删除，求删去 $0, 1, \dots, n$ 个点的方案数模 $10^9 + 9$。两种方案不同当且仅当二者在某一步选择的点不同。$1\le n\le 100$ 。 主要思路在环上的点一定无法被选择，因此去除所有删不掉的点后图是一个森林。对每棵树分别计算选择 $0$ 到 $size$ 个点的答案，卷积起来即可。注意如果一个点在原图中与不可选的点之间有连边，那么它在这个连通块里一定是最后被选择的。注意以这个点为根时，在一个点的子树里的点都被选后，其自身才能被选。考虑树形 dp ，令 $f_{i, j}$ 表示在 $i$ 子树里选出 $j$ 个点的方案，转移为对子树的 $f$ 卷积。 现在考虑一个连通块在原图中即为树的情况。我们无法确定选择所有点时最后被选的点。这种情况对所有点都以其为根做一次 dp ，对于有 $i$ 个点选了的方案，会在不以这 $i$ 个点为根时都计算一次，所以对于没有选完而选了 $i$ 个点的方案，除以 $size - i$ 即可去重。 单次树上背包时间复杂度 $O(n^2)$ ，所以总时间复杂度 $O(n^3)$ 。 参考代码咕]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>图论</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类A001608数列的一些性质]]></title>
    <url>%2Fblog%2F%E7%B1%BBA001608%E6%95%B0%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%A7%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[今日上某数学课的时候有一道这样的题目： 给定数列 $a_n = a_{n - 3} + a_{n - 2}; a_0 = 3, a_1 = 0, a_2 = 2$ ，证明如果 $p$ 为质数，有 $p|a_p$ 。 这个数列是 oeis 上的 A001608。 这个问题已经有了很多种证明方法，例如B. H. Neumann and L. G. Wilson, Some Sequences like Fibonacci’s, Fibonacci Quart., 17(1), 1979, p. 83.和E. B. Escott, Problem 151, Amer. Math. Monthly, 15 (1908), 209.。这两份 pdf 的本博客链接：neumann.pdf, 151.pdf。 本处介绍一种思路较为简单的证明方法。 考虑 $a_n$ 的意义，将 $a_n$ （$n\ge 3$）作如下定义：一个长 $n$ 的环按顺序标号 $1$ 到 $n$，环上标号为 $u$ 的点有权值 $w_u$，权值为 $0$ 或 $1$ ，且每个权值为 $1$ 的点到其他权值为 $1$ 的点的最短距离为 $2$ 或 $3$ 。求方案数。 显然对于 $a_3 = 3$ 定义成立。现在我们证明对 $n &gt; 3$ 该定义成立。 我们假设标号最小的为 $1$ 的点的标号为 $x$ ，则必然有 $w_{x + 2} = 1$ 或 $w_{x + 3} = 1$ 。 若 $w_{x + 2} = 1$ ，该方案等价于删去编号为 $x + 1, x + 2$ 的点（显然删去后仍然合法），有方案数 $a_{n - 2}$ 。 若 $w_{x + 3} = 1$ ，该方案等价于删去编号为 $x + 1, x + 2, x + 3$ 的点，有方案数 $a_{n - 3}$ 。 综上，有 $a_n = a_{n - 2} + a_{n - 3}$ 。 对于一个质数 $p\ge 3$ ，因为 $p$ 不含有 $1, p$ 以外的因子，所以对于任意一种合法的方案，显然将这种方案任意旋转仍然合法。所以有 $p|a_p$ 。 显然上述证明可以推广到J. Shallit, J. P. Yamron, On linear recurrences and divisibility by primes, Fib. Quart. 22 (4) (1984) 366.（shallit2.pdf）所提到的一类数列: 给定数列 $a_n = a_{n - k + 1} + a_{n - k}; a_0 = k, a_1 = a_2 = \cdots = a_{k - 2} = 0, a_{k - 1} = k - 1$ ，对于质数 $p\ge k$ ，$p|a_p$ 。 然而这种做法无法证明类似如下的题目： 给定数列 $a_n = a_{n - 1} + a_{n - 2} + (-1)^n; a_0 = 3, a_1 = 0, a_2 = 4$ ，证明如果 $p$ 为质数，有 $p|a_p$ 。 而 neumann.pdf 中有对于任意此类型数列的证明，而本人并未看懂，故弃坑。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC028E」High Elements]]></title>
    <url>%2Fblog%2FAGC028E%2F</url>
    <content type="text"><![CDATA[前面部分参考了yyb的题解。 题意简述[AGC 028E] 给你一个 $1$ 到 $n$ 的排列 $P$ 。你需要求出一个长为 $n$ 的 01 字符串 $S$ 。构造两个序列 $X, Y$ ，按标号升序考虑每个 $P_i$ ，如果 $S_i = 0$ ，则加入 $X$ 末尾，否则加入 $Y$ 末尾。若 $X$ 与 $Y$ 的 前缀最大值个数相等，则称 $S$ 是好的。求字典序最小的好的 $S$ 。$1\le n\le 2\times 10^5$ 。 主要思路显然，可以逐位确定，只需判断给定一个 $S$ 的前缀后，合法解的存在性。 先来证明一个结论：只要合法解存在，则总有一个好的 $S$ 使得 $X, Y$ 中，至多只有一个中有前缀最大值不为 $P$ 的前缀最大值。 如果 $X$ 中存在「原本不是 $P$ 中前缀最大值，但是现在数列的前缀最大值」的数，那么对于这个数， $P$ 中在它前面的最大值被分配到了 $Y$ 中。假如对于 $Y$ 也有这样的位置，将这两个位置所在的序列调换，则交换之后两个序列的前缀最大值的个数都会减少 $1$ 。所以，经过若干次交换之后，必定能够使之多只有一个序列中有前缀最大值不为 $P$ 中前缀最大值。 不妨设 $X$ 中所有前缀最大值均为 $P$ 的前缀最大值。假设前 $i-1$ 位已经构造完毕，现在考虑第 $i$ 个元素可以放在哪个序列。设目前 $X, Y$ 中的最大值分别为 $M_X, M_Y$ ，前缀最大值个数分别为 $C_X, C_Y$ 。 设 $P$ 中标号 $[i, n]$ 的前缀最大值个数为 $Q$ ，而 $Y$ 在接下来的数列中会有 $k$ 个前缀最大值为 $P$ 的前缀最大值，则 $X$ 中会有 $Q - k$ 个。再设 $Y$ 中非 $P$ 的前缀最大值的前缀最大值的个数为 $m$ 。由于 $X, Y$ 中前缀最大值的个数相等，有以下条件：$$C_X + (Q - k) = C_Y + k + m$$化简后得到：$$2k + m = C_X + Q - C_Y$$其中右边是已知的常量。 由于在 $k &gt; 0$ 或 $m &gt; 1$ 时， $2k + m$ 可以减少 $2$ ，因此若有一个方案能够满足 $2k + m \ge C_X + Q - C_Y$ 且 $2k + m \equiv C_X + Q - C_Y \pmod{\! 2}$ ，就必然存在满足 $2k + m = C_X + Q - C_Y$ 的方案。 实现时，先对 $P$ 倒序做带权的最长下降子序列，其中 $P$ 中的前缀最大值权为 $2$ ，其余元素权为 $1$ ，分别维护为奇数和偶数的最大长度。这一步可以线段树实现。正在确定 $S$ 的第 $i$ 位时，只需要查询从标号 $j$ （$j\ge i, P_j &gt; M_Y$）的元素开始，长度与当前的 $(C_X + Q - C_Y)\bmod 2$ 同余的最长上升子序列的最大长度即可。 复杂度 $O(n\log n)$ 。 参考代码咕咕咕]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>AtCoder</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC029F」Construction of a tree]]></title>
    <url>%2Fblog%2FAGC029F%2F</url>
    <content type="text"><![CDATA[题意简述[AGC 029F] 一张无向图有 $n$ 个点，还没有边。给出 $n - 1$ 个大小至少为 $2$ 的点集 $E_i$ ，问是否能从每个点集中选出两个点连边，使得图连边后为一棵树。若能，输出一种方案；若否，输出 -1 。$2\le n\le 10^5, \sum|E_i|\le 2\times 10^5$ 。 主要思路任意钦定一个点为这棵树的根，之后每条边都可看作某个点连向其父亲的边。建立一个二分图去匹配每个点和其连向父亲的边。二分图的左边为除了根以外的点，右边为 $n - 1$ 个点集。若 $u$ 不是根节点且 $u\in E_i$ ，连边 $(u, E_i)$ 。 可以看出，有解的必要条件就是这个二分图存在一组完美匹配。而另一个必要条件即二分图（左边加入根节点并用上面的方式连边后）应当联通。 任取一组该二分图的完美匹配，之后考虑从根出发 bfs。一开始，我们将根所在的所有点集的匹配点的父亲均设为根，然后再从这些点递归进行下去。如果最后有的点没被访问，说明二分图不连通，与假设矛盾。于是我们构造出了一组合法解，也说明上面的必要条件便是充要条件。 用 Dinic 等算法求二分图完美匹配，时间复杂度 $O(\sum |E_i|\sqrt{n})$ 。 参考代码咕咕咕]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>AtCoder</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF559E」Gerald and Path]]></title>
    <url>%2Fblog%2FCF559E%2F</url>
    <content type="text"><![CDATA[细节好多，写死人了。 题意简述[CF 559E] 有 $n$ 个二元组 $(a_i, l_i)$ ，对于每个二元组有两个选择：将数轴上的 $[a_i - l_i, a_i]$ 染色或将 $[a_i, a_i + l_i]$ 染色。求最大化的最终被染色总长度。输入均为整数， $1\le n\le 100, 0\le a_i\le 10^8, 1\le l_i\le 10^8$ ，保证 $a_i$ 互不相同。 主要思路先把二元组按 $a_i$ 排序，考虑动态规划，设 $f(x, s), x\in[1, 2n], s\in[0, 1]$ 表示「第 $x$ 个二元组向左（$s=1$）或右（$s=0$）贡献，最终染色总长度与 $(-\infty, a_i - s\times l_i]$ 的交的最大值」。 先考虑第 x 个二元组向左贡献。则 $[a_x - l_x, a_x]$ 这段区间内的所有二元组，也都会向左贡献，这会产生连锁反应。连锁反应过后，我们可以得到最右边的不被连锁反应影响的二元组 $y$ 。此时便转化为一个子问题，然而多了一个右端点的限制，但是总体区别不大。然后考虑这个二元组往右贡献。发现其实更简单，因为不会产生连锁反应，所以不被影响的最右的二元组即为 $x - 1$ 。所以无论左右的转移代价都是常数。 有 $O(n)$ 中状态，而每种状态的转移方式不会超过 $O(n)$ 种，转移代价为常数，总复杂度 $O(n^2)$ 。 参考代码感觉可能是我有史以来写过注释比例最高的代码…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; inline int VSC_Local()&#123; #ifdef VSC_Compile while(getchar() != '\n'); #endif return 0; &#125; #define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout) #define PBTXDY&#125;using namespace my_std;const int N = 210, inf = 1145141919;struct bulb&#123; int pos, len; inline bool operator &lt;(const bulb &amp;t)const&#123; return pos &lt; t.pos; &#125;&#125;p[N];int n, f[N], pre[N], rpre[N], md[N][N];//pre[i] : 点 i 向左这段区域内最左边的点的编号; rpre[i] : 点 i 一直向左扩展最后最左的编号（相当于 pre[i] 的迭代）//md[i][j] : [i, j] 这段区间中向左的端点最左的点int dp(int tr)&#123; if(f[tr] != -1) return f[tr]; Rint id, R; //id : 当前最右可贡献点; R : 当前最右允许贡献位置 if(tr &gt; n * 2) id = n, R = inf; else if(tr &gt; n) id = pre[tr - n] - 1, R = p[tr - n].pos - p[tr - n].len; //「当前位置」向左，显然在定义下「当前位置」无法造成贡献，故实际当前位置为 pre[tr - n] - 1 else id = tr - 1, R = p[tr].pos; //「当前位置」向右，同理「当前位置」无法造成贡献，故实际当前位置为 tr - 1 if(!id) return f[tr] = 0; f[tr] = p[id].pos - (p[rpre[id]].pos - p[rpre[id]].len) + dp(rpre[id] + n); //考虑当前最左可贡献点 (rpre[id]) 向左 chkmax(f[tr], min(p[id].len, R - p[id].pos) + dp(id)); //考虑当前最右可贡献点 (id) 向右 ROF(i, id - 1, 1)&#123; if(p[i].pos + p[i].len &lt;= p[id].pos) continue; Rint u = md[i + 1][id]; //令 i 右边的点向左贡献，能贡献到最左的 u if(p[u].pos - p[u].len &gt; p[i].pos)&#123; chkmax(f[tr], min(p[i].len, R - p[i].pos) + dp(i)); //假如点 i 右边没有点可以贡献到它的左边，直接把这个点贡献到右边 &#125; else&#123; Rint v; if(pre[u] &lt; i)&#123; v = rpre[md[pre[u]][i - 1]]; if(p[v].pos - p[v].len &gt; p[u].pos - p[u].len) v = u; //找出的点 v 比原来的点 u 还劣 &#125; else v = u; //找出在 i 向右时的最左可贡献点 v 并将其向左贡献 chkmax(f[tr], min(R, p[i].pos + p[i].len) - (p[v].pos - p[v].len) + dp(v + n)); //i 向右贡献， v 向左贡献 &#125; &#125; return f[tr];&#125;int main()&#123; n = read(); FOR(i, 1, n) p[i].pos = read(), p[i].len = read(); sort(p + 1, p + n + 1); p[0].pos = -inf, p[n + 1].pos = inf; FOR(i, 1, n)&#123; const int L = p[i].pos - p[i].len; pre[i] = i; while(p[pre[i] - 1].pos &gt;= L) --pre[i]; //求 pre[i] &#125; FOR(i, 1, n)&#123; Rint L = p[i].pos - p[i].len, x = i; FOR(j, i, n)&#123; if(chkmin(L, p[j].pos - p[j].len)) x = j; md[i][j] = x; &#125;//暴力求 md[i][j] &#125; FOR(i, 1, n)&#123; Rint x = md[pre[i]][i]; rpre[i] = (i == x) ? i : rpre[x]; //求 rpre[i] &#125; MEM(f, -1); printf("%d\n", dp(n * 2 + 1)); return VSC_Local();&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC039D」Incenters]]></title>
    <url>%2Fblog%2FAGC039D%2F</url>
    <content type="text"><![CDATA[粉兔的题解令我学到许多…… 题意简述[AGC 039D] 给定单位圆上的 $n$ 个点 $(\cos(\dfrac{2\pi T_i}{L}), \sin(\dfrac{2\pi T_i}{L}))$ 。求等概率随机三个不同的点的内心的期望位置。$3\le n\le 3000, n\le L\le 10^9, 0\le T_i &lt; T_{i + 1}\le L - 1$ 。 主要思路 如图，$\triangle{ABC}$ 的外心为 $O$ ，内心为 $I$ 。 分别延长 $AI, BI, CI$ 与 $\odot O$ 交于点 $A^\prime, B^\prime, C^\prime$ 。则易得 $A^\prime, B^\prime, C^\prime$ 分别为弧 $\overset{\LARGE{\frown}}{BC}, \overset{\LARGE{\frown}}{CA}, \overset{\LARGE{\frown}}{AB}$ （不经过 $A, B, C$ 的那一段）的中点。 根据鸡爪定理，有 $A^\prime I = A^\prime C, B^\prime I = B^\prime C$ ，所以 $IC\!\perp\!A^\prime B^\prime$ ，即 $IC^\prime\!\perp\!A^\prime B^\prime$ 。所以 $I$ 同时为 $\triangle{A^\prime B^\prime C^\prime}$ 的垂心 $H^\prime$ 。 根据欧拉线定理，有 $\overrightarrow{OH^\prime} = 3\overrightarrow{OG^\prime} = \overrightarrow{OA^\prime} + \overrightarrow{OB^\prime} + \overrightarrow{OC^\prime}$ 。 所以求 $E(I) = E(H^\prime)$ 只用求 $E(A^\prime) + E(B^\prime) + E(C^\prime)$ 即可。 这个枚举点对计算即可，复杂度 $O(n^2)$ 。 参考代码真的很短…… 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;#define reg register#define Rint register int#define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i)#define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i)typedef double DB;inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans;&#125;const DB pi = acos(-1);const int N = 3010;int n, L, t[N];DB ansx, ansy;int main()&#123; n = read(), L = read(); FOR(i, 1, n) t[i] = read(); reg DB x, y, res = n * (n - 1.0) * (n - 2.0) / 6.0; FOR(A, 1, n - 1) FOR(B, A + 1, n)&#123; x = cos(pi * (t[A] + t[B]) / L); y = sin(pi * (t[A] + t[B]) / L); ansx += x * (n - 2 * (B - A)); ansy += y * (n - 2 * (B - A)); &#125; printf("%.12lf %.12lf\n", ansx / res, ansy / res); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>数学</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF639F」Bear and Chemistry]]></title>
    <url>%2Fblog%2FCF639F%2F</url>
    <content type="text"><![CDATA[题意简述[CF 639F] 给定一张无向图 $G = (V, E)$ 其中点数 $n$ ，边数 $m$ 。$q$ 次询问，第 $i$ 次询问，会把无向图加上一些新的边，并询问一个大小为 $n_i$ 的点集在加入了给定 $m_i$ 条边的情况下，是否对于这个点集中的每一对点对 $(x, y)$ 都存在一条从 $x$ 到 $y$ 再回到 $x$ 的不经过重复边的路径。询问独立且强制在线。 $1\le n, q\le 3\times 10^5, 0\le m\le 3\times 10^5, \sum{n_i}, \sum{m_i} \le 3\times 10^5$ 。 主要思路显然，问题可以转化为询问加入一些边的情况下，某个点集是否在同一边双内。 可以先将原先给的图缩成边双，然后建成边双树。对于每次询问，将加边所在的点和询问的点集作为关键点。对关键点建虚树，再对虚树的边和新加的边求边双，判断询问点集是否在同一边双即可。 时间复杂度 $O(n\log n)$ （所有数与 $n$ 同阶）。 参考代码咕咕咕]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>图论</tag>
        <tag>Trojan</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC022F」Checkers]]></title>
    <url>%2Fblog%2FAGC022F%2F</url>
    <content type="text"><![CDATA[这题太神了，对着题解看了好久还没完全搞懂…… 题意简述[AGC 022F] 数轴上有 $n$ 个点，第 $i$ 个点的坐标是 $10^{100i}$ 。每次操作选择两个棋子 $a, b$ ，之后 $a$ 跳到关于 $b$ 的对称点上，然后删掉 $b$ 。求 $n - 1$ 次操作后，最后剩下的棋子可能的坐标个数模 $10^9 + 7$ 。$1 \le n \le 50$ 。 主要思路显然，两种方案不同仅当某个棋子对最后答案贡献的系数不同。 定义一次操作 $a \rightarrow b$ （称「$a$ 合并到 $b$」）表示选择第 $b$ 个棋子与第 $a$ 个棋子进行操作（删除 $a$ 上的棋子）。我们对于每一次操作 $a\rightarrow b$ ，将 $b$ 向 $a$ 连一条边，则会形成一棵以最后剩下的点为根的树。将深度从 $0$ 开始计，则深度为 $d$ 的点贡献的系数为 $+2^d$ 或 $-2^d$ 。 设点 $x$ 最后给答案贡献的正负性（称「点权」）为 $p_x\in \{-1, 1\}$ 。设点 $x$ 的「奇偶性」为 $q_x\in \{-1, 1\}$，有奇数个儿子的点为奇点（$q_x = -1$），有偶数个儿子的点为偶点（$q_x = 1$）。 由题面定义，若某一棋子 $y$ 合并到棋子 $x$ ，则棋子 $x$ 贡献的正负性将改变。 从上向下考虑可以得到，对于点 $rt$ 的总共 $k$ 个儿子，其中有 $\lfloor\frac{k}{2}\rfloor$ 个儿子 $ch$ 有 $p_{rt} = p_{ch}\times q_{ch}$ ，$\lceil\frac{k}{2}\rceil$ 个儿子 $ch$ 有 $-p_{rt} = p_{ch}\times q_{ch}$ 。（$q_{ch}$ 可以理解为操作完 $ch$ 子树后 $ch$ 目前的贡献正负性） 我们并不关心整棵树的形态，而只关心每一层中两种点权分别的个数。按深度从小到大挂点，设 $f_{i, j}$ 表示已经挂了 $i$ 个点，上一层有 $j$ 个奇点的答案。 钦定上一层的所有奇点的点权均为 $1$ （若原本应为 $-1$，则相当于对整棵子树的点权取反，这样的方案数与原来是相等的）。枚举这一层的点数 $x$ 与点权为 $-1$ （在钦定该层奇点点权均为 $1$ 的情况下）的点的个数 $y$ 。根据上面的结论，可以得到这一层有 $\frac{x + j}{2}$ 个点 $v$ 使得 $p_v\times q_v = -1$ 。因此，这一层的奇点数应该是 $|y - \frac{x + j}{2}|$ ，乘上组合数转移即可。 注意 $x \ge j$ （使得 $p_v\times q_v = -1$ 成立的点 $v$ 的个数比不成立的点个数多 $j$ 个）且 $x + j$ 为偶数。 时间复杂度 $O(n ^ 4)$ 。 参考代码更多细节见代码。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;#define reg register#define Rint register int#define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i)#define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i)inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans;&#125;const int mod = 1000000007;inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125;inline int _abs(const int &amp;x)&#123; return x &gt;&gt; 31 ? -x : x; &#125;#define abs(x) _abs(x)const int N = 55;int n;int f[N][N], C[N][N];int main()&#123; n = read(); FOR(i, 0, n)&#123; C[i][0] = C[i][i] = 1; FOR(j, 1, i - 1) inc(C[i][j], C[i - 1][j - 1] + C[i - 1][j]); &#125; f[1][0] = f[1][1] = n; FOR(i, 1, n - 1) FOR(j, 0, i)&#123; FOR(x, 1, n - i)&#123; if(x &lt; j || (x ^ j) &amp; 1) continue; FOR(y, 0, x)&#123; Rint tr = abs(y - ((x + j) &gt;&gt; 1)); inc(f[i + x][tr], 1ll * f[i][j] * C[n - i][x] % mod * C[x][y] % mod); &#125; &#125; &#125; printf("%d\n", f[n][0]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>AtCoder</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2019模拟赛」Yuno loves sqrt technology I]]></title>
    <url>%2Fblog%2FYnoi2019%E6%A8%A1%E6%8B%9F%E8%B5%9B-Yuno-loves-sqrt-technology-I%2F</url>
    <content type="text"><![CDATA[这题好像也是咕咕了很久？ [Luogu 5046] 题意简述强制在线的区间逆序对， $n$ 长度 $m$ 查询， $1\le n, m\le 10^5$ 。 题面还保证是排列，更好写（ 主要思路分块，块长为 $O(n)$ ，记录以下几个数组： $\langle pre_x\rangle$ ：第 $x$ 个元素到所在块的开头一段的逆序对数。 $\langle suf_x\rangle$ ：第 $x$ 个元素到所在块的结尾一段的逆序对数。 $\langle f_{t, x}\rangle$ ：前 $x$ 个元素，每个元素与第 $t$ 块形成的逆序对数总和。注意这里元素若在块中，则钦定可以形成的逆序对数为 $0$ 。 接下来看询问如何解决： 对于跨块的询问，可以拆分成三个区间（两边的散块和中间的一堆整块）。 对于两边零散块内部的贡献，处理了 $\langle pre_x \rangle, \langle suf_x \rangle$ ，可以 $O(1)$ 。 对于整块内部的贡献，对于每个块求一下与后面的整块形成的逆序对数，这可以通过查 $\langle f_{t, x}\rangle$ 得到；该块内部的贡献和零散块的贡献方法相同。所以单次复杂度 $O(\sqrt{n})$ 。 对于零散与中间的整块形成的逆序对，和整块内部贡献类似，查 $\langle f_{t, x}\rangle$ 的表即可 $O(\sqrt{n})$。 对于两个零散部分之间形成的逆序对，先对每个块内部排好序，查询时 $O(\sqrt{n})$ 将需要的区间拎出来，然后用双指针可以 $O(\sqrt{n})$ 求出逆序对数。 对于在块内的询问，可以转化为该块的两个前缀的差。当然不能直接 $pre_r - pre_{l - 1}$ ，还要用双指针把这两个段之间产生的贡献减掉。 所以单次查询复杂度就是 $O(\sqrt{n})$ ，可以通过此题。 参考代码写了个 fread 结果负优化，所以删了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; inline LL readLL()&#123; reg LL ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; inline int VSC_Local()&#123; #ifdef VSC_Compile while(getchar() != '\n'); #endif return 0; &#125; #define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout) #define PBTXDY&#125;using namespace my_std;const int N = 100010, BN = 320, blo = 317;struct BIT&#123; int b[N]; inline void upd(Rint x, Rint v)&#123; for(; x &lt; N; x += x &amp; (-x)) b[x] += v; &#125; inline int qry(Rint x)&#123; Rint res = 0; for(; x; x -= x &amp; (-x)) res += b[x]; return res; &#125;&#125;BT;int n, m, bcnt, a[N], sv[N], sd[N];//array, sorted_val, sorted_idint bl[N], Blo_L[BN], Blo_R[BN];int suf[N], pre[N], f[BN][N];int sl[BN], sr[BN], tl, tr;inline int merge()&#123; Rint res = 0, el = 1, er = 1; while(el &lt;= tl &amp;&amp; er &lt;= tr)&#123; sl[el] &lt; sr[er] ? (res += er - 1, ++ el) : (++ er); &#125; while(el &lt;= tl) res += tr, ++ el; tl = tr = 0; return res;&#125;struct myP&#123; int val, id; inline myP(int vall = 0, int idd = 0)&#123; val = vall, id = idd; &#125; inline int operator &lt; (const myP &amp;d)const&#123; return val &lt; d.val; &#125;&#125; ary[N];inline LL query(const int &amp;l, const int &amp;r)&#123; if(l &gt; r || r &gt; n || l &lt;= 0) return 0; const int lb = bl[l], rb = bl[r]; if(lb == rb)&#123; const int L = Blo_L[lb], R = Blo_R[lb]; if(l == L) return pre[r]; if(r == R) return suf[l]; FOR(i, L, R)&#123; if(l &lt;= sd[i] &amp;&amp; sd[i] &lt;= r) sr[++ tr] = sv[i]; else if(sd[i] &lt; l) sl[++ tl] = sv[i]; &#125; return pre[r] - pre[l - 1] - merge(); &#125; reg LL res = pre[r] + suf[l]; FOR(i, lb + 1, rb - 1)&#123; res += (f[i][r] - f[i][Blo_R[i]]) + pre[Blo_R[i]]; res += (f[i][Blo_R[lb]] - f[i][l - 1]); &#125; FOR(i, Blo_L[lb], Blo_R[lb])&#123; if(sd[i] &gt;= l) sl[++ tl] = sv[i]; &#125; FOR(i, Blo_L[rb], Blo_R[rb])&#123; if(sd[i] &lt;= r) sr[++ tr] = sv[i]; &#125; return res + merge();&#125;int main()&#123; n = read(), m = read(); FOR(i, 1, n) a[i] = read(), ary[i] = myP(a[i], i); bcnt = (n - 1) / blo + 1; FOR(i, 1, bcnt)&#123; Rint L = Blo_L[i] = Blo_R[i - 1] + 1, R = Blo_R[i] = i == bcnt ? n : i * blo, res = 0; sort(ary + L, ary + R + 1); FOR(j, L, R)&#123; bl[j] = i, sv[j] = ary[j].val, sd[j] = ary[j].id; BT.upd(a[j], 1); res += j - L + 1 - BT.qry(a[j]); pre[j] = res; &#125; FOR(j, L, R)&#123; suf[j] = res; BT.upd(a[j], -1); res -= BT.qry(a[j] - 1); &#125; &#125; sort(ary + 1, ary + n + 1); FOR(i, 1, bcnt)&#123; const int L = Blo_L[i], R = Blo_R[i]; Rint it = L, x, v; FOR(j, 1, n)&#123; x = ary[j].id, v = ary[j].val; while(it &lt;= R &amp;&amp; v &gt; sv[it]) ++it; if(x &lt; L) f[i][x] = it - L; else if(x &gt; R) f[i][x] = R - it + 1; &#125; FOR(j, 2, n) f[i][j] += f[i][j - 1]; &#125; // reg LL ans = 0, ll, rr; while(m --)&#123; ll = readLL(), rr = readLL(); printf("%lld\n", ans = query(int(ll ^ ans), int(rr ^ ans))); &#125; return VSC_Local();&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>Ynoi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C盘快爆了之后的瞎折腾]]></title>
    <url>%2Fblog%2FC%E7%9B%98%E5%BF%AB%E7%88%86%E4%BA%86%E4%B9%8B%E5%90%8E%E7%9A%84%E7%9E%8E%E6%8A%98%E8%85%BE%2F</url>
    <content type="text"><![CDATA[下载了某培训机构的 PC 客户端到 C 盘（本人喜欢将学习有关的软件直接扔 C 盘，其他扔 F 盘）之后发现 C 盘所剩不多，已经显示了红色条条，于是就有了这篇文章。 虽然后面做的事情和 C 盘没多大关系就是了。 删除各类流氓好像删了 360 浏览器、布丁压缩、万能看图王之类的垃圾，具体还有啥不记得了（ 我寻思平时给我弹广告的大概就是布丁和看图王这俩屑。 Bandzip被机房的某位硬核的神仙很久之前推荐的。非常好用（所以我是怎么在下了 Bandzip 之后还不把布丁删掉的）。 Honeyview这东西和上面的 Bandzip 一样，都是 Bandisoft 的作品，当然非常好用。 打开之后大概是这样一个页面：（话说为什么翻译是「蜂蜜浏览器」啊……） 然后自己改改配置什么的就行了，使用非常愉悦舒适，并且加载速度很快。 PotPlayer据说新版开始弹广告了？？总之我是没遇到过 官网直接下载即可。 配置 PotPlayer这里推荐Zune 皮肤（potplayer皮肤下载文件夹内）。 下载皮肤后得到一个 .dsf 文件，将其放入 PotPlayer 目录下的 Skins 文件夹内，然后打开 PotPlayer 。 右键，打开选项（当然也可以直接 F5）。基本\皮肤/配色 中，先「重新搜索」，然后将皮肤改为 Zune.dsf 。 然后勾选「视频下自动隐藏」，并进入 基本\皮肤覆盖/放大 ，将在画面上输出皮肤的方式改为「使用 Direct3D 9」。 这样，就得到了一个进度条自动隐藏的视频（音频？）播放器。 当然也可以改改字体，把丑陋的宋体改掉，完美！ 播放 .mkv现在打开 .mkv 文件的时候，可以播放视频却没音频。 需要安装 K-Lite Codec Pack，本人直接装了 Full 版。而且为什么还给我赠送了一个 MPC-HC ……我现在不想搞配置啊…… 然后就可以使用 PotPlayer 播放 .mkv 文件了。 各种东西还在试验中…… foobar2000下载了 dream_awake 大大的 foobox，美观高效。 大概是这样一个界面： 用于听音频绝赞，可惜歌词自动匹配上稍微跟不上。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2018」五彩斑斓的世界]]></title>
    <url>%2Fblog%2FYnoi2018-%E4%BA%94%E5%BD%A9%E6%96%91%E6%96%93%E7%9A%84%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[写了有一段时间了，忘更博客（咕咕咕）。 Idea：lxl Solution：lxl Std：lxl Data：lxlIdea：lxl Solution：lxl Std：lxl Data：lxl “突刺贯穿的第二分块” （妈呀这名字好中二啊（谁叫我要用日本轻小说中的东西命名真是作死）） 这题的来源比较神奇，大概是 csy 搬了一个全局大于 x 的减 x，查 kth 什么的题，然后我想把这个出区间上 然后直接出会得到一个 $O(n\sqrt{n}\log n)$ 的废物，当时想了很久都没想到什么trick能做值域1e9的情况（有没有人教教我啊） 然后改了改发现值域1e5是可以做的就出了出来 对这题的评价：6/11 顺便这题的 Version4 是查询区间 rank ，我记得当时我用当时感觉挺厉害的 trick 做到了和现在一样的复杂度不过感觉不 practical 所以没有挂出来 [Luogu 4117] [BZOJ 5143] [CF 896E] 所以 lxl 啥时候把加强的数据咕出来啊（ 好现在咕出来了，然后我过不去了，找时间来改（咕咕咕 题意简述一个长为 $n$ 的序列，$m$ 个操作。操作可能是以下两种： 将区间 $[l, r]$ 内所有大于 $x$ 的数减去 $x$ 。 求区间 $[l, r]$ 内 $x$ 的个数。 $1\le n, m, a_i\le 10^5$ 。 主要思路考虑分块，块长 $O(\sqrt{n})$。显然，每块的最大值总是不增的。 我们用某种数据结构来维护块内的所有数，设将某个数合并到另一个数上的时间复杂度是 $O(k)$，查询某种数的个数的时间复杂度是 $O(t)$。 假设一个块所有大于 $x$ 的数减去 $x$ ，最大值为 $v$ 。 当 $v \le 2\times x$ 时，可以把所有 $[x + 1, v]$ 内的数合并到 $[1, x]$ 上。这样，我们用 $O(v - x)\times O(k)$ 的时间让块内的最大值减小了 $v - x$ 。 当 $v &gt; 2\times x$ 时，可以把所有 $[1, x]$ 内的数合并到 $[x + 1, 2\times x]$ 上。这样，我们用 $O(x)\times O(k)$ 的时间让块内的最大值减少了 $x$ 。 散块的修改则重构整块，复杂度 $O(k\times\sqrt{n})$。 由于开始时所有块的最大值之和是 $O(n\sqrt{n})$ ，所以修改的复杂度是 $O(n\sqrt{n}\times k)$ 。查询的复杂度是 $O(n\sqrt{n}\times t)$ 。 类似未来日记，使用并查集来维护块内的所有数，则 $k = t = 1$ ，总复杂度 $O(n\sqrt{n})$ ，可以通过此题。 参考代码由于洛谷数据咕咕咕，没有卡常…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353; #ifdef using_mod inline void inc(int &amp;x, const int &amp;y)&#123; x += y; if(x &gt;= mod) x -= mod; &#125; inline void dec(int &amp;x, const int &amp;y)&#123; x -= y; if(x &lt; 0) x += mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; inline int VSC_Local()&#123; #ifdef VSC_Compile while(getchar() != '\n'); #endif return 0; &#125; #define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout) #define PBTXDY&#125;using namespace my_std;const int N = 100010, Vmax = 100000, SN = 330;int blo, Bcnt;int n, m, a[N], bl[N], fth[N], siz[N];int ary[N];int find(int x)&#123; return x == fth[x] ? x : fth[x] = find(fth[x]); &#125;struct Block&#123; int bg, ed, tag, mx;//数 y 实际值为 y - tag int pos[N]; inline void build()&#123; FOR(i, bg, ed) fth[i] = siz[i] = 0; tag = 0, mx = 0; FOR(i, bg, ed)&#123; if(!pos[a[i]]) pos[a[i]] = fth[i] = i, siz[i] = 1; else ++siz[ fth[i] = pos[a[i]] ]; chkmax(mx, a[i]); &#125; &#125; inline int query(int x)&#123; return x + tag &lt;= Vmax &amp;&amp; pos[x + tag] ? siz[pos[x + tag]] : 0; &#125; inline void update(int x)&#123; if(x &gt;= mx) return; if(2 * x &gt;= mx)&#123; FOR(val, x + 1 + tag, mx + tag) if(pos[val])&#123; Rint f = val - x; if(pos[f]) fth[pos[val]] = pos[f], siz[pos[f]] += siz[pos[val]]; else pos[f] = pos[val], a[pos[val]] -= x; pos[val] = 0; &#125; mx = x; &#125; else&#123; ROF(val, x + tag, 1 + tag) if(pos[val])&#123; Rint f = val + x; if(pos[f]) fth[pos[val]] = pos[f], siz[pos[f]] += siz[pos[val]]; else pos[f] = pos[val], a[pos[val]] += x; pos[val] = 0; &#125; tag += x, mx -= x; &#125; &#125;&#125;B[SN];inline void SBupd(int p, int l, int r, int x)&#123; Rint tag = B[p].tag, L = B[p].bg, R = B[p].ed; FOR(i, L, R) B[p].pos[a[find(i)]] = 0; FOR(i, L, R) ary[i] = a[find(i)] - tag; FOR(i, L, R) a[i] = l &lt;= i &amp;&amp; i &lt;= r &amp;&amp; ary[i] &gt; x ? ary[i] - x : ary[i]; return B[p].build();&#125;inline int SBqry(int p, int l, int r, int x)&#123; Rint res = 0, rx = x + B[p].tag; FOR(i, l, r) res += (a[find(i)] == rx); return res;&#125;inline void update(int l, int r, int x)&#123; Rint lb = bl[l], rb = bl[r]; if(lb == rb) return SBupd(lb, l, r, x); SBupd(lb, l, B[lb].ed, x), SBupd(rb, B[rb].bg, r, x); FOR(bid, lb + 1, rb - 1) B[bid].update(x); return;&#125;inline int query(int l, int r, int x)&#123; Rint lb = bl[l], rb = bl[r]; if(lb == rb) return SBqry(lb, l, r, x); Rint res = SBqry(lb, l, B[lb].ed, x) + SBqry(rb, B[rb].bg, r, x); FOR(bid, lb + 1, rb - 1) res += B[bid].query(x); return res;&#125;inline void init()&#123; Rint cb = 1; FOR(i, 1, n)&#123; a[i] = read(); bl[i] = i % blo ? cb : cb ++; &#125; Bcnt = bl[n]; FOR(bid, 1, Bcnt)&#123; B[bid].bg = (bid - 1) * blo + 1; B[bid].ed = bid == Bcnt ? n : bid * blo; B[bid].build(); &#125;&#125;int main()&#123; n = read(), m = read(), blo = ceil(sqrt(n)); init(); Rint sta, l, r, x; FOR(o, 1, m)&#123; sta = read() - 1, l = read(), r = read(), x = read(); sta ? (void)printf("%d\n", query(l, r, x)) : update(l, r, x); &#125; return VSC_Local();&#125; 参考资料据说询问区间某个数的 rank 也可做？然而我太弱了并不会 lxl 原博客]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>Ynoi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[早春杂记]]></title>
    <url>%2Fblog%2Fundefined%2F</url>
    <content type="text"><![CDATA[2019，真是各种意义上的多事之年。 零早在己亥年初，就有小道消息说自招降分最多只降 20 分。当时当然是一笑了之。 突然 jyb 允许举办的全国性竞赛名单中，少了 OI 。 没能有幸去现场听 dzd 的演讲。据传大概是 dzd 非常坦诚地表示 CCF 无法实现竞赛零收费的目标。 总之，己亥年就在 OIer 们不得不与 CCF 站在同一战线上对抗 jyb 这样一种可笑又无奈的状况下开始了。 不久之后， OI 又重新回到了竞赛名单中去。然而坏头已经开了，谁敢说一切都过去了呢。 壹初中生的省队名额变为了 E 类，省选也从三天变成了两天。 CTSC 扔了 C ，改名 CTS 避开收费的限制。 大家如果细心的话，你会发现，我们今年的选拔赛 少了一个字母「C」，「C」就是 competition（大笑+鼓掌），为什么「C」没了呢？好，给你们直说吧，如果是「赛」，就不让收费（大笑+鼓掌），不让收费呢，CCF 是没钱的（大笑+鼓掌） 啊 没有一分钱的政府的拨款（大笑+鼓掌）。500 名同学呢，你就要失去机会，只有 15 名同学我们选拔 4 位，我们还是要收点费的，要不然没有钱也没法干这活，啊，当然这钱也不一定够。——dzd 在 CTS2019 闭幕式上的讲话 zxr 省选挂分凉凉没进队退役， hz 倒二进 B ， pb 没成功拿到 E 类。为 z 老师惋惜的同时，也开始思考在强省进队的难度和自己目前实力的巨大差距。 只集训不停课，勉强保持着班级平均分。 贰就这样到了暑假。NOI 最后也没有收取「报名费」，而是以「食宿费」的名义收取了费用。 集训期间打了 NOI2019 网络同步赛，正好遇见 NOI 历史上第一道交互题。 一群初三升高一的神仙去浙江金华参加 ZR 集训，顺便逃了军训。 某老人生日前夕 CCF 突然放出暂停 NOIP 的公告，掀起轩然大波，被众多 OIer 的脚本刷到了一亿阅读量。 不安之中，暑假结束，迎来了 CCF 关于举办 CSP-S/J 的报名通知。一切，似乎又好起来了？ 肆开学，迎来初三生活。 吃完隔壁物理竞赛的学军瓜，刚考完第一次月考，距离 CSP 只剩一个月多。OI 生涯第一次停课，停了一个多月课冲刺 CSP 。 然而考得并不理想，回去之后文化课又落了一大截，从平均分掉到总分 30 名左右。 文化课生活太烦了，不知不觉重心有点向竞赛偏移了。 伍大概 jyb 终于开始向 CCF 反击了罢。1 月 15 日 jyb 发布的强基计划，感觉字里行间都是在针对 OI 。 利空消息一个接一个地到来：CS 没有列入强基计划的专业中；传出「 NOI 系列赛的奖项将不能作为强基计划校评部分的参考」的传闻；WHU 给签约选手打电话，通知签约作废的消息。 省一真就明面上什么用也没有了，据传 NOI 至少要 Ag 才有优惠可以拿。 kkksc03 在知乎发表的回答和 StudyingFather 的分析，使这件事看起来好像又没那么坏。 智子一如既往地开始在洛谷跳脚，大肆发表过激（？）言论（虽然他怼的人绝大多数比他的言论更草）。犇犇充斥着以其为首的激愤情绪与对 jyb 及此计划的强烈批判，洛谷管理员临时关闭犇犇。 而智子也在 18 日挨了洛弹。 StudyingFather 的灯下随笔（1）（2）（3）反复看了几遍，有些迷茫。 唯一能做的，也许是趁寒假补补文化课，尽量恢复到班级水平平均值罢。 毕竟 jyb 怎么搞我们，现在也还没能下定论。形势虽然偏向坏的方向，但总归不稳定，谁知道最后又会变成怎么样？ 陆1 月 21 日，CCF 发布了恢复 NOIP 竞赛的公告，去年拿的没什么用的一等证书或成为绝版。脚本哥们好像都回家过年了，如今一周后才刚破一千万阅读量。 WC 延期，某咕了一年的省内比赛延期……情况越发复杂多变。 反正寒假也很长，慢慢补文化课吧。 终如果现高三高二学生的一等约没法兑现，我想他们的人生轨迹也会因 jyb 被改变吧。 倘若这些学生们真的成为这场改革的「牺牲者」，我们除了替他们惋惜以外，又能够做什么呢。 倘若我们成为这场改革的「牺牲者」，我们除了替自己惋惜以外，又能够做什么呢。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>计划与总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC022E」Median Replace]]></title>
    <url>%2Fblog%2FAGC022E%2F</url>
    <content type="text"><![CDATA[这是毕克好久之前讲过的题……当时没写，现在再看到，回忆起做法就写了一发。 题意简述[AGC 022E] 定义长度为 $n$（奇数）的 01 字符串是好的，当且仅当可以通过进行 $\frac{n - 1}{2}$ 次下面的变换，使得最后字符串变为 1 。 变换是选择一个长度为 $3$ 的字串，将其改为这 $3$ 个字符的众数（即每次操作会减少 $2$ 个字符）。 先有一个字符串 $S$ ，保证长度为奇数，只含有 0, 1, ? 。分别将每个 ? 改为 0 与 1 中的一种，问有多少种方案，使得字符串是好的。 $1\le |S|\le 3\times 10^5$ 。 主要思路可以发现，如果在字符串后面加入一个字符，某些操作是不劣的。比如 000 肯定先变成 0 ，011 或 101 肯定先变成 1 。 然后我们可以构造出如下的自动机。 至于为啥 11 只加一个字符就可以再次变为 11 ，你可以理解为 11 后面无论加入什么，最后总是好的。 然后就可以倒着 dp 了。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 1000000007; #ifdef using_mod inline void inc(int &amp;x, const int &amp;y)&#123; x += y; if(x &gt;= mod) x -= mod; &#125; inline void dec(int &amp;x, const int &amp;y)&#123; x -= y; if(x &lt; 0) x += mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; inline int VSC_Local()&#123; #ifdef VSC_Compile while(getchar() != '\n'); #endif return 0; &#125; #define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout) #define PBTXDY&#125;using namespace my_std;/* * null + '0' -&gt; "0", null + '1' -&gt; "1" * "0" + '0' -&gt; "00", "0" + '1' -&gt; "01" * "1" + '0' -&gt; "10", "1" + '1' -&gt; "11" * "00" + '0' -&gt; "0", "00" + '1' -&gt; "0" * "01" + '0' -&gt; "0", "01" + '1' -&gt; "1" * "10" + '0' -&gt; "100", "10" + '1' -&gt; "1" * "11" + '0' -&gt; "11", "11" + '1' -&gt; "11" * "100" + '0' -&gt; "10", "100" + '1' -&gt; "10"*/const int N = 300010, trans[8][2] = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;, &#123;1, 1&#125;, &#123;1, 2&#125;, &#123;7, 2&#125;, &#123;6, 6&#125;, &#123;5, 5&#125;&#125;;int n, dp[N][8];char sc[N];int main()&#123; scanf("%s", sc); n = strlen(sc); dp[n][2] = dp[n][6] = 1; ROF(i, n - 1, 0)&#123; FOR(t, 0, 7)&#123; if(sc[i] != '0') inc(dp[i][t], dp[i + 1][trans[t][1]]); if(sc[i] != '1') inc(dp[i][t], dp[i + 1][trans[t][0]]); &#125; &#125; printf("%d\n", dp[0][0]); return VSC_Local();&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>AtCoder</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC037E」Reversing and Concatenating]]></title>
    <url>%2Fblog%2FAGC037E%2F</url>
    <content type="text"><![CDATA[题意简述[AGC 037E] 给你一个长为 $n$ 的字符串 $S$ ，你可以进行下面的操作 $k$ 次： 将 $S$ 翻转后接在 $S$ 后面得到一个长为 $2n$ 的字符串 $U$，再将 $S$ 改为 $U$ 的一个长为 $n$ 的子串。 求最后所得字典序最小的字符串。 $1\le n\le 5000, 1\le k\le 10^9$ 。 主要思路设 $S$ 中最小的字符为 $c$ ， $U$ 中最长的连续 $c$ 的个数为 $mxl$ 。 若 $2^k\times mxl \ge n$ ，则我们可以每次将最长连续 $c$ 的结尾作为选择的新 $S$ 的结尾，这样最后字符串将变为 $n$ 个 $c$ 。 否则，最后字符串必定开头有 $2^k\times mxl$ 个 $c$ 。而后面的 $n - 2^k\times mxl$ 个字符为第一次选择的新 $S$ 的翻转后的 $[mxl + 1, mxl + n - 2^k\times mxl]$ 字串。 注意到 $n\le 5000$ ，暴力比对取字典序最小即可。 若 $n$ 较大，也可使用各种后缀排序的算法 $O(n\log n)$ 或 $O(n)$ 解决。 果然这场的难度是乱序排的……另外这题在kenkoooo上的难度是 2845 ，在 AGC 的 E 来说是评分很低的。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353; #ifdef using_mod inline void inc(int &amp;x, const int &amp;y)&#123; x += y; if(x &gt;= mod) x -= mod; &#125; inline void dec(int &amp;x, const int &amp;y)&#123; x -= y; if(x &lt; 0) x += mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; inline int VSC_Local()&#123; #ifdef VSC_Compile while(getchar() != '\n'); #endif return 0; &#125; #define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout) #define PBTXDY&#125;using namespace my_std;const int N = 20010;int n, K, usd[N];char sc[N], ans[N];int main()&#123; n = read(), K = read() - 1; scanf("%s", sc + 1); reg char mn = 'z'; Rint len = 0, mxl = 0; FOR(i, 1, n) sc[2 * n + 1 - i] = sc[i], chkmin(mn, sc[i]); ROF(i, n * 2, n + 1)&#123; Rint l = i; while(sc[l] == mn &amp;&amp; i - l &lt; n) --l; chkmax(mxl, i - l); i = l; &#125; if(K &gt;= 13 || n &lt;= (1 &lt;&lt; K) * mxl)&#123; FOR(i, 1, n) putchar(mn); return VSC_Local(); &#125; ROF(i, n * 2, n + 1)&#123; Rint l = i; while(sc[l] == mn &amp;&amp; i - l &lt; n) --l; if(i - l == mxl) usd[i] = 1; &#125; len = n - (1 &lt;&lt; K) * mxl; FOR(i, 1, n) ans[i] = 'z'; function&lt;void(int)&gt; check = [&amp;](int x)&#123; FOR(i, 1, len)&#123; if(sc[x - i] &gt; ans[i]) return; if(sc[x - i] &lt; ans[i])&#123; FOR(j, 1, len) ans[j] = sc[x - j]; return; &#125; &#125; &#125;; FOR(i, n + 1, n * 2) if(usd[i]) check(i - mxl + 1); FOR(i, len + 1, n) putchar(mn); FOR(i, 1, len) putchar(ans[i]); return VSC_Local();&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>猜结论</tag>
        <tag>字符串</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC011D」Half Reflector]]></title>
    <url>%2Fblog%2FAGC011D%2F</url>
    <content type="text"><![CDATA[题意简述[AGC 011D] 给你一个长为 $n$ 的 AB 字符串。假设一个球从某一个方向（左或右）到达了一个 A ，该位置将变为 B 且该球会反弹；到达了一个 B ，该位置将变为 A 且该球会穿过该位置。 现在从字符串的最左边扔进去 $k$ 个球，每个球都在上一个球已经弹出字符串之后再放入（可以证明，任何字符串都不能把球永远留在字符串中）。 求最后的字符串。 $1\le n\le 200000, 1\le k\le 10^9$ 。 主要思路$k$ 这么大，说明最后的复杂度和 $k$ 没大关系。 发现如果扔进去球的时候第一个位置是 A ，则球从左边弹出，只改变第一个位置的值；否则，必然从右边弹出。 考虑球从某个位置的右边弹出时，原先在的位置和弹到的位置的值（注意到弹出时该位置必定为 A）。 AA 变为 BA ； AB 变为 AA ； 发现第二个位置的值取反即为最后第一个位置的值。 加以分析，即可得若球从字符串右边弹出，新字符串为原字符串左移一位每位取反后，最后一位补上 A 。 这样就得到了一个 $O(n + k)$ 的做法。 由于球从字符串右边弹出后，字符串最后一位必为 A ，所以球从字符串右边弹出若干次后，字符串有后缀 ...ABABA 。扔入足够多的球后，长度为偶数的字符串将变为 BABA...BABA 并保持稳定；长度为奇数的字符串将在 ABAB...BABA 与 BBAB...BABA 中反复。 显然，扔入两个球后至少有一个是从右边弹出的，故若 $k &gt; 2n$ ，可以直接利用上面的结论得到答案。 这样就得到了 $O(n)$ 做法。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;//AGC011Dnamespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353; #ifdef using_mod inline void inc(int &amp;x, const int &amp;y)&#123; x += y; if(x &gt;= mod) x -= mod; &#125; inline void dec(int &amp;x, const int &amp;y)&#123; x -= y; if(x &lt; 0) x += mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; inline int VSC_Local()&#123; #ifdef VSC_Compile while(getchar() != '\n'); while(getchar() != '\n'); #endif return 0; &#125; #define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout) #define PBTXDY&#125;using namespace my_std;const int N = 200010;int n, m, a[N &lt;&lt; 2], tag, fst;char S[N];int main()&#123; n = read(), m = read(); scanf("%s", S + 1); FOR(i, 1, n) a[i] = S[i] == 'A'; fst = 1; function&lt;void(void)&gt; update = [&amp;]()&#123; if(a[fst] ^ tag)&#123; a[fst] ^= 1; return; &#125; tag ^= 1; a[fst + n] = tag ^ 1; fst++; &#125;; FOR(i, 1, min(m, n * 3)) update(); if(m &gt; n * 3)&#123; if(n &amp; 1)&#123; Rint t = m - n * 3; if(t &amp; 1) update(); FOR(i, fst, fst + n - 1) putchar('B' - (tag ^ a[i])); &#125; else&#123; FOR(i, 1, n) putchar('A' + (i &amp; 1)); &#125; &#125; else&#123; FOR(i, fst, fst + n - 1) putchar('B' - (tag ^ a[i])); &#125; return VSC_Local();&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>猜结论</tag>
        <tag>AtCoder</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成函数初步学习笔记]]></title>
    <url>%2Fblog%2F%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[开始学生成函数了。 普通型生成函数生成函数是形式幂级数，不必顾虑收敛性等问题。对于一个数列 ${f_n}$，定义其普通型生成函数（Ordinary Generating Function，简称 OGF ）为 $F(x)=\sum\limits_{n\ge 0}{f_n x^n}$。$f_n$ 是 $x^n$ 在 $F(x)$ 中的系数（Coefficient），也写作 $f_n = [x^n]F(x)$。 一些例子$$\begin{aligned} \sum\limits_{n\ge 0}[n = m]x^n &amp;= x^m\\ \sum\limits_{n\ge 0}x^n &amp;= \dfrac{1}{1 - x}\end{aligned}$$ 由上面的那个式子可以得到以下四条： $$\begin{aligned} \sum\limits_{n\ge m}x^n &amp;= \dfrac{x^m}{1 - x}\\ \sum\limits_{n\ge 0}x^{nk} &amp;= \dfrac{1}{1 - x^k}\\ \sum\limits_{n\ge 0}c^n x^n &amp;= \dfrac{1}{1 - cx}\\ \sum\limits_{n\ge 0}\binom{n + k - 1}{n}x^n &amp;= \dfrac{1}{(1 - x)^k}\end{aligned}$$ 利用泰勒展开可以得到以下三条： $$\begin{aligned} \sum\limits_{n\ge 0}\dfrac{x^n}{n!}&amp;=e^x\\ \sum\limits_{n &gt; 0}\dfrac{x^n}{n} &amp;= \ln \dfrac{1}{1 - x}\\ \sum\limits_{n &gt; 0}\dfrac{(-1)^{n - 1}x^n}{n} &amp;= \ln (1 + x)\end{aligned}$$ 运算设 $F(x),G(x)$ 为数列 ${f_n}, {g_n}$ 的 OGF。 $$\begin{aligned} cF(x) &amp;= \sum\limits_{n\ge 0}cf_nx^n\\ x^mF(x) &amp;= \sum\limits_{n\ge m}f_{n - m}x^n\\ F(cx) &amp;= \sum\limits_{n\ge 0}c^nf_{n}x^n\\ \frac{\mathrm{d}}{\mathrm{d}x}F(x) &amp;= \sum\limits_{n\ge 0}(n + 1)f_{n + 1}x^n\\ \int_{0}^{x} F(x)\mathrm{d}x &amp;= \sum\limits_{n &gt; 0}\frac{f_{n - 1}}{n} x^n\\ F(x)G(x) &amp;= \sum\limits_{n\ge 0}(\sum\limits_{i=0}^{n}f_i g_{n - i})x^n\\ F(G(x)) &amp;= \sum\limits_{n\ge 0}f_n(G(x))^n\end{aligned}$$ 简单例题Example 1求数列 $a_n = \begin{cases} 1 &amp;,n = 0\\ ta_{n - 1} + w^{n - 1} &amp;,n &gt; 0\end{cases}$ 的通项公式。其中 $t, w &gt; 0$。 设 ${a_n}$ 的普通型生成函数为 $A$ ，则有 $A = tAx + \sum\limits_{n = 0}w^{n}x^{n} = tAx + \dfrac{1}{1 - wx}$。 则解出 $A = \dfrac{1}{(1 - tx)(1 - wx)}$。 所以 $a_n = \displaystyle\sum\limits_{i=0}^{n} t^i w^{n - i} = \dfrac{t^{n + 1} - w^{n + 1}}{t - w}$。 Example 2证明 $4^n = \sum\limits_{i=0}^{n}\binom{2i}{i}\binom{2n-2i}{2i}$。 设 $F = \sum\limits_{i\ge 0}\binom{2i}{i}x^i$，则需证 $F^2 = (1-4x)^{-1}$。 $(1 - 4x)^{-\frac{1}{2}} = \sum\limits_{n\ge 0}(-4)^n\dbinom{-\frac{1}{2}}{n}x^n = F$，证毕。 $$\begin{aligned} \dbinom{-\frac{1}{2}}{n} &amp;= \dfrac{(-\frac{1}{2})^{\underline{n}}}{n!}\\ &amp;= \dfrac{\prod\limits_{i=1}^{n}(-\frac{2i - 1}{2})}{n!}\\ &amp;= \dfrac{(-1)^n\prod\limits_{i=1}^{n}(2i - 1)}{2^n n!}\\ &amp;= \dfrac{(-1)^n(2n)!}{4^n (n!)^2}\\ &amp;= \dfrac{(-1)^n}{4^n}\binom{2n}{n}\end{aligned}$$ Example 3Catalan 数列：$f_n = [n = 0] + \sum\limits_{i = 0}^{n - 1}f_i f_{n - i - 1}$，求其通项公式。 易得其生成函数 $F(x)$ 有 $F(x) = 1 + x(F(x))^2$。 将 $F(x)$ 看作元而 $x$ 看作参，则 $F(x) = \dfrac{1\pm \sqrt{1 - 4x}}{2x}$。 由于 $f_0 = 1$，即 $\lim_{x\to 0}F(x) = 1$，故取 $F(x) = \dfrac{1 - \sqrt{1 - 4x}}{2x}$。 类似 Example 2 来化简它： $\sqrt{1 - 4x} = \sum\limits_{n\ge 0}(-4)^n\dbinom{\frac{1}{2}}{n}x^n = -2\sum\limits_{n\ge 0}\dfrac{(2n - 2)!}{n!(n - 1)!}x^n$ 故 $F(x) = \sum\limits_{n\ge 0}\dfrac{(2n)!}{n!(n + 1)!}x^n$，即 $f_n = \dfrac{(2n)!}{n!(n + 1)!}$。 指数型生成函数指数型生成函数与用于处理组合问题的普通型生成函数相对，用于处理排列问题。对于一个数列 ${f_n}$，定义其指数型生成函数（Exponential Generating Function，简称 EGF ）为 $F(x)=\sum\limits_{n\ge 0}{f_n \dfrac{x^n}{n!}}$。 运算设 $F(x),G(x)$ 为数列 ${f_n}, {g_n}$ 的 EGF。 大部分与 OGF 相同。 $$\begin{aligned} F(x)G(x) &amp;= \sum\limits_{n\ge 0}(\sum\limits_{i=0}^n \binom{n}{i}f_i g_{n - i})\dfrac{x^n}{n!}\\ \frac{\mathrm{d}}{\mathrm{d}x}F(x) &amp;= \sum\limits_{n\ge 0}f_{n + 1}\dfrac{x^n}{n!}\\ \int_{0}^{x} F(x)\mathrm{d}x &amp;= \sum\limits_{n &gt; 0}f_{n - 1}\dfrac{x^n}{n!}\\ xF(x) &amp;= \sum\limits_{n &gt; 0} \dfrac{f_{n - 1}}{n}\cdot\dfrac{x^n}{n!}\\ \frac{1}{x}(F(x) - f_0) &amp;= \sum\limits_{n\ge 0} f_{n + 1}\dfrac{x^n}{n!}\end{aligned}$$ 一些例子$$\begin{aligned} \sum\limits_{n\ge 0}\dfrac{x^n}{n!} &amp;= e^x\\ \sum\limits_{n\ge 0}\dfrac{c^n x^n}{n!} &amp;= e^{cx}\\ \sum\limits_{n\ge 0}\dfrac{n^\underline{k} x^n}{n!} &amp;= x^k e^x\\ \sum\limits_{n &gt; 0}(n - 1)!\dfrac{x^n}{n!} &amp;= \ln\dfrac{1}{1 - x}\end{aligned}$$ 简单应用Example 1 ——贝尔数贝尔数 $w_n$ 为将 $n$ 个不同元素划分为任意多个无序非空子集的方案数。 考虑递推，枚举1所在的子集大小 $i$，则应从剩下 $n - 1$ 个中选择 $i - 1$ 个与1放在同一集合，而其他随便放。即 $w_n = [n = 0] + \sum\limits_{i = 1}^{n}\binom{n - 1}{i - 1}w_{n - i}$。 设其 EGF 为 $W(x)$，则：$$\begin{aligned} W(x) &amp;= 1 + \displaystyle\int W(x) e^x \mathrm{d}x\\ \dfrac{\mathrm{d}W(x)}{\mathrm{d}x} &amp;= W(x)e^x\\ \dfrac{\mathrm{d}W(x)}{W(x)} &amp;= e^x\mathrm{d}x\\ \ln W(x) &amp;z= e^x + C\end{aligned}$$ 代入 $W(0) = w_0 = 1$，可得 $C = -1$。 故 $W(x) = \exp(e^x - 1)$。这个式子的组合解释？ 考虑到 $F = e^x - 1$ 就是「非空子集」的 EGF（对于任意 $n &gt; 0$ 均有一种方法把 $n$ 个元素放进一个集合里），那么套一层exp即 $\exp F = \displaystyle\sum\limits_{k\ge 0}\dfrac{F^k}{k!}$。 $k$ 可以看作非空子集的个数，且非空子集无序，故除以 $k!$。 类似地，可以得到 $n$ 个不同元素划分为任意多个无序非空集合，大小为 $k$ 的集合价值为 $a_k$，一种方案的价值为所有划分成的非空集合的价值的积，求所有方案的价值和，答案的 EGF 即为 $\exp(A(x))$。 Example 2 ——简单无向连通图求 $f_n$ 表示 $n$ 个点的简单无向连通图的个数（点带标号）。 先设 $g_n$ 表示 $n$ 个点的简单无向图的个数，即 $g_n = 2^{\binom{n}{2}}$。 那么 $n$ 个点的简单无向连通图，可以用 $g_n$ 减去不连通图的个数。不连通，则枚举1号点所在连通块大小 $k$。即：$$f_n = g_n - \sum\limits_{i = 1}^{n - 1}\binom{n - 1}{i - 1}f_i g_{n - i}$$移项，就得到 Example 1 中我们见过的式子：$$g_n = \sum\limits_{i = 1}^{n}\binom{n - 1}{i - 1}f_i g_{n - i}$$ 设 $F(x), G(x)$ 分别为 ${f_n},{g_n}$ 的 EGF，则 $G(x) = \exp F(x)$，即 $F(x) = \ln G(x)$。 于是我们得到ln的用处：如果我们知道了一个生成函数exp之后是什么，就可以把它ln回来。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>生成函数</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式版本控制系统Git学习笔记]]></title>
    <url>%2Fblog%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9FGit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Git 是目前世界上最先进的分布式版本控制系统。 安装Windows 下直接官网下，Linux 下可以直接 sudo apt-get install git 。 使用下面的命令来设置本地的账户名字与邮箱地址。 12git config --global user.name "Your Name"git config --global user.email "email@example.com" Windows 下出现「Git Credential Manager for Windows」对话框，关闭需要git config --edit --system，然后删除helper = manager行。但据说根据环境及安装时行为不同，有不同关闭方案。 每次远程操作都要输密码很烦？某次输入后git config --global credential.helper store即可。 创建版本库版本库，就是仓库，英文即为 repository 。 选择一个根目录。 如果你使用 Windows 系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。（啊，当然这提醒说不定已经过时了） 第二步，通过git init命令把这个目录变成 Git 可以管理的仓库。 然后根目录下就会多出一个.git的隐藏目录，如果你没有看到.git目录，用ls -ah命令就可以看见。 把文件添加到版本库 首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如 TXT 文件，网页，所有的程序代码等等，Git 也不例外。版本控制系统可以告诉你每次的改动，比如在第 5 行加了一个单词 “Linux” ，在第 8 行删了一个单词 “Windows” 。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从 100KB 改成了 120KB ，但到底改了啥，版本控制系统不知道，也没法知道。不幸的是， Microsoft 的 Word 格式是二进制格式，因此，版本控制系统是没法跟踪 Word 文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。因为文本是有编码的，比如中文有常用的 GBK 编码，日文有 Shift_JIS 编码，如果没有历史遗留问题，强烈建议使用标准的 UTF-8 编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 使用 Windows 要特别注意：千万不要使用 Windows 自带的记事本编辑任何文本文件。原因是 Microsoft 开发记事本的团队使用了一个非常弱智的行为来保存 UTF-8 编码的文件，他们自作聪明地在每个文件开头添加了 0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个 “?” ，明明正确的程序一编译就报语法错误，等等。这些都是由记事本的弱智行为带来的。 言归正传，把一个文件添加到 Git 仓库需要两步。 把文件添加或更新到仓库： 12git add &lt;file&gt;git add &lt;file1&gt; &lt;file2&gt; ... 执行上面的命令，没有任何显示，这就对了，Unix 的哲学是“没有消息就是好消息”，说明添加或修改成功。 把文件提交(commit)到仓库： 1git commit -m "massage" -m 后面输入的字符串是对本次提交的说明，可以输入任意内容，当然最好是有意义的。 掌握工作区状态git status命令可以让我们时刻掌握工作区当前的状态。 就比如说原博客给的一个例子： 123456789$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.txtno changes added to commit (use "git add" and/or "git commit -a") 上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 那假如我想要知道readme.txt哪里被修改了怎么办？这时就需要使用git diff命令来查看。 例如原博客给的一个例子： 123456789$ git diff readme.txt diff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software. git diff顾名思义就是查看 difference ，显示的格式正是 Unix 通用的 diff 格式。可以从上面的命令输出看到，我们在第一行添加了一个 distributed 单词。 也可以git diff &lt;file&gt;来查看单个文件的修改。 查看历史提交记录git log指令可以显示从最近到最远的提交日志。 会显示每次提交的 commit id, Author, Date 与我们在提交时写的&lt;message&gt;。 如果嫌输出信息太多，看得眼花缭乱的，可以使用git log --pretty=oneline，这样只会显示 commit id 和&lt;message&gt;。 使用git reflog可以显示每一次命令，包括提交、回退版本等。 版本回退首先， Git 必须知道当前版本是哪个版本，在 Git 中，用 HEAD 表示当前版本，也就是最新的提交，上一个版本就是 HEAD^ ，上上一个版本就是 HEAD^^ ，当然往上 100 个版本写 100 个 ^ 比较容易数不过来，所以写成 HEAD~100 。 就比如说git reset --hard &quot;HEAD^&quot;就回退到上一个版本。 所以说回退版本的命令就是： 1git reset --hard &lt;commit_id&gt; 这样就回退到你需要的版本了。 但是如果要恢复新版本怎么办？ 通过git reflog查看新版本对应的 commit id ，也使用上述指令即可。 Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的HEAD指针，当你回退版本的时候， Git 仅仅是把HEAD修改，然后顺便把工作区的文件更新。所以不仅可以回到历史版本也可以返回新版本。 工作区与暂存区的概念工作区即直接能看到的目录。 版本库打开显示隐藏目录，会发现.git目录。这个不算工作区，而是 Git 的版本库。 Git 的版本库中存了很多东西，比如称为 stage 或 index 的暂存区，及每个分支，指针HEAD。 回忆我们怎么把文件往 Git 版本库里添加： git add，把文件加入暂存区。 git commit，提交更改，即把把暂存区的所有内容提交到当前分支。 所以你在git status后看到的三类文件大概就是： Untracked files，从来未被添加过的文件。 Changes not staged for commit，在工作区修改了但没有将修改加入暂存区的文件。 Changes to be commited，加入了暂存区，还没有提交到分支的文件。 当我们加入某个文件到暂存区，之后再将其修改，未重新加入缓存区后提交到分支，则分支中的版本为先前暂存区中的版本。 可以使用git diff HEAD -- &lt;file&gt;验证。 参考文献Pro Git 廖雪峰的Git教程]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1266F」Almost Same Distance]]></title>
    <url>%2Fblog%2FCF1266F%2F</url>
    <content type="text"><![CDATA[nantf 由于生病窝在家里打 Global Round 6 然后 rating 超过 p_b_p_b 了…… 然后他场上做了 A - E。 题意简述[CF 1266F] 给定一棵树大小为 $n$ 。定义一个点集 $S$ 是 $k$ 均匀的，当且仅当对于任意 $u,v\in S, u\ne v$ ，有 $\operatorname{dist}(u, v) = k$ 或 $\operatorname{dist}(u, v) = k + 1$ ，其中 $\operatorname{dist}(u, v)$ 表示 $u$ 与 $v$ 在树上的距离，即它们的简单路径上的边数。 现在希望你对于 $1\le k\le n$ ，求出 $k$ 均匀点集点数的最大值。$2 \le n \le 5\times 10^5$ 。 主要思路题解讲得很迷，然后看了300iq的代码才明白的。 设 $ans[k]$ 为 $k$ 均匀点集点数的最大值。 显然我们可以 dfs 求出最长链的长度 $mxl$ ， $k &gt; mxl$ 则 $ans[k] = 1$ ， $k \le mxl$ 则 $ans[k] \ge 2$ 。 称一棵有根树的最深深度为根节点到所有叶子节点的距离最大值。 对于 $k = 2l + 1$ ($l &gt; 1$) ，最大 $k$ 均匀集必定以一个点 $r$ 为“中心”（该点不在均匀集中），而所有均匀集中的点 $x$ 距离 $r$ 为 $l + 1$ 或 $l$ ，且距离为 $l$ 的点的数量不超过 $1$ 个。 对于 $k = 2l$ ($l &gt; 1$) ，也类似，不过较为复杂。可能是以一个点 $r$ 为“中心”，此时所有均匀集中的点 $x$ 距离 $r$ 为 $l$ ；也可能是以一条边 $(s, t)$ 为“中心”，此时所有均匀集中的点 $x$ 有 $\min(\operatorname{dist}(x, s), \operatorname{dist}(x, t)) = l$ 。 由上，可得 $ans[k] \ge ans[k + 2]$ 。 对于 $k$ 为奇数，或 $k$ 为偶数的第一种情况，我们可以对每个点 $u$ ，求出若这棵树以这个点为根，它每个儿子的子树最深深度，并降序排序存入数组 $ret$ 中。 这样，我们就可以 $O(n\log_2 n)$ 地获得上述情况的答案。 这部分非常好写，但是对于 $k$ 为偶数且以一条边为“中心”的情况无法处理。 对于这种情况，我们对每个点 $u$ ，枚举其儿子 $v$ 。然后对于 $v$ 也求出它每个儿子的子树最深深度（不包含 $u$ ），并降序存入数组 $tmp$ 中。 然后对于每个 $ret[i], tmp[i]$ ，用类似上述的方法来更新。 这里每个节点会被访问两次，所以总的时间复杂度还是 $O(n\log_2 n)$ 。 参考代码上面的东西都可以两次 dfs 搞定。 写得丑了点不要介意。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 500010; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; inline int VSC_Local()&#123; #ifdef VSC_Compile while(getchar() != '\n'); #endif return 0; &#125; #define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout) #define PBTXDY&#125;using namespace my_std; #define swap(a,b) (a ^= b ^= a ^= b) int n, dep[N], mxl, ans[N &lt;&lt; 2], anss[N &lt;&lt; 2];vector&lt;int&gt; g[N]; struct BIT&#123; int a[N]; inline void update(int x, int v)&#123; for(; x &gt;= 0; x = (x &amp; (x + 1)) - 1) a[x] += v; &#125; inline int query(int x)&#123; Rint res = 0; for(; x &lt;= n; x = (x | (x + 1))) res += a[x]; return res; &#125;&#125;BT; void dfs(int u, int fth)&#123; dep[u] = 0; for(int v : g[u])&#123; if(v != fth)&#123; dfs(v, u); chkmax(dep[u], dep[v] + 1); &#125; &#125; return;&#125; void solve(int u, int fth, int upx)&#123; vector&lt;int&gt; ret&#123;upx, 0&#125;; for(int v : g[u])&#123; if(v != fth) ret.push_back(dep[v] + 1); &#125; sort(ret.rbegin(), ret.rend()); Rint fr = ret[0], sc = ret[1], siz = (int)ret.size(); chkmax(mxl, fr + sc); FOR(i, 1, siz - 1)&#123; chkmax(ans[2 * ret[i] + (ret[i] &lt; ret[i - 1])], i + 1); &#125; for(int v : g[u])&#123; if(v == fth) continue; Rint tmp = (dep[v] + 1 == fr ? sc : fr); solve(v, u, tmp + 1); &#125; vector&lt;int&gt; vec(siz); for(int v : g[u])&#123; if(v == fth) continue; vector&lt;int&gt; tmp; for(int x : g[v])&#123; if(x != u) tmp.push_back(dep[x] + 1); &#125; sort(tmp.rbegin(), tmp.rend()); FOR(i, 0, (int)tmp.size() - 1)&#123; Rint l = 0, r = siz, mid; while(l &lt; r - 1)&#123; mid = (l + r) &gt;&gt; 1; if(ret[mid] &lt;= tmp[i]) r = mid; else l = mid; &#125; if(r != siz)&#123; chkmax(vec[r], i + 1); chkmax(anss[2 * tmp[i]], i + l + 1); &#125; &#125; &#125; FOR(i, 1, siz - 1)&#123; chkmax(vec[i], vec[i - 1]); &#125; FOR(i, 0, siz - 1)&#123; chkmax(anss[2 * ret[i]], i + vec[i]); &#125; return;&#125; int main()&#123; n = read(); Rint u, v; FOR(i, 1, n - 1)&#123; u = read() - 1, v = read() - 1; g[u].push_back(v), g[v].push_back(u); &#125; dfs(0, -1); solve(0, -1, 0); ROF(i, n - 1, 1) chkmax(ans[i], ans[i + 1]); ROF(i, n - 2, 1) chkmax(anss[i], anss[i + 2]); FOR(i, 1, n)&#123; chkmax(ans[i], anss[i]); chkmax(ans[i], 1 + (i &lt;= mxl)); &#125; FOR(i, 1, n) printf("%d ", ans[i]); puts(""); return VSC_Local();&#125; dfs(v, u); chkmax(dep[u], dep[v] + 1); &#125; &#125; return;&#125;void solve(int u, int fth, int upx)&#123; vector&lt;int&gt; ret&#123;upx, 0&#125;; for(int v : g[u])&#123; if(v != fth) ret.push_back(dep[v] + 1); &#125; sort(ret.rbegin(), ret.rend()); Rint fr = ret[0], sc = ret[1], siz = (int)ret.size(); chkmax(mxl, fr + sc); FOR(i, 1, siz - 1)&#123; chkmax(ans[2 * ret[i] + (ret[i] &lt; ret[i - 1])], i + 1); &#125; for(int v : g[u])&#123; if(v == fth) continue; Rint tmp = (dep[v] + 1 == fr ? sc : fr); solve(v, u, tmp + 1); &#125; for(int x : ret) BT.update(x, 1); vector&lt;int&gt; vec(siz); for(int v : g[u])&#123; if(v == fth) continue; BT.update(dep[v] + 1, -1); vector&lt;int&gt; tmp; for(int x : g[v])&#123; if(x != u) tmp.push_back(dep[x] + 1); &#125; sort(tmp.rbegin(), tmp.rend()); FOR(i, 0, (int)tmp.size() - 1)&#123; Rint l = 0, r = siz, mid; while(l &lt; r - 1)&#123; mid = (l + r) &gt;&gt; 1; if(ret[mid] &lt;= tmp[i]) r = mid; else l = mid; &#125; if(r != siz)&#123; chkmax(vec[r], i + 1); &#125; &#125; FOR(i, 0, (int)tmp.size() - 1)&#123; chkmax(anss[2 * tmp[i]], i + 1 + BT.query(tmp[i])); &#125; BT.update(dep[v] + 1, 1); &#125; FOR(i, 1, siz - 1)&#123; chkmax(vec[i], vec[i - 1]); &#125; FOR(i, 0, siz - 1)&#123; chkmax(anss[2 * ret[i]], i + vec[i]); &#125; for(int x : ret) BT.update(x, -1); return;&#125;int main()&#123; n = read(); Rint u, v; FOR(i, 1, n - 1)&#123; u = read() - 1, v = read() - 1; g[u].push_back(v), g[v].push_back(u); &#125; dfs(0, -1); solve(0, -1, 0); ROF(i, n - 1, 1) chkmax(ans[i], ans[i + 1]); ROF(i, n - 2, 1) chkmax(anss[i], anss[i + 2]); FOR(i, 1, n)&#123; chkmax(ans[i], anss[i]); chkmax(ans[i], 1 + (i &lt;= mxl)); &#125; FOR(i, 1, n) printf("%d ", ans[i]); puts(""); return VSC_Local();&#125; 顺便从300iq那里学来了一个东西。 1234567891011struct BIT&#123; int a[N]; inline void update(int x, int v)&#123; for(; x &gt;= 0; x = (x &amp; (x + 1)) - 1) a[x] += v; &#125; inline int query(int x)&#123; Rint res = 0; for(; x &lt;= n; x = (x | (x + 1))) res += a[x]; return res; &#125;&#125;BT; 这个东西可以支持单点修改和查询后缀和。证明正确性和复杂度的方法好像和普通树状数组差不多。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>dfs类</tag>
        <tag>树论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF掉分笔记]]></title>
    <url>%2Fblog%2FCF%E6%8E%89%E5%88%86%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录本人 Codeforces 的比赛历程与心得。 Codeforces Round #606Codeforces Round #606(Div.1, Div.2) and Technocup — Elimination Round 4 (2019.12.14 19:05) RATING CHANGE: 1922 -&gt; 1869 第一场 div 1 ，然后自闭了只做出来 A …… A 都写了十分钟。 然后开 B ，发现是个不知道什么玩意的图论，盲猜 Tarjan 或者其他什么小玩意。 图论不擅长啊。直接跳了看 C 。 是构造题，我喜欢。把 $4\times 10^5$ 看成 $4\times 10^4$ ，然后推了许久搞出来个 $O(n\sqrt{n})$ 的暴力。 交上去 RE on 48 了，检查了好久，又交了几遍。 终于重新读了一遍题，发现数据范围看错了。马上改数据范围。 2.5e8 你 CF 一秒跑不过？我当场，就把这个键盘吃掉！ 结果还真跑不过。 此时已经过一个小时了（我浪费一堆时间什么分都没拿到），心慌了认为是常数原因。 然后花了大概 10 分钟在试图卡过去。 结果当然是失败了。 然后大概剩 45 分钟吧，只能换题看 B 。 由于前面心态崩了这个巨简单的 B 没搞出来。 于是自闭了。 最后 5 分钟想到 C 正解，但是没时间打了。 然后就只过了 A 结束了…… 毕竟是第一次 div 1 ，就当是长见识了。 RATING CHANGE 出了，喜闻乐见地掉回蓝名。（上一场 +53 升紫，这一场 -53 掉蓝……） 还是太慌张了，推不出题目情绪波动太大。 这不行啊。 以后打 CF 要注意 CF 的评测机是垃圾的事实，并且要仔细看数据范围。 Codeforces Round #608Codeforces Round #608 (Div. 2, based on Municipal Stage of All-Russian Competitions for Schools, Saratov) (2019.12.15 17:15) RATING CHANGE: 1869 -&gt; 1777 草掉得比 zz 还低了。（zz 升了一百多，高下立判，，，） 太久不打 div 2 了……遇到不顺的场就挂了。 开局犯傻，倒序开题先开 C 。（事实证明倒序开题必须先开 D 否则比顺开分还少） 然后果然切回去之后分少得一批。 然后看 D 。题意是啥啊没看懂。 感觉是个不好做的东西，于是去看 E 。这个 E ，看起来像是在数位上乱搞？ 大概知道怎么做 E 的时候已经过一小时了，于是开码。 结果码到比赛快结束才过了样例。艰难过 pp 。 然后就回去晚修了。 一节课下课发现 fst 两题 A 和 E ，当场自闭。 看了一下代码， A 是很傻逼的感觉都过不了 pp 的错误。 E 至今不知道哪里挂了。 感觉要掉至少 100 分…… 第二节晚修下课 RATING CHANGE 出来了，结果没掉超过 100 分。 无意间翻到昨天场的草稿纸，上面密密麻麻画满了 B 和 C 的样例。突然就感觉有点感慨。 后来发现 D 题的确被题意杀了。就该看看样例先的。 大失败。 下次打 div 2 一定要注意了，要么顺开要么先做 D ，题意看不懂一定要看样例，样例不给解释的题目建议疯狂对线出题人。 总有一天，我会超回来的。 Educational Codeforces Round 79Educational Codeforces Round 79 (Rated for Div. 2) (2019.12.27 22:40) RATING CHANGE: 1814 -&gt; 1880 总算有一场打得还行的。 nantf 小号升了 506 分（1137 -&gt; 1643）太吓人了…… A 题不认真看题面（没说要成环）直接白交一发…… B 题这种暴贪心的题目又死在细节上了……（然后我不知道当时在想什么连交两发，真实本场最大败笔） 然后 C 和 D 都是简单题完全没啥好说的。 发现手速完全不够快…… nantf 20 min 切前四题 0 wa ，对比我 38 min 4 wa ，高下立判，，， 发现过了前四个题之后没事做了，然后 E 题看起来比 F 可做的样子就使劲肝，结果当然是没肝出来。 果然 Educational 拼的是码速和代码正确率……不过没掉分就随便吧。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2015」我回来了]]></title>
    <url>%2Fblog%2FYnoi2015-%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86%2F</url>
    <content type="text"><![CDATA[这个题主要是当做手写 bitset 板子来写的。 Idea：lxl Solution：lxl Std：lxl Data：lxl 对这题的评价：1/11 大概是 lxl 评价最低的题吧…… [Luogu 5068] 题意简述珂朵莉给你一个无向图，每次查询的时候给一堆二元组 $(x_i,y_i)$ 。 求图中有多少个点 $u$ 与至少一个这次询问给出的二元组 $(x_i,y_i)$ 满足 $dist(u,x_i) \le y_i$ ，其中 $dist(u, v)$ 表示 $u, v$ 这两个点在图中的距离（不连通为 $\inf$），边权全为 $1$ 。 记 $n$ 为点数， $m$ 为边数， $q$ 为询问个数， $cnt$ 为给出二元组的总数。 $1\le n\le 10^3, 1\le m, q\le 10^5, cnt \le 2.1 \times 10^6$ 。 主要思路每个点上记个 bitset $f[i]$ ， $f[i][j]$ 表示距离点 $i$ 不大于 $j$ 的点数。 可以 bfs 处理这些 bitset ，每次查询就是把一堆 bitset 或起来。 时间复杂度 $O(n\times m + \frac{n\times cnt}{\omega})$ ，空间 $O(\frac{n^3}{\omega})$ 。 参考代码把 bitset 的大部分操作都写了一遍。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; Rint ans=0,f=1;reg char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=ans*10+c-'0'; return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 1010, ToT = 16, M = 100010; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;struct my_bitset&#123; unsigned long long a[ToT]; inline void reset()&#123; FOR(i, 0, ToT - 1) a[i] = 0ull; return; &#125; inline void set()&#123; FOR(i, 0, ToT - 1) a[i] = ~0ull; return;&#125; inline my_bitset()&#123; reset(); &#125; inline void filp(int x)&#123; a[x &gt;&gt; 6] ^= (1ull &lt;&lt; (x &amp; 63)); &#125; inline void reset(int x)&#123; a[x &gt;&gt; 6] &amp;= ~(1ull &lt;&lt; (x &amp; 63)); &#125; inline void set(int x)&#123; a[x &gt;&gt; 6] |= (1ull &lt;&lt; (x &amp; 63)); &#125; inline int test(int x)&#123; return (a[x &gt;&gt; 6] &gt;&gt; (x &amp; 63)) &amp; 1; &#125; inline int count()&#123; Rint res = 0; FOR(i, 0, ToT - 1) res += __builtin_popcountll(a[i]); return res; &#125; //----- inline my_bitset operator ~()const &#123; my_bitset res; FOR(i, 0, ToT - 1) res.a[i] = ~a[i]; return res; &#125; inline my_bitset operator |(const my_bitset &amp;B)const &#123; my_bitset res; FOR(i, 0, ToT - 1) res.a[i] = a[i] | B.a[i]; return res; &#125; inline my_bitset operator &amp;(const my_bitset &amp;B)const &#123; my_bitset res; FOR(i, 0, ToT - 1) res.a[i] = a[i] &amp; B.a[i]; return res; &#125; inline my_bitset operator ^(const my_bitset &amp;B)const &#123; my_bitset res; FOR(i, 0, ToT - 1) res.a[i] = a[i] ^ B.a[i]; return res; &#125; inline my_bitset operator &lt;&lt;(const int &amp;t)const &#123; my_bitset res; Rint High = t &gt;&gt; 6, Low = t &amp; 63; unsigned long long Last = 0; FOR(i, 0, ToT - High - 1)&#123; res.a[i + High] = Last | (a[i] &lt;&lt; Low); if(Low) Last = a[i] &gt;&gt; (64 - Low); &#125; return res; &#125; inline my_bitset operator &gt;&gt;(const int &amp;t)const &#123; my_bitset res; Rint High = t &gt;&gt; 6, Low = t &amp; 63; unsigned long long Last = 0; ROF(i, ToT - 1, High)&#123; res.a[i - High] = Last | (a[i] &gt;&gt; Low); if(Low) Last = a[i] &lt;&lt; (64 - Low); &#125; return res; &#125; //----- inline void operator |=(const my_bitset &amp;B)&#123; FOR(i, 0, ToT - 1) a[i] |= B.a[i]; return; &#125; inline void operator &amp;=(const my_bitset &amp;B)&#123; FOR(i, 0, ToT - 1) a[i] &amp;= B.a[i]; return; &#125; inline void operator ^=(const my_bitset &amp;B)&#123; FOR(i, 0, ToT - 1) a[i] ^= B.a[i]; return; &#125; inline void operator &lt;&lt;=(const int &amp;t)&#123; *this = *this &lt;&lt; t; &#125;//懒了…… inline void operator &gt;&gt;=(const int &amp;t)&#123; *this = *this &gt;&gt; t; &#125;&#125;a[N][N], tmp;#define inf (1001)int n, m, q, dis[N], Que[M];vector&lt;int&gt; G[N];inline void bfs(int S)&#123; FOR(i, 1, n) dis[i] = inf; dis[S] = 0; Rint l = 0, r = 1, u, v; Que[0] = S; while(l &lt; r)&#123; u = Que[l++]; FOR(i, 0, int(G[u].size()) - 1)&#123; v = G[u][i]; if(chkmin(dis[v], dis[u] + 1)) Que[r++] = v; &#125; &#125; FOR(i, 1, n) a[S][dis[i]].set(i); FOR(i, 1, n) a[S][i] |= a[S][i - 1];&#125;int main()&#123; n = read(), m = read(), q = read(); Rint u, v, T; FOR(i, 1, m)&#123; u = read(), v = read(); G[u].push_back(v); G[v].push_back(u); &#125; FOR(i, 1, n) bfs(i); while(q--)&#123; T = read(); tmp.reset(); while(T--)&#123; u = read(), v = read(); tmp |= a[u][v]; &#125; printf("%d\n", tmp.count()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Ynoi</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2015」盼君勿忘]]></title>
    <url>%2Fblog%2FYnoi2015-%E7%9B%BC%E5%90%9B%E5%8B%BF%E5%BF%98%2F</url>
    <content type="text"><![CDATA[这个题是刚考挂 CSP 回来写的。 Idea：lxl Solution：lxl Std：lxl Data：lxl 对这题的评价：4/11 [Luogu 5072] 题意简述一个长为 $n$ 的整数序列， $m$ 次查询。每次给出 $l, r, p$ ，查询区间 $[l,r]$ 中所有子序列分别去重（即一个子序列中出现多次的数只留下一个）后的和 $\bmod\ p$ 。 $1\le n, m, a_i\le 10^5, 1\le p\le 10^9$ ，不强制在线。 主要思路一个长度为 $len$ 的询问，如果一个数 $x$ 出现了 $k$ 次，对答案的贡献是 $x(2^{len - k}(2^k - 1))$ 。 $2^{len - k}$ 是除了 $x$ 以外的数的子序列个数， $2^k - 1$ 是所有 $x$ 构成的子序列中包含 $x$ 的种数。 把出现个数为 $i$ 的数的和记为 $s_i$ ，则只需要维护 $s$ 即可。 肯定是离线下来莫队，但是模数不同不好求答案。 发现出现个数大于 $\sqrt{n}$ 的数的个数不会超过 $\sqrt{n}$ ，所以将出现次数大于 $\sqrt{n}$ 的数用一个东西来维护，复杂度就是单次 $O(\sqrt{n})$ 的了。 然后快速幂要用那种 $O(\sqrt{n})$ 预处理 $O(1)$ 求幂次的方法（就是处理 $2^0, 2^1, 2^2, \dots, 2^{\sqrt{n}}$ 和 $2^{\sqrt{n}}, 2^{2\sqrt{n}}, \dots, 2^{n}$ ）。 出现次数大于 $\sqrt{n}$ 的数可以用哈希表来维护。 unordered_set 居然没被卡。 于是就时间复杂度 $O((n + m)\sqrt{n})$ ，空间复杂度 $O(n)$ 了。 参考代码然后不知道为什么跑得巨慢，花了 std 的两倍时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125;// #define using_mod const int N = 100010, BN = 330; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;const int blo = 317;int n, m, a[N], ans[N], bl[N], cnt[N];struct Query&#123; int l, r, mod, id; inline int operator &lt;(const Query &amp;t)const&#123; return bl[l] == bl[t.l] ? (bl[l] &amp; 1 ? r &lt; t.r : r &gt; t.r) : l &lt; t.l ; &#125;&#125;Que[N];LL sum[BN];unordered_set&lt;LL&gt;s;int p_2[BN], pb2[N];inline int ksm2(const int &amp;x, const int &amp;mod)&#123; return 1ll * p_2[x % blo] * pb2[x / blo] % mod; &#125;inline void inc(int &amp;x, const int &amp;y, const int &amp;mod)&#123; x += y; if(x &gt;= mod) x -= mod; &#125;inline void Query(int id)&#123; const int mod = Que[id].mod; Rint l = Que[id].l, r = Que[id].r, res = 0, len = r - l + 1; FOR(i, 1, blo) p_2[i] = 2ll * p_2[i - 1] % mod; pb2[1] = p_2[blo]; Rint tmp = pb2[1]; FOR(i, 2, blo) pb2[i] = 1ll * tmp * pb2[i - 1] % mod; tmp = ksm2(len, mod); FOR(j, 1, blo) inc(res, sum[j] * (tmp - ksm2(len - j, mod) + mod) % mod, mod); for(int t : s) inc(res, 1ll * t * (tmp - ksm2(len - cnt[t], mod) + mod) % mod, mod); ans[Que[id].id] = res;&#125;inline void update_add(int x)&#123; if(cnt[x] &gt; blo) cnt[x]++; else&#123; sum[cnt[x]++] -= x; if(cnt[x] &gt; blo) s.insert(x); else sum[cnt[x]] += x; &#125;&#125;inline void update_del(int x)&#123; if(cnt[x] &gt; blo + 1) cnt[x]--; else&#123; if(cnt[x] &gt; blo) s.erase(x), sum[--cnt[x]] += x; else sum[cnt[x]--] -= x, sum[cnt[x]] += x; &#125;&#125;int main()&#123; n = read(), m = read();// blo = ceil(sqrt(n)); p_2[0] = pb2[0] = 1; Rint cb = 1; FOR(i, 1, n)&#123; a[i] = read(); bl[i] = (i % blo) ? cb : cb++; &#125; FOR(i, 1, m) Que[i].id = i, Que[i].l = read(), Que[i].r = read(), Que[i].mod = read(); Rint l = 1, r = 0; sort(Que + 1, Que + m + 1); FOR(i, 1, m)&#123; while(r &lt; Que[i].r) update_add(a[++r]); while(l &gt; Que[i].l) update_add(a[--l]); while(r &gt; Que[i].r) update_del(a[r--]); while(l &lt; Que[i].l) update_del(a[l++]); Query(i); &#125; FOR(i, 1, n) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2015」纵使日薄西山]]></title>
    <url>%2Fblog%2FYnoi2015-%E7%BA%B5%E4%BD%BF%E6%97%A5%E8%96%84%E8%A5%BF%E5%B1%B1%2F</url>
    <content type="text"><![CDATA[感觉失去卡常的兴致了……，虽然这个题明明不卡常。 Idea：ccz Solution：ccz Std：ccz Data：ccz 对这题的评价：3/11 [Luogu 5069] 题意简述维护一个长度为 $n$ 的正整数序列 $a$ ， $m$ 次修改序列中某个位置的值。 每次修改后问对序列重复进行以下操作，需要进行几次操作才能使序列变为全 $0$ （询问后序列和询问前相同，不会变为全 $0$ ）： 选出序列中最大值的出现位置，若有多个最大值则选位置标号最小的一个，设位置为 $x$ ，则将 $a{x-1},a_x,a_{x+1}$ 的值减 $1$ ，如果序列中存在小于 $0$ 的数，则把对应的数改为 $0$ 。 $1\le n, m\le 10^5, 1\le a_i \le 10^9$ 。 主要思路如果一个位置 $x$ 是极大值（即 $a_{x-1} &lt; a_x, a_x \ge a_{x + 1}$ ），显然位置 $x - 1$ 和位置 $x + 1$ 不会成为最大值，且位置 $x$ 会成为最大值 $a_x$ 次。而操作过位置 $x$ 后，可能会出现新的极大值。 分析找极大值的过程，发现是从初始每个极大值开始向两侧隔一个位置取一个位置，直到到达极小值或边界为止。一个极小值仅当到两侧第一个极大值的距离均为偶数时才成为极大值。 所以对奇数位置和偶数位置分别开一棵树状数组维护一下，然后用一棵平衡树记录序列的极大值和极小值位置。这样就能够快速计算两个极值之间的区间的贡献。 对于单点修改，只会影响两侧最多分别两个区间，重新计算贡献即可。 时间复杂度 $O(n\log_2{n})$ 。 参考代码写得好的话细节其实不多。 开始想要把两个极值之间的答案记在前一个极值上，然后发现很难写…… 于是把极大值到两侧极小值这两段区间的答案记在极大值上，极小值上只记录自己有没有贡献。 然后由于要访问前两个和后两个极值，所以开始先插入一些初值即可减少讨论。 总之想好了再码还是比较容易的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#pragma GCC optimize("Ofast")#pragma GCC optimize("unroll-loops")#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 100010; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;typedef set&lt;int&gt;::iterator iter;set&lt;int&gt; s;int n, m, a[N];LL ans;struct BIT&#123;//树状数组 LL a[N]; inline void update(int x, LL v)&#123; if(x) for(; x &lt;= n; x += x &amp; (-x)) a[x] += v; &#125; inline LL query(int x)&#123; if(x &lt;= 0) return 0; if(x &gt; n) x = n; reg LL res = 0; for(; x; x -= x &amp; (-x)) res += a[x]; return res; &#125; inline LL query(int l, int r)&#123; return l &lt;= r ? query(r) - query(l - 1) : 0; &#125;&#125;BT[2];inline LL get_num(iter it)&#123;//求贡献直接传迭代器进来 Rint x = *it; if(x &lt;= 0 || x &gt; n) return 0; Rint opt = a[x - 1] &lt; a[x] &amp;&amp; a[x] &gt;= a[x + 1]; reg iter nxt = it, pre = it; ++nxt, --pre; if(opt)&#123; return BT[x &amp; 1].query(*pre + 1, *nxt - 1); &#125; else&#123; return (x - *pre + 1) &amp; 1 &amp;&amp; (*nxt - x + 1) &amp; 1 ? a[x] : 0; &#125;&#125;inline void build()&#123; s.insert(-1), s.insert(n + 2); s.insert(-1145141919), s.insert(1145141919); s.insert(1), s.insert(n); FOR(i, 2, n - 1) if(!((a[i - 1] &lt; a[i]) ^ (a[i] &gt;= a[i + 1]))) s.insert(i); for(reg iter it = s.begin(); it != s.end(); ++it) ans += get_num(it); return;&#125;inline void update(int x, int y)&#123; reg iter nxt = s.upper_bound(x), pre = --s.lower_bound(x); ans -= get_num(nxt), ans -= get_num(pre); reg iter nnxt = nxt, ppre = pre; ++nnxt, --ppre; ans -= get_num(nnxt), ans -= get_num(ppre); if(*next(pre) == x) ans -= get_num(next(pre)); BT[x &amp; 1].update(x, y - a[x]); a[x] = y; FOR(i, x - 1, x + 1)&#123; if(i &lt;= 1 || i &gt;= n) continue;//边界也不需要从 set 里面取出来 if(!((a[i - 1] &lt; a[i]) ^ (a[i] &gt;= a[i + 1]))) s.insert(i); else s.erase(i); &#125; ++nnxt; for(reg iter it = ppre; it != nnxt; ++it)&#123; ans += get_num(it); &#125; return;&#125;int main()&#123; n = read(); FOR(i, 1, n) BT[i &amp; 1].update(i, a[i] = read()); build(); m = read(); Rint x, y; FOR(o, 1, m)&#123; x = read(), y = read(); update(x, y); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>log数据结构</tag>
        <tag>Ynoi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于日常使用字体]]></title>
    <url>%2Fblog%2F%E5%85%B3%E4%BA%8E%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[出于某些原因，在学校使用的电脑换了一台。 然后由于实在忍受不了 cmd 界面丑陋的字体，所以就折腾了一会。 下列操作均在 Windows 7 系统中进行。 字体的安装什么 build 不会啊，反正是 Windows ，直接把 ttf 文件下下来选中右键安装完事。 推荐平时使用 Sarasa Gothic（更纱黑体），代码 Hack 或 Fira Code。 目前计算机中安装的字体可以在在 C:\Windows\Fonts 查看。 Fira Code 还有一些特性，详见后文。 更改 cmd 字体Win + R， regedit 进入注册表。 再进入[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Console\TrueTypeFont]中。 代码页936：默认简中字体 代码页950：默认繁中字体 代码页932：默认日文字体 代码页949：默认韩文字体 代码页437：其他（不属于上面的所有项都属于这个代码页） 添加一项 0936 ，输入需要的字体即可。 然后打开 cmd ，右键标题栏的 属性(P) ，更改字体即可。 参考kangflict的博客。 更改 Dev C++ 字体虽然我本人是不喜欢 Dev C++ ……但是总还是得用。 工具[T]&gt;编译器选项[E]&gt;显示。 更改 VS Code 字体打开 UI 界面的设置。 顺便附上目前使用的 settings.json 。 12345678910111213141516&#123; "git.ignoreMissingGitWarning": true, "C_Cpp.intelliSenseEngineFallback": "Enabled", "atomKeymap.promptV3Features": true, "editor.multiCursorModifier": "ctrlCmd", "editor.formatOnPaste": true, "window.zoomLevel": 0, "editor.cursorBlinking": "phase", "editor.cursorStyle": "line-thin", "C_Cpp.updateChannel": "Insiders", "files.associations": &#123; "*.json": "jsonc" &#125;, "editor.fontFamily": "'Fira Code', 'Sarasa Term SC'", "editor.fontLigatures": "false"&#125; 更改 Hexo 博客字体（NexT 主题）打开主题目录下的 _config.yml 。 然后就是 font: 那一段。 发现原本的 Lato 字体不是很难看，所以就只将代码字体改为了 Hack 。 Fira Code 特性 大概就是在支持连字属性的地方会将各种连着的符号渲染成左图这个样子…… SublimeText, Xcode, Notepad++, Eclipse 等编辑器都不支持连字。 然而 VS Code 支持，只要在 settings.json 里加上一行： 1&quot;editor.fontLigatures&quot;: &quot;true&quot; 但是本人觉得这样搞反而会降低代码可读性，所以便作罢。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1172D」Nauuo and Portals]]></title>
    <url>%2Fblog%2FCF1172D%2F</url>
    <content type="text"><![CDATA[ouuan 场的有意思构造题。 [CF 1172D] 题意简述定义一对传送门 $(A,A^\prime)$ 为从 $A$ 门进入会从 $A^\prime$ 门出来，且保持进入 $A$ 门的方向（从 $A^\prime$ 进去同理）。 给出一个 $n\times n$ ($1\le n\le 10^3$) 的矩形和 $2n$ 个要求，其中前 $n$ 个要求的形式为 $(r_i,n)$ ，代表 $\texttt{Nauuo}$ 从 $(i,1)$ 这个格子出发一直向右走，经过若干对传送门（或者不经过传送门）后从 $(r_i,n)$ 这个格子走出矩形；后 $n$ 个要求的形式为 $(n,c_i)$ ，代表 $\texttt{Nauuo}$ 从 $(1,i)$ 这个格子出发一直向下走，经过若干对传送门（或者不经过传送门）后从 $(n,c_i)$ 这个格子走出矩形。 请你在这个 $n\times n$ 的矩形中放置若干对传送门，使得这 $2n$ 个请求可以同时满足。输出传送门的对数和每对传送门两个门各自的坐标。 保证 $r_i, c_i$ 为 $1$ 到 $n$ 的排列。无解时输出 $-1$ 。 注意：你不需要找到使用传送门最少的方案数，只需要让你给出的方案可以满足题目中给出的要求。 主要思路考虑 $n\times n$ 的问题如何转换成 $(n - 1)\times (n - 1)$ 。 假设从第 $i$ 行进的人要从第 $r_i$ 行出去，第 $i$ 行出去的人要是从第 $idr_i$ 行进的人。 假设从第 $i$ 列进的人要从第 $c_i$ 列出去，第 $i$ 列出去的人要是从第 $idc_i$ 列进的人。 考虑满足第 $i$ 行出去的人和第 $i$ 列出去的人。 我们可以在 $(i, idc_i), (idr_i, i)$ 的位置放置一对传送门（如果 $idc_i$ , $idr_i$ 不都为 $i$ ），并且之后不再在第 $i$ 行或第 $i$ 列放置传送门。 此时，满足了第 $idr_i$ 行进的人与第 $idc_i$ 列进的人。并且第 $i$ 行进的人一定会到达 $(idr_i, i)$ ，第 $i$ 列进的人一定会到达 $(i, idc_i)$ 。 然后更改 $idr_{r_i},r_{idr_i},idc_{c_i},c_{idc_i}$ ，继续做下一行即可。时间复杂度 $O(n)$ 。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; reg int ans=0,f=1; reg char c=getchar(); while(!isdigit(c)) f^=(c=='-'), c=getchar(); for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 1010; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;int n, r[N], c[N], idr[N], idc[N];vector&lt;pair&lt;PII, PII&gt; &gt; ans;int main()&#123; n = read(); FOR(i, 1, n) idr[r[i] = read()] = i; FOR(i, 1, n) idc[c[i] = read()] = i; FOR(i, 1, n)&#123; if(idr[i] == i &amp;&amp; idc[i] == i) continue; ans.push_back(MP(MP(i, idc[i]), MP(idr[i], i))); r[idr[i]] = r[i], idr[r[i]] = idr[i]; idr[i] = i, r[i] = i; c[idc[i]] = c[i], idc[c[i]] = idc[i]; idc[i] = i, c[i] = i; &#125; printf("%d\n", (int)ans.size()); for(auto &amp;i : ans)&#123; printf("%d %d %d %d\n", i.fir.fir, i.fir.sec, i.sec.fir, i.sec.sec); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2018」天降之物]]></title>
    <url>%2Fblog%2FYnoi2018-%E5%A4%A9%E9%99%8D%E4%B9%8B%E7%89%A9%2F</url>
    <content type="text"><![CDATA[第二道 Ynoi2018 。 Idea：lxl Solution：lxl Std：lxl Data：lxl “弑尽破净的第四分块” （妈呀这名字好中二啊（谁叫我要用日本轻小说中的东西命名真是作死）） 这题就是我想改一个已有的经典根号形式改出来，然后想了想发现可以做 考虑根号分治 存在序列分块做法 对这题的评价：6/11 [Luogu 5397] [51nod 2046] 题意简述维护一个长 $n$ 的整数序列 $a$ ， $m$ 个操作，可能是以下两种： 给出 $x,y$ 两个正整数，将序列中所有值为 $x$ 的数变为 $y$ ； 给出 $x,y$ 两个正整数，查询序列中对于所有 $i,j$ 满足 $a_i=x, a_j=y$ ， $|i-j|$ 的最小值，无解输出Ikaros。 强制在线， $1\le n,m\le 10^5,0\le a_i,x,y\le 10^5$ 。 主要思路看到所有操作都只涉及整个序列就感觉应该不是序列分块。 所以考虑根号分治。 设 $x$ 在序列中的个数为 $siz[x]$ 。 称满足 $siz[x] \ge \sqrt{n}$ 的数 $x$ 为大的，否则为小的。 无修做法把每个数 $i$ 出现的位置按顺序丢到一个数组 $V[i]$ 里。 再预处理每个大的数到所有其他值的答案，显然可以每个大的数 $O(n)$ ，预处理复杂度 $O(n\sqrt{n})$ 。 查询的时候如果 $x$ 与 $y$ 均为小，则可以使用类似归并的方法， $O(\sqrt{n})$ 查询排序后的位置数组得到答案；否则直接 $O(1)$ 取出预处理的答案即可。 所以时间复杂度为 $O(n\sqrt{n} + m\sqrt{n})$ 。 带修做法假设将所有 $x$ 变为 $y$ 。 由于可以通过一些技巧，使得 $x$ 变为 $y$ 等价于 $y$ 变为 $x$ ，所以不妨先设 $siz[x] \le siz[y]$ 。 假设我们一开始预处理的大的数 $B$ 到任意数 $i$ 的答案为 $ans[B][i]$ 。 如果 $x$ 与 $y$ 均为大，我们可以直接 $O(n)$ 重构 $y$ 到每个数 $i$ 的答案 $ans[y][i]$ 。由于需要满足 $x,y$ 均为大，故这样的重构不会超过 $\sqrt{n}$ 次，总复杂度 $O(n\sqrt{n})$ 。 如果 $x$ 与 $y$ 均为小，并且合并后也为小，我们只需要对于每个大数 $B$ ，使用 $ans[B][x]$ 更新 $ans[B][y]$ ，并将 $ans[B][x]$ 设为 $\inf$ 即可。这样单次复杂度为大数个数，即 $O(\sqrt{n})$ 。若 $x$ 与 $y$ 合并后为大，那么直接如上方 $O(n)$ 重构。易得这样的重构也不会超过 $\sqrt{n}$ 次，所以总复杂度 $O(n\sqrt{n})$ 。 然而 $x$ 为小， $y$ 为大时，仅使用 $ans$ 数组来记录答案不可行。若直接 $O(n)$ 重构，总复杂度上升到 $O(n^2)$ ；若只更新每个大数 $B$ 到 $y$ 的答案 $ans[B][y]$ ，正确性出现问题。 假设将 $x_1, x_2$ （小）分别变为 $y_1, y_2$ （大）。则 $ans[y_1][y_2]$ 记录的是原本的 $y_1$ 到原本的 $y_2, x_2$ 的答案的最小值， $ans[y_2][y_1]$ 记录的是原本的 $y_2$ 到原本的 $y_1, x_1$ 的答案的最小值。若现在 $y_1, y_2$ 的答案实际在原本的 $x_1, x_2$ 之间取得，则无法被更新到。故直接更新正确性错误。 我们对每个大的数 $B$ 都开一个附属集合，表示目前序列的哪些位置原本不是 $B$ 但现在变成了 $B$ ，这些位置就应该是在上方讨论过，未被完全更新的位置。将这些位置按顺序放入数组 $V^\prime[B]$ 中，$|V^\prime[B]|$ 记为 $psz[B]$。 对于 $x$ 为小， $y$ 为大时的修改，仍然对每个大数 $B$ 更新 $ans[B][y]$ ，并将所有 $x$ 出现的位置按顺序加入 $V^\prime[y]$ 中。此时一次的时间复杂度为 $O(\sqrt{n} + psz[y])$ 。故若 $V^\prime[y]$ 在加入 $x$ 的位置后， $psz[y]$ 大小已经比 $\sqrt{n}$ 大，需要像 $x$ 与 $y$ 均为大时一样，直接 $O(n)$ 重构 $ans[y][i]$ 。由于这样的重构次数也不会超过 $\sqrt{n}$ 次，总复杂度也是 $O(n\sqrt{n})$ 。 如上述修改，总复杂度即为 $O(n\sqrt{n} + m\sqrt{n})$ 。 接下来假设查询 $x$ 与 $y$ ，先钦定 $siz[x] \le siz[y]$ 。 如果 $x$ 与 $y$ 均为小，可以通过无修时类似归并的方法， $O(\sqrt{n})$ 做。 如果 $x$ 与 $y$ 均为大，先 $\min(ans[y][x], ans[x][y])$ 得到一个答案，再将两数的附属集合像上面的方法一样归并做，两个答案的最小值就是真正的答案，复杂度也为 $O(\sqrt{n})$ 。 如果 $x$ 为小， $y$ 为大，将 $V[x]$ 和 $V^\prime[y]$ 归并做，再与 $ans[y][x]$ 取最小值即为答案，复杂度仍为 $O(\sqrt{n})$ 。 所以总时间复杂度 $O((n + m)\sqrt{n})$ ，空间复杂度 $O(n\sqrt{n})$ 。 参考代码然而怎么实现？ 由于需要支持在修改中交换 $x, y$ ，需要一个数组 $rn[i]$ 来表示数 $i$ 现在在序列中的真实值。 发现当数 $i$ 为大的时候，存 $V[i]$ 没有用，直接把 $V^\prime[i]$ 存到 $V[i]$ 上去，这样合并两个集合或者附属集合就好写多了。 大数肯定要编个号，注意垃圾回收。然后就是注意 $siz$ 和 $psz$ 的修改不要漏了。 实验证明大数的判定标准定到 $500$ 时跑得最快。加了三行指令集之后，跑到了最优解，纪念一下。 更多细节见代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#pragma GCC optimize("Ofast")#pragma GCC optimize("unroll-loops")#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 100010, MX = 100000, BN = 500, BM = 210; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;inline int my_max(Rint a, Rint b)&#123; return (a &gt; b) ? a : b; &#125;inline int my_min(Rint a, Rint b)&#123; return (a &lt; b) ? a : b; &#125;#define max(a,b) my_max(a,b)#define min(a,b) my_min(a,b)//inline int abs(Rint x)&#123; return x &lt; 0 ? -x : x; &#125;//#define abs(x) ((x) &lt; 0 ? -(x) : (x))#define swap(a,b) (a ^= b ^= a ^= b)#define inf (114514)//手写各种东西vector&lt;int&gt; v[N];int n, m, bgn, a[N], siz[N], psz[N], rn[N], bnd[N];//siz[x] : 数 x 在序列中的个数; psz[x] : 数 x 附属集合大小; rn[x] : 数 x 实际上是什么数//bgn : 目前最大大数序号; bnd[x] : 数 x 对应的大数序号 int ans[BM][N];int del[N], dt;const int blo = BN;inline int new_big_num()&#123; return dt ? del[dt--] : ++bgn;&#125;inline void init_big_num(Rint x)&#123;//O(n) 预处理 ans[bnd[x]]][i] Rint id = bnd[x], now = inf; FOR(i, 1, MX) ans[id][i] = inf; FOR(i, 1, n)&#123; if(a[i] == x) now = 0; else chkmin(ans[id][a[i]], ++now); &#125; now = inf; ROF(i, n, 1)&#123; if(a[i] == x) now = 0; else chkmin(ans[id][a[i]], ++now); &#125;&#125;inline void build_big_num(Rint x)&#123;//建新大数 bnd[x] = new_big_num(); init_big_num(x), ans[bnd[x]][x] = 0;&#125;inline void rebuild_big_num(Rint x, Rint y)&#123;//将 x 合并到大数 y 并重构 if(bnd[x]) del[++dt] = bnd[x]; FOR(i, 1, n) if(a[i] == x) a[i] = y; psz[y] = 0; init_big_num(y);&#125;inline void merge(Rint x, Rint y)&#123;//将 x 的集合合并到 y 的集合中 Rint sx = siz[x], sy = siz[y] &lt; blo ? siz[y] : psz[y], ss = sx + sy; vector&lt;int&gt; tmp = v[y]; v[y].resize(ss + 10); while(sx &amp;&amp; sy) v[y][ss--] = ((v[x][sx] &gt; tmp[sy]) ? v[x][sx--] : tmp[sy--]); while(sx) v[y][ss--] = v[x][sx--]; while(sy) v[y][ss--] = tmp[sy--]; FOR(i, 1, bgn) chkmin(ans[i][y], ans[i][x]); FOR(i, 1, siz[x]) a[v[x][i]] = y; return;&#125;inline int merge_num(Rint x, Rint y)&#123;//求两个集合间的答案 Rint sx = siz[x] &lt; blo ? siz[x] : psz[x], sy = siz[y] &lt; blo ? siz[y] : psz[y], res = inf; if(!sx || !sy) return inf; while(sx &amp;&amp; sy) chkmin(res, (v[x][sx] &gt; v[y][sy]) ? v[x][sx--] - v[y][sy] : v[y][sy--] - v[x][sx]); //这两行不需要是因为通过这两行得出的答案一定不会比上一行得出的答案更优// ROF(i, sx, 1) chkmin(res, v[y][1] - v[x][i]);// ROF(i, sy, 1) chkmin(res, v[x][1] - v[y][i]); return res;&#125;inline void update(Rint xx, Rint yy)&#123; Rint x = rn[xx], y = rn[yy]; if(x == y || !siz[x]) return; if(siz[x] &gt; siz[y]) swap(x, y), swap(xx, yy), rn[yy] = 0, rn[xx] = y;//保证 siz[x] &lt;= siz[y] else rn[xx] = 0; if(!x || !y) return;//没有直接跳了 //siz[x] &lt;= siz[y] &lt; blo if(siz[y] &lt; blo)&#123; if(siz[x] + siz[y] &lt; blo)&#123; merge(x, y); siz[y] += siz[x], siz[x] = 0; &#125; else&#123;//变大重构 bnd[y] = new_big_num(); FOR(i, 1, siz[x]) a[v[x][i]] = y; init_big_num(y); siz[y] += siz[x], siz[x] = 0; &#125; return; &#125; //siz[x] &lt; blo &lt;= siz[y] if(siz[x] &lt; blo)&#123; if(psz[y] + siz[x] &lt; blo)&#123; merge(x, y); psz[y] += siz[x], siz[y] += siz[x], siz[x] = 0; &#125; else&#123;//psz[y] 过大重构 psz[y] += siz[x], siz[y] += siz[x], siz[x] = 0; rebuild_big_num(x, y); &#125; return; &#125; //blo &lt;= siz[x] &lt;= siz[y] siz[y] += siz[x], siz[x] = 0; rebuild_big_num(x, y);//直接重构&#125;inline int query(Rint xx, Rint yy)&#123; Rint x = rn[xx], y = rn[yy]; if(x == y) return siz[x] ? 0 : -1; if(!siz[x] || !siz[y]) return -1;//判掉无解情况 if(siz[x] &gt; siz[y]) swap(x, y), swap(xx, yy); //siz[x] &lt;= siz[y] &lt; blo if(siz[y] &lt; blo) return merge_num(x, y); //siz[x] &lt; blo &lt;= siz[y] if(siz[x] &lt; blo) return min(ans[bnd[y]][x], merge_num(x, y)); //blo &lt;= siz[x] &lt;= siz[y] return min(min(ans[bnd[y]][x], ans[bnd[x]][y]), merge_num(x, y));&#125;int main()&#123; n = read(), m = read(); FOR(i, 1, n) ++siz[a[i] = read()], rn[i] = i; FOR(i, 1, MX)&#123; if(siz[i] &gt;= blo) build_big_num(i), v[i].resize(10); else v[i].resize(siz[i] + 10), siz[i] = 0; &#125; FORit(int, a, i, 1, n)&#123; if(siz[*i] &lt; blo) v[*i][++siz[*i]] = i - a; &#125; Rint lastans = 0, opt, x, y; while(m --)&#123; opt = read(), x = read() ^ lastans, y = read() ^ lastans;// opt = read(), x = read(), y = read(); if(opt == 1) update(x, y); else&#123; lastans = query(x, y); if(lastans == -1) puts("Ikaros"), lastans = 0; else printf("%d\n", lastans); &#125; &#125; return 0;&#125; 对比一下自己写「Ynoi2018」未来日记时的码风发现变化有点大…… 参考资料lxl 原博客 foreverlasting 的博客]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Ynoi</tag>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Musescore初体验]]></title>
    <url>%2Fblog%2FMusescore%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[边打 Codeforces 边下《恋×シンアイ彼女》， System Test 结束之后才下了一半不到。 于是觉得好无聊啊，就去找我的 Sibelius 7 破解版。结果发现挂了，各种意义上的。 折腾了一会之后修好了，但是本来我就不大会用 Sibelius ，加上它很卡，于是就弃了。 想到还有一个免费制谱软件 Musescore ，并且有汉化版。 于是赶紧到官网下了一个来折腾。 然后发现这比以前用过的 Overture 好太多了，以后就用 Musescore 吧。 结果下完好久之后才折腾完。 抄写了まんどぉ 採譜空間的 喫茶ステラと死神の蝶 OP -「Smiling-Swinging!!」，作为使用 Musescore 的练习。 mscz, pdf, mp3, mid. 原谱面： 原 OP 动画。 操作用户手册。 基本操作首先先创建空乐谱。 然后，大概就会有教程手把手教你基本操作了。 而且这个……大部分都可以摸索出来吧……于是这篇文章只讲一些比较重要的东西。 所以也有需要时才更新吧。 输入音符官网教程 快捷键N可以快速进入或退出音符输入模式。 快捷键1~9分别对应选择时值为六十四分音符到四全音符。 快捷键.为选择附点，0为选择对应休止符。 这个多声部功能居然是可以删掉除第一声部以外其他声部的休止符的，好评。 连音符可以Ctrl + 2 ~ 9来添加 2 ~ 9 连音。 大于 9 个音符的连音可以使用上方的添加 &gt; 连音符 &gt; 其他…。 速度打开那个符号面板中速度那一栏。选择一个音符（休止符）然后双击你需要的速度即可。可以移动位置，也可以双击修改。 Swing摇摆节拍的使用方法。官网讲得蛮详细了。 右键出谱表文字属性之后的界面： 图片可以复制到占位框里然后使劲移动，做到图中的效果。 线性记号记得先选中一段区间再双击需要的记号。 这个东西也可以拖动。 奏法记号Ctrl + ↑↓居然可以上下移动奏法记号。不过也可以拿鼠标拖动就是了。 倚音这倚音也很不错啊。 有前后两种，如果想要一个位置多个倚音的话可以使用添加音程的方式向倚音添加音程。 不过因为有缩小音符音头这个东西在，好像只要是不带斜杠的倚音都不用倚音做出同样的效果哎。 琶音与滑音没啥大问题，然而这个刮奏为啥在音符距离比较小的时候就变了样子啊…… 谱表与分谱属性 所以怎么调整整个谱表的高度啊……]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫老师带你从高考走向一试]]></title>
    <url>%2Fblog%2F%E8%8E%AB%E8%80%81%E5%B8%88%E5%B8%A6%E4%BD%A0%E4%BB%8E%E9%AB%98%E8%80%83%E8%B5%B0%E5%90%91%E4%B8%80%E8%AF%95%2F</url>
    <content type="text"><![CDATA[两位数竞大佬 mzc 与 cp 心血来潮出了一份难度据说是高考衔接一试难度的小测卷，并由苦工 zsd 验题。 两大看点： 看本人因好久没有认真做过数学题被其他神仙暴踩； 试卷不用 $\LaTeX$ 格式爆炸，各种出锅，骂出题人。 一些题目T1在锐角 $\triangle{ABC}$ 中， $\sin{A} + \sin{B} + \sin{C} + \tan{A} + \tan{B} + \tan{C}$ ____ $\pi$ 。（） A. $&lt;$ B. $&gt;$ C. $\ge$ D. $=$ solution: 然而这题最快方法或许是代正三角形？ 大家都知道当 $x\in(0, \frac{\pi}{2})$ 有 $\sin{x} &lt; x &lt; \tan{x}$ 。 什么？要用万能公式？不存在的。 T2已知奇函数 $f(x)$ 在 $[-1, 0]$ 上为单调递减函数， $\alpha, \beta$ 为某锐角三角形的两个内角，则____。（） A. $f(\cos{\alpha}) &gt; f(\cos{\beta})$ B. $f(\sin{\alpha}) &lt; f(\cos{\beta})$ C. $f(\sin{\alpha}) &gt; f(\sin{\beta})$ D. $f(\sin{\alpha}) &gt; f(\sin{\beta})$ solution: $\because \alpha + \beta &gt; \frac{\pi}{2}$ $\therefore 0 &lt; \frac{\pi}{2} - \beta &lt; \alpha\qquad\therefore \sin{(\frac{\pi}{2} - \beta)} &lt; \sin{\alpha}$ $\therefore f(\sin{\alpha}) &lt; f(\cos{\beta})$ T3若实数 $a, b$ 满足不等式 $\begin{cases}a + b - 2 \ge 0 \\ b - a - 1 \le 0 \\ a \le 1 \end{cases}$ ，则 $\frac{a + 2b}{2a + b}$ 的最大值为____。（） A. $\frac{8}{5}$ B. $\frac{7}{5}$ C. $\frac{6}{5}$ D. $1$ solution: 直接线性规划就完事了。 T9函数 $f(a, b) = (a - b)^2 + (\sqrt{2 - a^2} - \frac{9}{b})^2$ 的最小值为____。 solution: 这东西就是两点 $C,D$ ，其中 $x_C^2 + y_C^2 = 2, y_C \ge 0, x_D\cdot y_D = 9$ ，然后求这两点距离的最小值。 然后场上居然没做出来。 T12设 $\triangle{ABC}$ 中 $BC$ 边上的高为 $h$ ，且 $h = \frac{\sqrt{3}a}{3}$ ，则 $\frac{c}{b} + \frac{b}{c} + \frac{a^2}{bc}$ 的最大值为____。 solution: 设 $L=\frac{c}{b} + \frac{b}{c} + \frac{a^2}{bc}=\frac{c^2+b^2+a^2}{bc} = 2\cos{A} + \frac{2a^2}{bc}$ $\because 2S = ah = \frac{\sqrt{3}}{3} a^2 = bc\sin{A}$ $\therefore L = 2\cos{A} + 2\sqrt{3}\sin{A} = 4\sin(A + \frac{\pi}{6}) \le 4$ 又当 $A = \frac{\pi}{3}, B = \frac{\pi}{2}, C = \frac{\pi}{6}$ 时， $L = 4$ $\therefore L_{\max} = 4$ T13请用一个式子表示数列 $1, 2, 3, 1, 2, 3, \dots$ 的通项公式（下标从 $1$ 开始）。 solution: $a_n = (n - 1) % 3 + 1$ 好，结果你要求只用初等方法，还不告诉我初等方法是什么 上单位根。 $[x|n] = \frac{1}{x}\sum\limits_{r = 0}^{x - 1} \omega_x^{r\cdot n}$ $n \% x = \sum\limits_{t = 1}^{x - 1}t \cdot [x | (n - t)] = \sum\limits_{t = 1}^{x - 1}\frac{t}{x}\sum\limits_{r = 0}^{x - 1} \omega_x^{r\cdot (n-t)}$ 直接代进去就能得到一个很丑的式子。 然后稍微好看点的式子是 $a_n = 1 + \omega_3^n + \omega_3^{n + 1} + \omega_3^{2n} + \omega_3^{2n + 2}$ 。 结果你还要求不准用虚数…… $\cos{\frac{2n\pi}{3} = \begin{cases} 1, 3|n\\ -\frac{1}{2}, \text{others} \end{cases}}$ 好，配一下就好了。 T17在 $\triangle{ABC}$ 中， $M$ 为 $BC$ 中点，有一条直线穿过线段 $AB,AC$ 与 $AB,AC,AM$ 分别交于点 $P,Q,N$ 。求证 $\frac{AB}{AP},\frac{AM}{AN},\frac{AC}{AQ}$ 成等差数列。 solution: 设 $\frac{AB}{AP} = \alpha,\frac{AM}{AN} = \gamma,\frac{AC}{AQ} = \beta$ 。 则要证明 $\alpha + \beta = 2\gamma$ 。 $\because M$ 为 $BC$ 中点 $\qquad\therefore \overrightarrow{AB} + \overrightarrow{AC} = 2\overrightarrow{AM}$ 即 $\alpha\overrightarrow{AP} + \beta\overrightarrow{AQ} = 2\gamma\overrightarrow{AN}\qquad$ 即 $\frac{\alpha}{2\gamma}\overrightarrow{AP} + \frac{\beta}{2\gamma}\overrightarrow{AQ} = \overrightarrow{AN}$ $\because P,Q,N$ 三点共线 $\qquad\therefore \frac{\alpha}{2\gamma} + \frac{\beta}{2\gamma} = 1$ $\therefore \alpha + \beta = 2\gamma$ T18设 $a,b,c\in \mathbf{R}_+, abc = 1$ 。求证 $L = (a - 1 + \frac{1}{b})(b - 1 + \frac{1}{c})(c - 1 + \frac{1}{a}) \le 1$ 。 solution: 设 $a = \frac{x}{y}, b = \frac{y}{z},c = \frac{z}{x}, x,y,z\in \mathbf{R}_+$ 。 则 $L = (\frac{x - y + z}{y})(\frac{x + y - z}{z})(\frac{-x + y + z}{x})$ 设 $p = x + y - z, q = x + y - z, p = x + y - z$ ，则 $x = \frac{p + q}{2}, y = \frac{p + r}{2}, z = \frac{q + r}{2}$ 。 $\because pqr = \sqrt{pq}\cdot\sqrt{qr}\cdot\sqrt{rp} \le \frac{p + q}{2}\cdot\frac{p + r}{2}\cdot\frac{q + r}{2} = xyz$ $\therefore L = \frac{pqr}{xyz} \le 1$ T20用牟合方盖证明球的体积公式。 solution: 咕了。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF1261E」Not same]]></title>
    <url>%2Fblog%2FCF1261E%2F</url>
    <content type="text"><![CDATA[这构造题怎么随便猜个结论就对了啊……另外这个题做法好多…… 所以 Technocup 都是升分好场？等等 div 2 没这题 总有一天我不会再咕掉升分好场的！ [CF 1261E] 题意简述给你一个整数序列 $\left\langle a_n\right\rangle$ ，保证每个数都在 $[1,n]$ 之内。 你需要找出至多 $n + 1$ 个互不相同的 $1, 2, 3, \dots, n$ 的子集，使得对于任意整数 $i$ ( $1\le i\le n$ ) 在这些集合中的出现次数为 $a_i$ 。 输出任意一个答案， $1\le n\le 10^3$ 。 主要思路本人做法首先肯定还是先排序。下文中基于 $\left\langle a_n\right\rangle$ 为不降的序列讨论。 根据样例，先考虑 $\forall i, a_i = n$ 的情况。 在 $n = 5$ 时的一个答案： 12345676111110111110111110111110111110 这给我们一些微小的启发。 初始化现在我们规定 $g(i,j)$ 表示集合 $i$ 内是否有数 $j$ 。 考虑刚刚的情况。如果 $a_i \le i$ ，令 $g(k, i) = 1$ ( $1\le k\le a_i$ ) ；如果 $a_i &gt; i$ ，令 $g(k, i) = 1$ ( $k\in [1,i] \cup [i+2,a_i+1]$ ) 。 例如样例二： Input: 1251 3 4 4 5 g: 123451111101111001110101100101 发现此时每个集合都是不同的，即已经找到了一个答案。 显然，这样的方法并不能保证最后每个集合都不同。例如样例三： Input: 1251 1 1 1 5 g: 123451111100001000010000100001 此时，有 $4$ 个相同的集合，g不是合法的答案。 解决冲突考虑如何将这些相同的集合变为不同的集合。 发现第一个集合必定是全集。下称第一个集合为元集合。 我们考虑从元集合中取出一些数放到其他集合中使得所有集合不同。 比如上面的样例三就可以变成这样： g(new): 123450001100001001010100110001 我们将元集合中 $1, 2, 3$ 这三个数分别移出并放入第 $5, 4, 3$ 这 $3$ 个集合中。 定义 $h(i)$ 为处理前 $i$ 个数时，原本的 $g$ 中序号最大的不为空的集合的序号。 例如样例四： Input: 1252 2 3 5 5 g: 123456111110111110111000110000100010 $i$ $1$ $2$ $3$ $4$ $5$ $h(i)$ $3$ $3$ $3$ $6$ $6$ 可以看出，因为 $g(i, i + 1) = 0$ ，几个冲突的集合必定为前缀一段0，后缀一段1的形式。 而仅当 $a_i &gt; a_{i - 1}$ 时，才有可能发生冲突。此时有相同的集合个数为 $\min(a_i, i) - h(i - 1)$ 。 相同的 $c$ 个集合可以对除第一个以外的 $c-1$ 个中加入一个数使得其互不相同。 一个显然的想法是维护一个 $p$ ，表示当前元集合中最小的数。每当出现冲突时，将该数从元集合中取出，并插入到冲突的最后一个集合中，然后将 $p$ 设为元集合现在最小的数。 这样，就得到了上文中样例三的一个答案。 然而我们发现这样会有一些问题。 例如样例五： Input: 1271 1 1 4 4 4 7 g: 12345671111111000111100011110001111000000100000010000001 处理第 $4$ 个数出现的冲突时没有问题，此时 g 变为： 12345670011111000111101011111001111000000100000010000001 而当处理第 $7$ 个数出现的冲突时，如果将元集合中的 $3$ 移出放入第 $7$ 个集合，则会导致第 $1$ 与第 $2$ 个集合相同。 所以，为了保证元集合不和其他集合相同，如果 $a_p &lt; a_{p + 1}$ ，那么 $p$ 这个数就不应该被从元集合中移出。 那么还有什么元集合中的数应该保留？ 例如样例五： Input: 1271 3 3 3 3 3 7 g: 12345671111111011111100111110100001000000100000010000001 处理第 $7$ 个数的冲突时，会导致 g 变为： 12345670011111011111100111110100001000000101000011000001 此时，第 $1$ 与 第 $3$ 个集合相同了。 所以，如果 $a_i &gt; i$ ，数 $i$ 也不应从元集合中取出。 加上这两个处理后开码，一交过了。 正确性证明为什么这是对的？ 首先我们先将初始的 g 表示成几个点与一条直线。 例如上图对应的 g : 1234567811111110001111000111100011110000111000001100001010000110 设这条直线为 $\text{base}$ ，向右为 $x$ 轴正方向，向下为 $y$ 轴正方向。将所有在 $\text{base}$ 下方的点都向上移动一个单位，这样，第 $i$ 个点的位置即为 $(i, a_i)$ 。 然后把相邻两个点之间的先向右再向下两条线段连起来。这样得到一条折线，从 $(1, a_1)$ 开始，到 $(n, a_n)$ 结束。 考虑这条折线中所有竖直的线段。设所有跨过直线 $\text{base}$ 的线段的在 $\text{base}$ 下方的长度和为 $nS$ ，所有线段的长度和为 $S$ ，线段条数为 $cS$ （将跨过 $\text{base}$ 的线段算作两条）。例如上图中， $nS = 1, S = 6, cS = 3$ 。 则需要将 $S - cS - nS$ 个元集合中的数取出。 考虑这条折线中所有水平的线段。设所有跨过直线 $\text{base}$ 的线段的在 $\text{base}$ 下方的长度和为 $nT$ ，所有线段的长度和为 $T$ ，线段条数为 $cT$ 。例如上图中， $nT = 1, T = 6, cT = 3$ 。 则有 $T - cT - nT$ 个元集合中的数可以被取出。 现在我们要证明 $S - cS - nS \le T - cT - nT$ 。 因为折线的结束点 $(n, a_n)$ 必定不在直线 $\text{base}$ 下方，所以可以得到 $nS = nT$ 。并且易得 $T = n - 1, S = a_n - 1$ ， 所以 $S \le T$ 。 由于从 $(1, a_1)$ 出发后第一条线段必定向右，所以 $cS \le cT$ 。 最后就可以得到 $S - cS - nS \le T - cT - nT$ 。 所以这个做法是对的！ 神仙 HZB 做法还是先不降排序。 构造方法仍然规定 $g(i,j)$ 表示集合 $i$ 内是否有数 $j$ 。 当 $a_i \le i$ 时，令 $g(k, i) = 1$ ( $i - a_i + 1 \le k \le i$ ) ；否则令 $g(k, i) = 1$ ( $k\in [1, i] \cup [i + 2, a_i + 1]$ ) 。 例如样例二： Input: 1251 3 4 4 5 g: 123451111101111001110101100101 哎这怎么和本人的方法得到的集合一模一样啊 样例三： Input: 1251 1 1 1 5 g: 123451000101001001010001100001 不像上面本人的做法，这个答案直接就对了。 于是直接写一发，然后过了。 ？？？？？？ 正确性证明好，证明。 观察到一个鲜明的特点：集合 $i$ ( $1 \le i \le n$ ) 有 $g(i, i) = 1$ 。 首先证明第 $n + 1$ 个集合不会和任何其他集合相同。 如果 $a_{n - 1} &lt; n$ 显然这个集合为空，而其他集合均为非空。 如此，我们设 $t$ 为最小满足 $a_t = n$ 的整数。 此时 $g(n + 1, i) = 1$ ( $t \le i \le n - 1$ ) 。 易得集合 $[t, n]$ 均不与其相同（因为后面都挖掉了一个数而且每个集合挖掉的数是不同的）；且集合 $[1, t - 1]$ 均不与其相同（因为 $g(j, i) = 1$ ( $1 \le j &lt; t, t \le i \le n$ ) 而 $g(n + 1, n) = 0$ ）。 假设集合 $x$ 与集合 $y$ ( $x &lt; y \le n$ )相同。 因为 $g(x, x) = 1, g(y, y) = 1$ ，且这两个集合相同，故有 $g(y, x) = 1, g(x, y) = 1$ 。 所以 $a_x \ge y - 1$ ，即 $a_{y - 1} \ge y - 1$ ，即 $g(x, y - 1) = 1$ 。但显然 $g(y, y - 1) = 0$ ，与我们的假设矛盾。 故不存在两个集合相同。 故该构造方法正确。 BGNB! 神 tourist 做法没看懂，咕了。 原社论先不升排序。我们现在依次在这至多 $n + 1$ 个集合中加入数 $1$ 至数 $n$ 。 我们用一可重集合 $S$ 来描述已经加入 $[1, x - 1]$ 后的状态。 假设 $S = {c_1, c_2, c_3, \dots, c_{|S|}}$ ，则目前至多有 $|S|$ 种互相不同的集合，第 $i$ 种集合的数量为 $c_i$ 。 现在我们研究加入 $x$ 时会发生什么。 首先假设 $S$ 中最大的数为 $A$ 。 如果 $a_x &lt; A$ ，我们可以将 $x$ 加入到这 $A$ 个集合中的前 $a_x$ 个中去。这样，原本 $A$ 个相同的集合就变成了 $a_x$ 个新的相同的集合和 $A - a_x$ 个旧的相同的集合。由于其他集合中必定没有 $x$ ，所以这 $a_x$ 个新的相同的集合必定和其他集合不相同。 如果 $a_x \ge A$ ，我们可以类似地将 $A$ 个相同的集合变为 $A - 1$ 个新的相同的集合和 $1$ 个旧的集合。多出来的 $a_x - A + 1$ 个 $x$ 只用随机放到剩下的集合中就可以了。 开始时令 $S={n + 1}$ 即可。由于最后要将 $S$ 变为一个有 $n + 1$ 个 $1$ 的集合，且每放入一个数都会导致其中的一个元素分裂成两个而集合内元素总和不变，所以只需要 $n$ 次，一定可以满足要求。 参考代码本人做法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 1010; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;struct NODE&#123; int num, id; inline int operator &lt;(const NODE &amp;X)const&#123; return num &lt; X.num; &#125;&#125;a[N];int n, g[N][N], cbu[N], cnt, ot[N];inline int get_ans()&#123; ROF(i, n + 1, 1) FOR(j, 1, n) if(g[i][j]) return i; return 0;&#125;int main()&#123; n = read(); FOR(i, 1, n) a[i].num = read(), a[i].id = i; sort(a + 1, a + n + 1); FOR(i, 1, n) ot[a[i].id] = i; FOR(i, 1, n)&#123; FOR(j, 1, min(a[i].num, i)) g[j][i] = 1; FOR(j, i + 1, a[i].num) g[j + 1][i] = 1; &#125; FOR(i, 1, n - 1) if(a[i].num == a[i + 1].num &amp;&amp; a[i].num &lt;= i) ++cnt, cbu[i] = 1; Rint tmp = 1, h = a[1].num + (a[1].num &gt; 1); FOR(i, 2, n)&#123; if(a[i - 1].num &lt; a[i].num)&#123; Rint res = min(a[i].num, i); for(Rint t = 1; t &lt; res - h;)&#123; if(cbu[tmp])&#123; g[1][tmp] = 0; g[res - t + 1][tmp] = 1; ++t; &#125; ++tmp; &#125; &#125; chkmax(h, a[i].num + (a[i].num &gt; i)); &#125; Rint ans = get_ans(); printf("%d\n", ans); FOR(i, 1, ans)&#123; FOR(j, 1, n) putchar(g[i][ot[j]] ^ 48); putchar('\n'); &#125; return 0;&#125; 看，多短（然而在所有做法中好像也是最繁琐的……）]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP-S2019二轮游]]></title>
    <url>%2Fblog%2FCSP-S2019%E4%BA%8C%E8%BD%AE%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[感觉自一轮游已经过去了好久。 今年怎么题这么难啊。 我怎么挂了这么多分啊。 我怎么这么菜啊。 Before…总之停了一个月左右的文化课。 后三周大概每天一套模拟题。每天日常挂分。 慢慢感觉有点状态了。 Day -5 ~ -1双十一来了。然后发现当天已经day -4。 最后一周，搞了两套信心赛，之后就自主改题和复习。 然而好像也没啥能复习的。所以就开始做往年的大搜索和模拟。 Day 0早上没咋写代码了。学习p_b_p_b搞了一篇挂分集锦，然而还没上传。 结果下午还去上了个数学课放松身心。 晚上开了个美其名曰动员大会的玩意。总感觉大家都被奶了。 结束后突然开始在机房狂笑不止，机房里充满了快活的空气。笑气中毒（确信） 之后回家dd Vtuber去了。结果发现喫茶ステラと死神の蝶（星巴克与扑棱蛾子）的 OP 出了，听了一晚上。 果然柚子社最棒了。 Day 1和NOIP 2018考场相同，坐地铁只用半个小时。 感觉昨晚没睡好。在地铁里听了一路寒蝉的you，差点在地铁里睡着了。 考室在 7 楼。边爬楼还边想着有什么要注意的地方。 大概8:20让我们进去试机。翻来覆去看了各种须知之后去找noi linux虚拟机。然而并没有找到，一定是我瞎了罢。不过当时我还不知道虚拟机怎么打开，虽然会用linux。然而noi linux对于一个还没参加过 NOI 的选手有什么用吗。 8:30，开考了。 这个 T1 …… 打了个表之后知道是 k ^ (k &gt;&gt; 1) ，然而开了long long，成功-5pts。 这个 T2 …… 看上去就很套路的东西，CSP 开无限栈空间对吧，写就完事了。 才过去了不到 1.5h 。 这个 T3 …… 先码个 10pts 。 不对啊，我怎么可能只会 10pts ！ 然后想了各种假做法。最后还是只写了 10 分暴力。 期望得分 95 + 100 + 10 = 205 。 出来发现大家基本都 100 + 100 + 10 = 210 ，还好还好。 回家之后继续水群和dd Vtuber。 Day 2AthousandMoon似乎 D1T1 用了 cout 然后因为 &lt;&lt; 比 ^ 优先级高并没打括号导致 CE 了…… 不要指望着Day 2翻盘，因为你根本就不知道盘是什么样子。 再次试机，有点紧张，安分地坐在那里，什么也没动。 又到了八点半。密码怎么是抓紧时间…… 第一题卫宫饭好评。 看了几眼，第一题数数，第二题最优化，第三题在树上搞不知道什么玩意，果断顺序开题。 发现 T1 只会 32pts ，赶紧写完暴力搞 T2 。 T2 想了一会，搞了个 $O(n^2\log_2{n})$ 。希望能过 $n\le 5000$ 的点吧。 接着回肝 T1 ，码了一个假做法之后，搞出来一个 $O(n^3m)$ 的垃圾，发现有 84pts ，然后决定先拿个 T3 暴力再开码。 开 T3 ，此时10:40。然后整整 40min 没调过 T3 的 $O(n^2)$ 暴力。虽然玩出来了链，完全二叉树也大概知道思路，但是连最裸的暴力都写挂了不太敢写。 不太对劲啊。 最后半小时，赶紧回去写 T1 的 84pts 。在之前没码完的假做法上改一改就好了，写完用了不到一刻钟。 不太对劲啊。 这怎么也能写挂啊。 剩下 15min 疯狂调 T1 。然而没调出来。 完了， 32 + 64 + 0 = 96 ，连仨暴力都不如的分数。 实际能写 84 + 64 + 55(75?) = 203(223) 。真就挂的分比拿到的分还多呗。 凉了。期望得分 205 + 96 = 301 。万一哪里再写挂了什么，就连 300 都上不了了。 出来发现大家都挂分了，都在说今年题难。 成功获得小机房吊车尾，甚至差点被联赛组同学吊打了。 然而p_b_p_b（期望 498）和nantf（期望 430+）稳了。 完了，要放年假了。 Day 3 ~ 4然后就回归文化课了。 这两天年级月考。逃掉了月考，在机房自习文化课。 完全接受了自己凉凉的事实。真就浪费一年呗。 After All ～痛苦的现实～今年居然发了程序。 拉下来一测， D1T3 因为最后几分钟还在测样例，忘记开文件操作又挂 10 分。 总分只有 291 了。可能只能捞到个没什么用的一等。 接下来的一年，虽然 OI 训练不会停止，但是没什么比赛可以现场参加了。 唉。滚回去搞文化课罢。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Old Driver Tree学习笔记]]></title>
    <url>%2Fblog%2FOldDriverTree%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Old Driver Tree (ODT)，又称珂朵莉树，是源于 lxl 出的「CF 896C」的，对一类以推平区间作为关键操作的维护数列方法。 原理很简单：使用一棵平衡树（大多数情况下为std::set），每个节点存储一段权值相等的极长区间。 一些操作下述时间复杂度时， $n$ 表示平衡树中的节点数量（即序列中权值相等的极长区间数量）。 split将某一个权值相等的区间分裂成两个，要求 $pos$ 为后一个的左端点。 在平衡树中找到跨过 $pos$ 的区间，删除并添加新区间即可。复杂度稳定 $O(\log_2{n})$ 。 assgin将区间 $[l,r]$ 推平。 先把 $l$ 和 $r + 1$ 进行 split 操作，再把 $[l,r]$ 合成一个节点。 注意要先 split $r+1$ 再 split $l$ 。 单次复杂度最坏 $O(n)$ 。 其他操作在平衡树上遍历节点即可。 复杂度的证明假设在数据真随机的情况下，开始时有 $n$ 个长为 $1$ 的区间，接下来有 $k$ 个区间推平操作。 考虑一次推平操作后，点 $i$ 作为一个权值相等的极长区间的结尾的可能性为:$$1 - \dfrac{i + \binom{i - 1}{2} + \binom{n - i}{2}}{\binom{n}{2}} = 1 - \dfrac{2i(n - i - 1)}{n(n - 1)} \approx \left(\dfrac{i}{n}\right)^2 + \left(1 - \dfrac{i}{n}\right)^2$$ 假设这 $k$ 次区间推平是独立的，那么 $k$ 次推平后点 $i$ 作为一个权值相等的极长区间的结尾的可能性约为 $((\frac{i}{n})^2 + (1 - \frac{i}{n})^2)^k$ 。 所以总的权值相等的极长区间的总数即约为 $\sum\limits_{i=1}^{n}((\frac{i}{n})^2 + (1 - \frac{i}{n})^2)^k\approx n\int_0^1 (x^2 + (1 - x)^2)^k \mathrm{d}x$ 。 $$\begin{aligned} &amp; n\int_0^1 (x^2 + (1 - x)^2)^k \mathrm{d}x \\=\ &amp; n \int_{-1/2}^{1/2} ((\frac{1}{2} + x)^2 + (\frac{1}{2} - x)^2)^k \mathrm{d}x \\=\ &amp; n \int_{-1/2}^{1/2} (\frac{1}{2} + 2x^2)^k \mathrm{d}x \\=\ &amp; n\cdot 2^{-k} \int_{-1/2}^{1/2} (1 + 4x^2)^k \mathrm{d}x \\=\ &amp; n\cdot 2^{-k} \sum\limits_{i=0}^{k} \binom{k}{i}\cdot 4^i \int_{-1/2}^{1/2} x^{2i} \mathrm{d}x \\=\ &amp; n\cdot 2^{-k} \sum\limits_{i=0}^{k} \binom{k}{i}\cdot 4^i\cdot \frac{(1/2)^{2i+1} - (-1/2)^{2i+1}}{2i+1} \\=\ &amp; n\cdot 2^{-k} \sum\limits_{i=0}^{k} \binom{k}{i} \frac{1}{2i + 1} \\\le\ &amp; n\cdot 2^{-k} \sum\limits_{i=0}^{k} \binom{k}{i} \frac{1}{i + 1} \\=\ &amp; n\cdot 2^{-k} \cdot \frac{2^{k+1} - 1}{k + 1} \\=\ &amp; O(\frac{n}{k})\end{aligned}$$ 所以，最坏情况下 $k$ 次区间推平的复杂度是 $O(n\log_2k)$ 。 lxl的题解，Akababa的原证明。另外，Blaze也给出了一种证明方法。 代码实现及例题「CF 896C」Willem, Chtholly and Seniorious例题。 维护长为 $n$ 的序列， $m$ 个操作，可能为区间加、区间推平、区间查询第 $k$ 小，区间查询 $(\sum_{i=l}^{r} a_i^x)\mod y$ 。 $1\le n,m\le 10^5$ ，数据随机生成。 思路直接上 ODT 即可。 由于要区间加，记得节点开 $mutable$ 。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125;// #define using_mod const LL mod = 1000000007; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; Templ(_Tp) inline _Tp ksm(_Tp x,LL y)&#123; reg _Tp res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;inline LL ksm(LL x, LL y, const LL &amp;p)&#123; x %= p; reg LL res = 1; for(; y; y &gt;&gt;= 1, x = x * x % p) if(y &amp; 1) res = res * x % p; return res;&#125;int n, m;LL seed, vmess;inline LL rnd()&#123; reg LL ret = seed; seed = (seed * 7 + 13) % mod; return ret;&#125;namespace ODT&#123; struct node&#123; int l, r; mutable LL val; inline node(int rl = 0, int rr = -1, LL rv = 0)&#123; l = rl, r = rr, val = rv; &#125; inline int operator &lt;(const node &amp;t)const&#123; return l &lt; t.l; &#125; &#125;; set&lt;node&gt; s; typedef set&lt;node&gt;::iterator iter; inline iter split(int pos)&#123; iter it = s.lower_bound(node(pos)); if(it != s.end() &amp;&amp; it-&gt;l == pos) return it; --it; Rint l = it-&gt;l, r = it-&gt;r; reg LL v = it-&gt;val; s.erase(it); s.insert(node(l, pos - 1, v)); return s.insert(node(pos, r, v)).first; &#125; inline void assign(int l, int r, LL val)&#123; iter itr = split(r + 1), itl = split(l); s.erase(itl, itr); s.insert(node(l, r, val)); &#125; inline void add(int l, int r, LL val)&#123; iter itr = split(r + 1), itl = split(l); while(itl != itr) (itl++)-&gt;val += val; return; &#125; inline LL k_th(int l, int r, int k)&#123; iter itr = split(r + 1), itl = split(l); vector&lt; pair&lt;LL, int&gt; &gt; vec; vec.clear(); while(itl != itr)&#123; vec.push_back(MP(itl-&gt;val, itl-&gt;r - itl-&gt;l + 1)); itl++; &#125; sort(vec.begin(), vec.end()); for(pair&lt;LL, int&gt; &amp;i : vec)&#123; k -= i.sec; if(k &lt;= 0) return i.fir; &#125; return -1ll; &#125; inline LL sum(int l, int r, LL x, LL y)&#123; iter itr = split(r + 1), itl = split(l); reg LL res = 0; while(itl != itr)&#123; res =(res + ksm(itl-&gt;val, x, y) * (itl-&gt;r - itl-&gt;l + 1)) % y; itl++; &#125; return res; &#125;&#125;using namespace ODT;int main()&#123; n = read(), m = read(), seed = read(), vmess = read(); FOR(i, 1, n) s.insert(node(i, i, rnd() % vmess + 1)); Rint opt, l, r; reg LL x, y; FOR(i, 1, m)&#123; opt = rnd() % 4 + 1; l = rnd() % n + 1; r = rnd() % n + 1; if(l &gt; r) swap(l, r); x = rnd() % ((opt == 3) ? (r - l + 1) : vmess) + 1; switch(opt)&#123; case 1:&#123; add(l, r, x); break; &#125; case 2:&#123; assign(l, r, x); break; &#125; case 3:&#123; printf("%lld\n", k_th(l, r, x)); break; &#125; case 4:&#123; y = rnd() % vmess + 1, printf("%lld\n", sum(l, r, x, y)); break; &#125; &#125; &#125; return 0;&#125; 「CometOJ contest#14 D」转转的数据结构题[CometOJ contest#14 D]。 一个长为 $m$ 的整数序列 $c$ ，初值全为 $0$ ；一个长为 $n$ 的操作序列，第 $i$ 个用三元组 $(l_i, r_i, v_i)$ 描述，代表将 $c_{l_i}, c_{l_i + 1}, c_{l_i + 2}, \cdots, c_{r_i}$ 赋值为 $v_i$ 。 $q$ 个询问，第 $i$ 个有两个参数 $x_i$ , $y_i$ ( $x_i\le y_i$ )，回答对初值全为 $0$ 的空序列 $c$ ，按顺序执行序号位于 $[x_i,y_i]$ 中的操作后， $c$ 中所有整数的和。 $1\le n,m,q\le 5\times 10^5,0\le v_i\le 2\times 10^9$ 。 思路将询问按照 $y_i$ 排序。使用类似 ODT 的方法来维护 $c$ 序列。 对平衡树上的每个节点存储一个时间戳 $t$ ，即这个节点是由哪次操作产生的。发现询问 $x_i, y_i$ 即为做完前 $y_i$ 个操作后，时间戳不小于 $x_i$ 的节点的和。这可以很容易地使用树状数组维护。 将时间后移（即进行下一个修改）时修改树状数组即可。 考虑这个方法的时间复杂度。每个节点最多只会被删除 $1$ 次。而一个修改在插入 $1$ 个节点的同时最多只会分裂 $2$ 个节点，所以节点的变化次数是 $O(n)$ 的。 所以，虽然这个题的数据不随机，然而时间复杂度是稳定 $O(n\log_2{n})$ 的。 代码写得特别丑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 500010; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;int n, m, q;struct Query_Node&#123; int tl, tr, id; inline int operator &lt;(const Query_Node &amp;t)const&#123; return tr &lt; t.tr; &#125;&#125;qry[N];struct Cover_Node&#123; int l, r, val;&#125;cvr[N];struct ODT_Node&#123; int l, r, val, tsp; inline ODT_Node(int ll = 0, int rr = 0, int vall = 0, int tspp = 0)&#123; l = ll, r = rr, val = vall, tsp = tspp; &#125; inline int operator &lt;(const ODT_Node &amp;t)const&#123; return l &lt; t.l; &#125;&#125;;struct BIT&#123; LL a[N]; inline void update(int x, LL val)&#123; if(!x) return; for(; x &lt;= m; x += x &amp; (-x)) a[x] += val; return; &#125; inline LL query(int x)&#123; reg LL res = 0; for(; x; x -= x &amp; (-x)) res += a[x]; return res; &#125; inline LL queryS(int l, int r)&#123; return query(r) - query(l - 1); &#125;&#125;BT;set&lt;ODT_Node&gt; odt;typedef set&lt;ODT_Node&gt;::iterator ODTit;LL ans[N];inline ODTit split(int pos)&#123; ODTit it = odt.lower_bound(ODT_Node(pos, 0, 0, 0)); if(it != odt.end() &amp;&amp; it-&gt;l == pos) return it; --it; Rint l = it-&gt;l, r = it-&gt;r, val = it-&gt;val, tsp = it-&gt;tsp; odt.erase(it); odt.insert(ODT_Node(l, pos - 1, val, tsp)); return odt.insert(ODT_Node(pos, r, val, tsp)).fir;&#125;inline void Assign(int l, int r, int val, int tsp)&#123; ODTit R = split(r + 1), L = split(l); for(ODTit i = L; i != R; ++i) BT.update(i-&gt;tsp, -1ll * (i-&gt;val) * (i-&gt;r - i-&gt;l + 1)); odt.erase(L, R); odt.insert(ODT_Node(l, r, val, tsp)); BT.update(tsp, 1ll * val * (r - l + 1));&#125;int main()&#123; m = read(), n = read(), q = read(); FORit(Cover_Node, cvr, i, 1, m) i-&gt;l = read(), i-&gt;r = read(), i-&gt;val = read(); FORit(Query_Node, qry, i, 1, q) i-&gt;tl = read(), i-&gt;tr = read(), i-&gt;id = i - qry; sort(qry + 1, qry + q + 1); odt.insert(ODT_Node(1, n + 1, 0, 0)); FORit(Query_Node, qry, i, 1, q)&#123; FOR(tsp, (i - 1)-&gt;tr + 1, i-&gt;tr) Assign(cvr[tsp].l, cvr[tsp].r, cvr[tsp].val, tsp); ans[i-&gt;id] = BT.queryS(i-&gt;tl, m); &#125; FOR(i, 1, q) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ODT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Comet#13F」「蓬莱的弹枝 -七色的弹幕-」]]></title>
    <url>%2Fblog%2FCometOJ-13F%2F</url>
    <content type="text"><![CDATA[一道只有标题和东方有关系的大分块。 [CometOJ contest#13 F] 题意简述维护一个长为 $n$ 的序列，要求支持查询距离某个数 $a_x$ 距离最近的相等的数与这个数的距离，区间加一，区间左移一位（即 $a_{i}\leftarrow a_{i+1} (l\le i\le r), a_r\leftarrow a_l$ ）。 $1\le n,m,a_i\le 10^5$ 。 主要思路所以平衡树怎么做这个玩意？ 分块，设每块长度为 $K$ 。每个块内记录： $beg$ ：这个块第一个数的下标减一 $cnt$ ：这个块的长度 $tag$ ：这个块的加标记 $\left\langle num\right\rangle$ ：块中元素（存储的值为真实值减去 $tag$ ，存储的数对应原序列中的 $[beg + 1, beg + cnt]$ ） $\left\langle fix\right\rangle$ ： $fix_{val}$ 表示块内值为 $val$ （真实值为 $val + tag$ ）的数的数量 查询查询时，寻找这个位置 $x$ 所在的块 $B_x$ ，先在这个块内找有没有相同数；再分别遍历 $B_x$ 后面与前面的块，找到后面与前面分别第一次出现 $a_x$ 的块（由于存储了 $\left\langle fix\right\rangle$ ，可以 $O(1)$ 判断一个块内有没有 $a_x$），在块内暴力寻找 $a_x$ 出现的位置更新答案。 这样得到三组结果，取最优即可。一次时间复杂度 $O(K + \dfrac{n}{K})$ 。 区间加经典操作。散块暴力整块打 $tag$ 即可。一次时间复杂度 $O(K + \dfrac{n}{K})$ 。 区间左移设区间左移 $[l,r]$ 时，最前和最后的要修改的块分别为 $B_l$ 与 $B_r$ 。 官方题解中，每个块的大小是定的。这样使用块状数组，每次左移即对于 $[B_l, B_r]$ 中的每个块，将弹出一个数字和插入一个数字，块大小仍然不变，只需处理修改块的 $beg$ 即可。发现散块是在中间插入与弹出，可以暴力处理；整块是在两端插入与弹出，可以 $O(1)$ 搞。一次时间复杂度是 $O(K + \dfrac{n}{K})$ 。 这样写比较方便，代码也比较短。 然而本人将此题当作块状链表的例题来做。即完全按照题意，每次左移将块 $B_l$ 中对应序列中下标为 $l$ 的数弹出，其他块不变，然后插入到块 $B_r$ 中对应序列中下标为 $r$ 的数后面。 由于一个块大小减少 $1$ ，一个块大小增加 $1$ ，所以当一个块大小过大 ( $cnt &gt; 2\times K$ ) 或过小 ( $cnt \le \dfrac{K}{2}$ ) 时，将这个块分裂成两个块或与后一个块合并（若合并后 $cnt &gt; 2\times K$ ，也不应合并，应将后一个块前端部分移至该块后端使这两个块的大小较为平衡）。 最后也能推出单次时间复杂度为 $O(K + \dfrac{n}{K})$ 。 所以 $K$ 取 $\sqrt{n}$ 时，时间复杂度取到最优为 $O(n\sqrt{n})$ 。这题不卡空间所以 $K$ 开 $\sqrt{n}$ 空间上也不会有问题。 参考代码然而我真就把这题当作块状链表的例题来做了，各种不熟练导致调了一下午。 一些细节详见代码与注释。 大量指针注意。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 100010, BN = 400; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;int n, m, blo, a[N], dtop;struct Block;inline Block* new_Block();inline void del_Block(Block *B);struct Block&#123; Block *pre, *nxt; int beg, fix[N &lt;&lt; 1], tag, cnt, num[BN &lt;&lt; 1]; //beg : 前面的块总共有多少个数, cnt : 块大小, tag : 加标记 //fix : 值域(不加 tag)上每种数的数量, num : 每个数(不加 tag) inline void Clear()&#123; pre = nxt = nullptr; beg = tag = cnt = 0; MEM(fix, 0), MEM(num, 0); &#125; inline Block()&#123; Clear(); &#125; inline void scatter()&#123;//把过大的块拆成两个 Rint rc = cnt, *it = nullptr; reg Block *to = nxt, *x = new_Block(); x-&gt;pre = this, x-&gt;nxt = to; nxt = x;//处理各种关系 if(to != nullptr) to-&gt;pre = x; cnt = blo, x-&gt;cnt = rc - blo; x-&gt;beg = beg + blo, x-&gt;tag = tag; it = x-&gt;num; FOR(i, blo + 1, rc)&#123;//把信息转到分出来的块里去 ++it; *it = num[i], --fix[*it], ++(x-&gt;fix[*it]); &#125; return; &#125; inline void merge()&#123;//把过小的块和下一个块合并成两个 / 将过小的块后端插入下一个块的一个前缀使该块不至于太小 reg Block *x = nxt, *to = nullptr; if(x == nullptr) return; if(cnt + x-&gt;cnt &gt; (blo &lt;&lt; 1))&#123;//如果两个块加起来大小过大就不能直接合并(然而这样就不用处理各种关系了, 写起来其实更方便) Rint *it = nullptr; FOR(i, 1, cnt) --fix[num[i]], num[i] += tag, ++fix[num[i]]; tag = 0; it = x-&gt;num; FOR(i, cnt + 1, blo)&#123;//把这个块的长度补到 blo ++it; num[i] = (*it) + x-&gt;tag, ++fix[num[i]], --(x-&gt;fix[*it]); &#125; FOR(i, 1, cnt + x-&gt;cnt - blo) ++it, x-&gt;num[i] = *it;//处理下个块的信息 x-&gt;cnt += cnt - blo, x-&gt;beg += blo - cnt, cnt = blo; return; &#125; to = x-&gt;nxt, nxt = to; if(to != nullptr) to-&gt;pre = this;//处理各种关系 Rint rc = cnt + x-&gt;cnt, *it = x-&gt;num; FOR(i, 1, cnt) --fix[num[i]], num[i] += tag, ++fix[num[i]];//把 tag 去掉 tag = 0; FOR(i, cnt + 1, rc)&#123;//把原本的下一个块的信息转过来 ++it; num[i] = *it + x-&gt;tag, ++fix[(*it) + x-&gt;tag]; &#125; cnt = rc; del_Block(x);//把原本的下一个块删了 return; &#125; inline void check()&#123;//检查块是否过大或过小 if(cnt &gt; (blo &lt;&lt; 1)) return scatter(); if(cnt &lt;= (blo &gt;&gt; 1)) return merge(); return; &#125; inline void print()&#123; puts("Block : "); printf("beg : %d, cnt : %d, tag : %d\n", beg, cnt, tag); FOR(i, 1, cnt) printf("%d ", num[i]); puts(""); &#125;&#125;;Block *St = nullptr/*, *Ed = nullptr*/, *del[BN &lt;&lt; 1];inline Block* new_Block()&#123; return dtop ? del[--dtop] : (new Block);&#125;inline void del_Block(Block *B)&#123;//由于有拆块和合并块, 所以写了垃圾回收, 回收方式比较奇怪 B-&gt;Clear(); del[dtop++] = B; return;&#125;inline void Debug()&#123; reg Block *now = St; while(now != nullptr)&#123; now-&gt;print(); now = now-&gt;nxt; &#125; return;&#125;inline void Build()&#123; St = new_Block(); FOR(i, 1, blo) St-&gt;num[i] = a[i], ++(St-&gt;fix[a[i]]); St-&gt;beg = 0, St-&gt;cnt = blo;//先把头搞出来 reg Block *now = St, *to; FOR(i, 2, ceil(n / (DB)(blo)))&#123;//做出每个块 to = new_Block(); now-&gt;nxt = to, to-&gt;pre = now; to-&gt;beg = now-&gt;beg + now-&gt;cnt; to-&gt;cnt = min(n, to-&gt;beg + blo) - to-&gt;beg; FOR(j, to-&gt;beg + 1, to-&gt;beg + to-&gt;cnt)&#123; to-&gt;num[j - to-&gt;beg] = a[j]; ++(to-&gt;fix[a[j]]); &#125; now = to; &#125;// Ed = now; return;//实际上 Ed 根本不需要用... &#125;inline int query(int x)&#123; reg Block *now = St, *B = nullptr; Rint wgh, res = n + 1;// find block [x] while(now-&gt;beg + now-&gt;cnt &lt; x) now = now-&gt;nxt;// query block [x] wgh = now-&gt;num[x - now-&gt;beg]; if(now-&gt;fix[wgh] &gt; 1)&#123;//处理自己的块 ROF(i, x - now-&gt;beg - 1, 1) if(now-&gt;num[i] == wgh)&#123; chkmin(res, x - now-&gt;beg - i); break; &#125; FOR(i, x - now-&gt;beg + 1, now-&gt;cnt) if(now-&gt;num[i] == wgh)&#123; chkmin(res, i - x + now-&gt;beg); break; &#125; &#125; wgh += now-&gt;tag;// query next blocks B = now-&gt;nxt; while(B != nullptr)&#123; if(wgh - B-&gt;tag &gt; 0 &amp;&amp; B-&gt;fix[wgh - B-&gt;tag])&#123;//找到 next blocks 中第一个有 wgh 的块, 注意可能 wgh - B-&gt;tag 不大于 0, 要判 FOR(i, 1, B-&gt;cnt) if(B-&gt;num[i] == wgh - B-&gt;tag)&#123; chkmin(res, i + B-&gt;beg - x); break; &#125; break; &#125; B = B-&gt;nxt; &#125;// query pre blocks B = now-&gt;pre; while(B != nullptr)&#123; if(wgh - B-&gt;tag &gt; 0 &amp;&amp; B-&gt;fix[wgh - B-&gt;tag])&#123;//找到 pre blocks 中第一个有 wgh 的块, 注意可能 wgh - B-&gt;tag 不大于 0, 要判 ROF(i, B-&gt;cnt, 1) if(B-&gt;num[i] == wgh - B-&gt;tag)&#123; chkmin(res, x - i - B-&gt;beg); break; &#125; break; &#125; B = B-&gt;pre; &#125; return res != n + 1 ? res : -1;&#125;inline void update_add(int l, int r)&#123;//区间加没啥难度 reg Block *now = St; Rint *it = nullptr;// find block [l] while(now-&gt;beg + now-&gt;cnt &lt; l) now = now-&gt;nxt; if(now-&gt;beg + now-&gt;cnt &gt;= r)&#123;//if [l] and [r] in the same block it = now-&gt;num + l - now-&gt;beg - 1; FOR(i, l - now-&gt;beg, r - now-&gt;beg)&#123; ++it; --(now-&gt;fix[*it]), ++(*it), ++(now-&gt;fix[*it]); &#125; return; &#125;// update block [l] it = now-&gt;num + l - now-&gt;beg - 1; FOR(i, l - now-&gt;beg, now-&gt;cnt)&#123; ++it; --(now-&gt;fix[*it]), ++(*it), ++(now-&gt;fix[*it]); &#125;// find block [r] now = now-&gt;nxt; while(now-&gt;beg + now-&gt;cnt &lt; r)&#123; ++(now-&gt;tag); now = now-&gt;nxt; &#125; // update block [r] it = now-&gt;num; FOR(i, 1, r - now-&gt;beg)&#123; ++it; --(now-&gt;fix[*it]), ++(*it), ++(now-&gt;fix[*it]); &#125; return;&#125;inline void update_shift(int l, int r)&#123; reg Block *now = St, *x; Rint *it = nullptr, wgh;// find block [l] while(now-&gt;beg + now-&gt;cnt &lt; l) now = now-&gt;nxt; if(now-&gt;beg + now-&gt;cnt &gt;= r)&#123;//if [l] and [r] in the same block wgh = now-&gt;num[l - now-&gt;beg]; FOR(i, l - now-&gt;beg, r - now-&gt;beg - 1) now-&gt;num[i] = now-&gt;num[i + 1]; now-&gt;num[r - now-&gt;beg] = wgh; return; &#125;// update block [l] wgh = now-&gt;num[l - now-&gt;beg], --(now-&gt;fix[wgh]); FOR(i, l - now-&gt;beg, now-&gt;cnt - 1) now-&gt;num[i] = now-&gt;num[i + 1]; wgh += now-&gt;tag, --(now-&gt;cnt);//把一个点从这个块里抽出来所以 --(now-&gt;cnt) , 这个点已经抽出来了所以 wgh += now-&gt;tag x = now;// find block [r] now = now-&gt;nxt; while(now-&gt;beg + now-&gt;cnt &lt; r &amp;&amp; now != nullptr)&#123; --(now-&gt;beg);//这些中间的块因为前面有块被抽了一个数所以 --(now-&gt;beg) now = now-&gt;nxt; &#125; if(now == nullptr) return;// update block [r] ++(now-&gt;cnt), --(now-&gt;beg);//要插一个数进这个块里所以 ++(now-&gt;cnt) //由于 wgh - now-&gt;tag 可能不大于 0 所以应该把这个块的 tag 归 0 it = now-&gt;num; FOR(i, 1, r - now-&gt;beg - 1)&#123; ++it; --(now-&gt;fix[*it]), *it += now-&gt;tag, ++(now-&gt;fix[*it]); &#125; it = now-&gt;num + now-&gt;cnt; ROF(i, now-&gt;cnt, r - now-&gt;beg + 1)&#123; *it = *(it - 1); --(now-&gt;fix[*it]), *it += now-&gt;tag, ++(now-&gt;fix[*it]); --it; &#125;//归 0 tag 顺便把 now-&gt;num[r - now-&gt;beg] 空出来 ++(now-&gt;fix[wgh]), now-&gt;num[r - now-&gt;beg] = wgh;// tag 归 0 了所以直接插进去 now-&gt;tag = 0; x-&gt;check(), now-&gt;check();//因为两个块分别减少/增加了一个数所以 check 一下 return;&#125;int main()&#123; n = read(), m = read(), blo = ceil(sqrt(n)); FOR(i, 1, n) a[i] = read(); Build(); Rint opt, l, r; while(m--)&#123; opt = read() - 1, l = read(); if(opt == 2)&#123; printf("%d\n", query(l)); continue; &#125; r = read(); opt ? update_add(l, r) : update_shift(l, r); &#125; return 0;&#125; 所以我第一题块状链表是不是还是写个「POJ 2887」Big String 啥的合适啊…… 结果为什么写了这题之后马上又拿分块链表过了「SCOI 2013」多项式的运算呢……]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>块状链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉回路学习笔记与Hierholzer算法]]></title>
    <url>%2Fblog%2F%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E4%B8%8EHierholzer%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[欧拉回路和欧拉路径的学习笔记。 例题：[UOJ 117] 、 [LOJ 10105] 、 [Luogu 2731] 。 一些定义一个图，若能够找到一条路径，使得可以遍历完所有的边且不重复，则这样的图称为欧拉图，这条路径称为欧拉路径，若路径闭合也称为欧拉回路。 一些定理以下大量文字摘自维基百科。 定理一 连通的无向图有欧拉路径的充要条件是：图中度数是奇数的顶点数量是 $0$ 或 $2$ 。 连通的无向图有欧拉回路的充要条件是：图中所有点的度数都是偶数。 证明一 必要性：如果一个图能够一笔画成，那么对于除了起点和终点的其他顶点，总有路径中连向点的边数与这个点的出边数相同，即这个点的度数为偶数。而对于起点和终点，若起点和终点相同，则这个点的度数也为偶数；否则这两个点的度数为奇数。即图中度数为奇数的点的数量是 $0$ 或 $2$ 。 充分性： 如果图中没有度数为奇数的点，则任选一点出发，连一个环。如果这个环就是原图则结束。若不是，由于图是连通的，该环与原图的其他部分必然有公共顶点，从该点出发，在原图的剩余部分中重复上述步骤。由于原图是连通图，经过若干步后，全图被分为一些环。由于两个相连的环就是一个环，原来的图也就是一条欧拉回路。 如果图中有两个度数为奇数的顶点 $u$ 和 $v$ ，那么将他们连边后，得到一个无奇数度数的点的连通无向图，由上知这是一个环，因此去掉新加的边后，成为一条路径，起点和终点是 $u$ 与 $v$ 。至此证毕。 定理二如果连通无向图有 $2k$ 个奇数度数的顶点，那么它可以且至少可以用 $k$ 笔画成。 证明二将这 $2k$ 个奇数度数的顶点分成 $k$ 对后分别连起，则得到一个无奇数度数顶点的连通图。由上知这个图是一个环，因此去掉新加的边后至多成为 $k$ 条欧拉路径，因此必然可以用 $k$ 笔画成。但是假设全图可以分为 $q$ 条欧拉路径，则由定理一知，每条链中只有不多于两个奇顶点，于是 $2q\ge 2k$。因此必定至少要 $k$ 笔画成。 有向图的欧拉路径 一个连通的有向图可以表示为一条欧拉回路的充要条件是：每个顶点的出度和入度都相等。 一个连通的有向图可以表示为一条不闭合的欧拉路径的充要条件是：某一个点的出度比入度多 $1$ ，另一个点的出度比入度少 $1$ ，前者为起点而后者为终点。 证明方式类似证明一。 Hierholzer算法Hierholzer算法是一种可以在时间复杂度 $O(|E|)$ 内求出无向图或有向图的欧拉路径（如果有的话）的算法。 算法流程首先要判断这个图有没有欧拉路径，判断方法就是前面的定理。 然后，任选择一个顶点 $u$ 开始 dfs 。枚举 $u$ 的每条出边（若是无向图则为无向边） $e=(u,v)$ ，将这条边删去并 dfs 点 $v$ ，结束后将这条边加入答案序列。 最后再判断答案是否合法（指图是否不连通，图只要连通则必定合法），若合法，该序列倒序即为欧拉路径。 无论是否为欧拉回路均可以找到。 由于选择了一条边之后便将其删去，所以时间复杂度是 $O(|E|)$ 。 参考代码细节比较多，详见代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 100010; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;int n, m, ecnt, stk[N &lt;&lt; 2], stop;struct Edge&#123; int link, to, id, vis;&#125;e[N &lt;&lt; 2];struct Vertice&#123; int head, ind, outd, vis;&#125;p[N];inline void add_edge(int u, int v, int i)&#123; e[++ecnt] = (Edge)&#123; p[u].head, v, i &#125;; p[u].head = ecnt, ++p[u].outd, ++p[v].ind;&#125;inline int Output_path()&#123; if(stop &lt; m) return 0; puts("YES"); ROF(i, stop, 1) printf("%d ", stk[i]); return 1;&#125;inline void dfs_directed_graph(int u)&#123;//做有向图 for(Rint &amp;i = p[u].head, v, real_i; i; i = e[i].link)&#123;//&amp;i 是为了保证这条边不会再被遍历到 real_i = i, v = e[real_i].to; if(!e[real_i].vis)&#123; if(!p[v].vis) p[v].vis = 1; e[real_i].vis = 1; dfs_directed_graph(v); stk[++stop] = e[real_i].id; &#125; &#125; return;&#125;inline void dfs_undirected_graph(int u)&#123;//做无向图 for(Rint &amp;i = p[u].head, v, real_i; i; i = e[i].link)&#123; real_i = i, v = e[real_i].to; if(!e[(real_i + 1) &gt;&gt; 1].vis)&#123; if(!p[v].vis) p[v].vis = 1; e[(real_i + 1) &gt;&gt; 1].vis = 1; dfs_undirected_graph(v); stk[++stop] = e[real_i].id; &#125; &#125; return;&#125;int work_directed_graph()&#123; n = read(), m = read(); Rint u, v; FOR(i, 1, m) u = read(), v = read(), add_edge(u, v, i); FOR(i, 1, n) if(p[i].ind != p[i].outd) return puts("NO"), 0; FOR(i, 1, n) if(!p[i].vis)&#123; p[i].vis = 1, dfs_directed_graph(i); if(Output_path()) return 0; stop = 0; &#125; return puts("NO"), 0;&#125;int work_undirected_graph()&#123; n = read(), m = read(); Rint u, v; FOR(i, 1, m) u = read(), v = read(), add_edge(u, v, i), add_edge(v, u, -i); FOR(i, 1, n) if(((p[i].ind + p[i].outd) &gt;&gt; 1) &amp; 1) return puts("NO"), 0; FOR(i, 1, n) if(!p[i].vis)&#123; p[i].vis = 1, dfs_undirected_graph(i); if(Output_path()) return 0; stop = 0; &#125; return puts("NO"), 0;&#125;int main()&#123; int test_type = read() - 1; return test_type ? work_directed_graph() : work_undirected_graph();&#125; 一些套路哈密顿路径和欧拉路径相对，指的是遍历一个图的所有点且不重复的路径，可以不经过所有的边。 有时一个题目可以转化成哈密顿路径或欧拉路径。 然而图上找哈密顿路径是 NP 问题，所以基本是用欧拉路径做。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Comet#7C」临时翻出来的题]]></title>
    <url>%2Fblog%2FCometOJ-7C%2F</url>
    <content type="text"><![CDATA[状压好题。 [CometOJ contest#7 C] 题意简述给出一个 $1$ 至 $n$ 的排列 $a_i$ 。定义一个排列 ${p_i}$ 是合法的，要满足 $p_i\ne a_i$ 。 一个排列 ${p_i}$ 的权值可以这样计算：对于每一个逆序对 $(i,j)$ ($p_i &gt; p_j$) ，贡献为 $(j - i)\times(p_i - p_j)$ ，这个排列的权值即所有逆序对的贡献和。 求每一个合法的排列的权值和。 $case$ 组数据， $case \le 10, n \le 16$ 。 主要思路首先先把下标和值域都转换成 $[0,n-1]$ 。 这么小的数据范围，猜测复杂度大概是指数级别的。 按照从小到大往排列里放数，这样每个数在放入排列时，必定所有在其后的已经在排列中的数都会对其产生贡献。 考虑集合 $S$ 为放了数的位置，已经放了 $0,1,\dots,|S|-1$ 这些数，此时的合法排列（仅考虑已经放的数）方案。 记合法排列总数为 $t(S)$ ，贡献总和为 $f(S)$ ，位置 $pos$ 上的数在所有合法排列中的总和为 $g(S, pos)$ 。 如何转移？对于一个集合 $S$ ，枚举下一个数即( $|S|$ )放的位置 $x,x\ne a_{|S|}$ 。 设 $T = S\ \cup\ {x}$ ，考虑 $S$ 转移至 $T$ 。 对 $f(T)$ 的贡献为： $f(S) + \sum\limits_{i&gt;x,i\in S}(|S|\times t(S) - g(S,i))\times (i - x)$ 。（枚举与数 $|S|$ 形成逆序对的位置） 对 $t(T)$ 的贡献为： $t(S)$ 。（数 $|S|$ 只有一种放法） 对 $g(T,x)$ 的贡献为： $t(S)\times |S|$ 。 对 $g(T,i)$ 的贡献为： $g(S,i)$ ( $i\ne x$ ) 。 初始状态是 $|S|={k}$ 的状态 ( $0\le k\le n - 1$ ) ，如果 $a_0\ne k$ ， $f({k})=0,g({k},k)=0,t({k})=1$ 。 参考代码然后不知道为什么代码写得特别丑……为了卡常 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 20, MX = 65550; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;int n, a[N], U, count_[MX], loog[MX] = &#123;-1&#125;;LL f[MX], g[MX][N], t[MX];inline void Summer_Pockets()&#123; n = read(), U = (1 &lt;&lt; n) - 1; FOR(i, 0, n - 1) a[i] = read() - 1; FOR(S, 0, U) f[S] = 0, t[S] = 0; FOR(S, 0, U) FOR(i, 0, n - 1) g[S][i] = 0; FOR(S, 1, U)&#123; if(count_[S] == 1)&#123; if(a[0] == loog[S]) continue; f[S] = 0, g[S][loog[S]] = 0, t[S] = 1; continue; &#125; Rint cnt = count_[S] - 1, T, pos; reg LL res; for(Rint rS = S, x = S &amp; (-S); x; rS ^= x, x = rS &amp; (-rS))&#123; T = S ^ x, res = 0, pos = loog[x]; if(a[cnt] == pos) continue; for(Rint rrS = rS ^ (rS &amp; (-rS)), i = rrS &amp; (-rrS); i; rrS ^= i, i = rrS &amp; (-rrS))&#123; res += (t[T] * cnt - g[T][loog[i]]) * (loog[i] - pos); &#125; f[S] += res + f[T]; for(Rint rT = T, i = T &amp; (-T); i; rT ^= i, i = rT &amp; (-rT))&#123; g[S][loog[i]] += g[T][loog[i]]; &#125; g[S][pos] += t[T] * cnt; t[S] += t[T]; &#125; &#125; printf("%lld\n", f[U]);&#125;int main()&#123; U = 65535; FOR(i, 1, U) count_[i] = count_[i &gt;&gt; 1] + (i &amp; 1), loog[i] = loog[i &gt;&gt; 1] + 1; Rint esac = read(); while(esac --) Summer_Pockets(); return 0;&#125; CometOJ 其实有很多高质量题目，比如状压 dp 就还有「Comet#1C」,「Comet#4F」。等我不咕了一定把「Comet#4F」肝出来。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF750G」New Year and Binary Tree Paths]]></title>
    <url>%2Fblog%2FCF750G%2F</url>
    <content type="text"><![CDATA[这题听了几遍还没听懂，结果对着 nantf 的代码爆抄才大概懂了这题在搞什么。 [CF 750G] 题意简述一棵无限的满二叉树，根节点为 $1$ ，节点 $x$ 的左儿子是 $2x$ ，右儿子是 $2x+1$ 。给定一个正整数 $n$ ，询问这棵满二叉树上有多少条简单链，使得链上所有点之和，即链的权值为 $n$ 。 $1\le n\le 10^{15}$ 。 主要思路发现可以将满足条件的链分为 $\text{LCA}$ 是链的端点的（单链）和不是的（双链），分别考虑。 单链考虑从 $x$ 往左儿子走 $h$ 步。此时链权值为 $x(2^h - 1)$ 。 若倒数第 $i$ 步走了右儿子，权值将增加 $2^i - 1$ 。 所以 $x$ 往下形成的长为 $h$ 的链中，设倒数第 $i,i\in T$ 步走向了右儿子，这样一条单链就可以表示成 $(h, T)$ 的形式。 则最后链的权值为：$$x(2^h - 1) + \sum\limits_{i\in T} 2^i - |T|$$ 令 $L=\lfloor\dfrac{n}{2^h - 1}\rfloor$ ，显然有 $|T|&lt; h \le \log_2(n+1) , x \le L$ 。 又 $(L - 1)(2^h - 1) + \sum\limits_{i\in T}2^i - |T| \le n - (2^h - 1) + (2^h - h - 1) = n - h &lt; n$ ，所以 $x &gt; L - 1$ ，即对于给定的 $h$ 有唯一的 $x=L$ ，并且方案数就是关于集合 $T$ 的方程 $L(2^h - 1) + \sum\limits_{i\in T} 2^i - |T| = n$ 的解的个数。发现这个方程最多只有一组解。 双链从 $x$ 的左右儿子出发两条单链，类似上面设这两条单链表示为 $(h_0, T_0), (h_1, T_1)$ 。 此时，这条 $\text{LCA}$ 为 $x$ 的双链的权值和为：$$\begin{aligned}&amp;x + 2x(2^{h_0} - 1) + (2x+1)(2^{h_1} - 1) +\sum\limits_{i\in T_0} 2^i +\sum\limits_{i\in T_1}2^i-|T_0|-|T_1|\\&amp;=x(2^{h_0 + 1} + 2^{h_1 + 1} - 3) + 2^{h_1} - 1 + \sum\limits_{i\in T_0} 2^i +\sum\limits_{i\in T_1} 2^i-|T_0|-|T_1|=n\end{aligned}$$ 类似单链时的推论，发现 $h_0,h_1$ 确定时有唯一的 $x=\lfloor\dfrac{n-2^{h_1}+1}{2^{h_0+1}+2^{h_1+1}-3}\rfloor$ 。 此时，问题转化为了在 $2^1,2^2,\dots,2^{h_0-1},2^1,2^2,\dots,2^{h_1-1}$ 中一共选取 $cnt$ 个数，和为 $n - x(2^{h_0 + 1} + 2^{h_1 + 1} - 3) - 2^{h_1} + 1 + cnt$ 的方案数。 考虑枚举 $cnt$ ，设 $f(i,j,0/1)$ 表示枚举完前 $i$ 个指数 ( $2^1,2^2,\dots,2^i$ ) 后，已经选了 $j$ 个数字，二进制下 $i+1$ 是否进位的方案数。 $f(0,0,0) = 1$ 。 dp 过程大概就是枚举两边的单链走左儿子还是右儿子，然后保证上一位和需要凑出的和相同之类的，详见代码。 在枚举了 $h_0,h_1,cnt$ 的情况下，答案就是 $f(max(h_0,h_1),cnt,0)$ 。 可以得出时间复杂度是 $O(\log_2^5n)$ 。 参考代码基本爆抄的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline LL read()&#123; reg LL ans=0,f=1;reg char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=ans*10+c-'0'; return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, MX = 50; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;LL n, f[60][120][2];//inline int count1(LL x)&#123; return x ? count1(x &amp; (x - 1)) + 1 : 0; &#125;#define count1(x) (__builtin_popcountll(x))inline LL work1()&#123; reg LL ans = 0, x, res; FOR(i, 1, MX)&#123; x = n / ((1ll &lt;&lt; i) - 1); if(!x) break; res = n - x * ((1ll &lt;&lt; i) - 1); FOR(j, 0, i - 1) if( !((res + j) &amp; 1) &amp;&amp; count1(res + j) == j) ++ans; &#125; return ans;&#125;inline LL work2()&#123; reg LL ans = 0, x, res; FOR(l, 2, MX) FOR(r, 2, MX)&#123; x = (n - (1ll &lt;&lt; (r - 1)) + 1) / ((1ll &lt;&lt; r) + (1ll &lt;&lt; l) - 3); if(!x) break; res = n - (1ll &lt;&lt; (r - 1)) + 1 - x * ((1ll &lt;&lt; r) + (1ll &lt;&lt; l) - 3); FOR(cnt, 0, l + r - 4) if(!((res + cnt) &amp; 1))&#123; FOR(i, 0, max(l, r)) FOR(j, 0, min(cnt, i &lt;&lt; 1)) f[i][j][0] = f[i][j][1] = 0; f[0][0][0] = 1; FOR(i, 1, max(l, r)) FOR(j, 0, min(cnt, (i - 1) &lt;&lt; 1))&#123; FOR(k, 0, 1) FOR(a, 0, 1) FOR(b, 0, 1)&#123; if(i &gt;= l - 1 &amp;&amp; a) continue; if(i &gt;= r - 1 &amp;&amp; b) continue; if( ((k + a + b) &amp; 1) == (((res + cnt) &gt;&gt; i) &amp; 1) )&#123; f[i][j + a + b][(k + a + b) &gt;&gt; 1] += f[i - 1][j][k]; &#125; &#125; &#125; ans += f[max(l, r)][cnt][0]; &#125; &#125; return ans;&#125;int main()&#123; n = read(); return printf("%lld\n", work1() + work2()), 0;&#125; 参考资料nosta 的 blog Kelin 的 blog nantf 的代码]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>猜结论</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF715D」Create a Maze]]></title>
    <url>%2Fblog%2FCF715D%2F</url>
    <content type="text"><![CDATA[神仙构造题不是人能场上做出来的…… [CF 715D] 题意简述一个四联通的 $n\times m$ 的迷宫，相邻的两个位置之间可能有墙阻隔使得这两个位置不能直接互达，一共有 $k$ 堵墙。从 $(1,1)$ 进入迷宫，而出口是 $(n,m)$ ，假设现在在 $(x,y)$ ，下一步只能走到 $(x + 1,y)$ 或 $(x,y + 1)$ ，当然不能走出迷宫且下一步走到的位置和现在位置之间不能有墙。通过一些计算，得出从入口 $(1,1)$ 走到 $(n,m)$ 共有 $T$ 种走法。 现在给出 $T$ ， $1\le T\le 10^{18}$ ，希望你构造出一个迷宫，使得从入口 $(1,1)$ 走到 $(n,m)$ 共有 $T$ 中走法，限制 $1\le n,m\le 50, 0\le k\le 300$ 。 主要思路考虑在 $(x,y)$ 时答案是 $T$ 。发现可以简单地在 $(x+1,y+1)$ 获得 $2T$ 。 如何将 $T$ 变为 $2T + 1$ ？考虑将上方开一小口，将一个 $1$ 引入。 如何保证引入的是 $1$ ？ 发现只需要保证红圈位置的为 $1$ 即可，所以可以在外面建墙。 那么初始的状态如何生成呢？如图，左上角为 $(1,1)$ 。 这样，可以将 $T$ 转换成二进制数，就可以得到 $T &lt; 2^{50}$ 的做法了。 然而题目要求做到 $T \le 10^{18}$ ，如何解决？ 发现可以在 $(x+2,y+2)$ 获得 $6T$ ，而 $6 &gt; 2^2$ ，看起来就可以将 $n,m$ 卡进 $50$ 以内。 但是我们同时要便于获得 $6T + i$ ( $1\le i \le 5$ )。 发现在引入 $1$ 的情况下，若不建图中的蓝墙，不建一堵墙会增加 $3$ 种方案；不建图中的红墙，不建一堵墙会增加 $1$ 种方案。如此就可以将 $T$ 转换成六进制做了。 同时为了保证引入的是 $1$ ，可以如图所示在外围建墙。此时，计算最大的 $n,m,k$ ，发现都可以卡进限制范围内。 初始状态同二进制做法。 参考代码代码写起来特别难受…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline LL read()&#123; reg LL ans=0,f=1;reg char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=ans*10+c-'0'; return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, K = 310, N = 55; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;LL T;struct Wall&#123; int x, y, xx, yy;//x &lt;= xx, y &lt;= yy&#125;Q[K];int top, a[N], acnt;int main()&#123; T = read(); while(T)&#123; a[acnt++] = T % 6; T /= 6; &#125; FOR(i, 0, (acnt - 1) &gt;&gt; 1) swap(a[i], a[acnt - 1 - i]); Rint n = 2; Q[top++] = (Wall)&#123; 1, 2, 2, 2 &#125;, Q[top++] = (Wall)&#123; 2, 1, 2, 2 &#125;; FOR(i, 0, acnt - 1)&#123; if(n &gt; 2)&#123; Q[top++] = (Wall)&#123; n - 2, n + 2, n - 1, n + 2 &#125;, Q[top++] = (Wall)&#123; n + 2, n - 2, n + 2, n - 1 &#125;; if(i != acnt - 1)&#123; Q[top++] = (Wall)&#123; n - 2, n + 3, n - 1, n + 3 &#125;, Q[top++] = (Wall)&#123; n + 3, n - 2, n + 3, n - 1 &#125;; &#125; &#125; if(i != acnt - 1)&#123; Q[top++] = (Wall)&#123; n, n + 2, n, n + 3 &#125;, Q[top++] = (Wall)&#123; n + 1, n + 2, n + 1, n + 3 &#125;; Q[top++] = (Wall)&#123; n + 2, n, n + 3, n &#125;, Q[top++] = (Wall)&#123; n + 2, n + 1, n + 3, n + 1 &#125;; &#125; switch(a[i])&#123; case 0 :&#123; Q[top++] = (Wall)&#123; n - 1, n + 1, n, n + 1 &#125;, Q[top++] = (Wall)&#123; n - 1, n + 2, n, n + 2 &#125;; Q[top++] = (Wall)&#123; n + 1, n - 1, n + 1, n &#125;, Q[top++] = (Wall)&#123; n + 2, n - 1, n + 2, n &#125;; break; &#125; case 1 :&#123; Q[top++] = (Wall)&#123; n - 1, n + 1, n, n + 1 &#125;; Q[top++] = (Wall)&#123; n + 1, n - 1, n + 1, n &#125;, Q[top++] = (Wall)&#123; n + 2, n - 1, n + 2, n &#125;; break; &#125; case 2 :&#123; Q[top++] = (Wall)&#123; n - 1, n + 1, n, n + 1 &#125;; Q[top++] = (Wall)&#123; n + 1, n - 1, n + 1, n &#125;; break; &#125; case 3 :&#123; Q[top++] = (Wall)&#123; n - 1, n + 2, n, n + 2 &#125;; Q[top++] = (Wall)&#123; n + 1, n - 1, n + 1, n &#125;, Q[top++] = (Wall)&#123; n + 2, n - 1, n + 2, n &#125;; break; &#125; case 4 :&#123; Q[top++] = (Wall)&#123; n + 1, n - 1, n + 1, n &#125;, Q[top++] = (Wall)&#123; n + 2, n - 1, n + 2, n &#125;; break; &#125; case 5 :&#123; Q[top++] = (Wall)&#123; n + 1, n - 1, n + 1, n &#125;; break; &#125; &#125; n += 2; &#125; printf("%d %d %d\n", n, n, top); FORit(Wall, Q, i, 0, top - 1)&#123; printf("%d %d %d %d\n", i-&gt;x, i-&gt;y, i-&gt;xx, i-&gt;yy); &#125; return 0;&#125; 其他解法 如图，可以将 $T$ 转化为三进制做，一位是几就把那一位对应的几面墙打开，外面的墙是用于将答案引至最终点的。 据说这样更好写？]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2019」连续子序列]]></title>
    <url>%2Fblog%2FSDOI2019-%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[一道神仙题，场上只想到一半不到…… [LOJ 3115] [Luogu 5362] 题意简述$\text{Thue−Morse}$ 序列是一个无限长度的序列 $\left\langle T_n\right\rangle$ ： $T_0 = 0$ ； $T_{2n} = T_n$ ； $T_{2n + 1} = 1 - T_n$ 。( $n &gt; 0$ ) 显然这是一个 $\text{01}$ 序列。现在给定一个 $01$ 序列 $S$ 和一个非负整数 $k$ ，求 $\text{Thue-Morse}$ 序列中有多少本质不同的连续子序列 $T$ 满足： $S$ 是 $T$ 前缀； $|T| = |S| + k$ ，其中 $|x|$ 表示 $\text{02}$ 序列 $x$ 的长度。 数据组数 $case \le 100$ ， $|S| \le 100$ ， $0\le k\le 10^{18}$ ，答案模 $10^9+9$ 。 主要思路据说 $\text{Thue-Morse}$ 序列被出到过很多找规律题里？然而本人才第一次见，充分说明本人刷题量还大大不足…… 由于这个序列是个 $\text{01}$ 序列，所以下文可能会把这个序列当成一个 $\text{01}$ 字符串。 关于 $\text{Thue-Morse}$ 序列的性质以下简称 $\text{Thue-Morse}$ 为 $\text{T.M.}$ 。 场上通过手玩样例和瞪这个序列，不难发现几个性质： 每次这个序列会将上一次生成的子串中， 1 变为 10 ， 0 变为 01 ，接入总串尾部，这我们称为一次生成。例如，一开始的串是 01 ，上一次生成的串是 1 。接着，这个串会以此变成 0110 , 01101001 , 0110100110010110 …… 除了 000 与 111 之外，其他长度不大于 $3$ 的 $\text{01}$ 字符串都是 $\text{T.M.}$ 串的子串。同时，如果一个串 $s$ 中有至少三个 1 或 0 相连，那么这个串不可能是 $\text{T.M.}$ 的子串。 对于一个长度大于 $3$ 的串 $s$ ，如果其是 $\text{T.M.}$ 串的子串，它必然是由一长度为 $\lceil\dfrac{n}{2}\rceil$ 或 $\lceil\dfrac{n + 1}{2}\rceil$ 的 $\text{T.M.}$ 串的子串 $t$ 生成的。发现并不用考虑 $t$ 是不是一次生成了 $s$ ，因为即使 $t$ 并不是一次就生成了 $s$ ，生成的 $s$ 也会是连续的。 对于上面的第三条，考虑如何通过 $s$ 反推回 $t$ 。大概思路就是将 01 写为 0 ，将 10 写为 1 ，适当在串前后补字符。 看几个例子： 011001 是如何生成的？显然这个串可以通过 010 生成。 001100 是如何生成的？考虑 1010 可以生成 10011001 ，可得 001100 也是由 1010 生成的。 10010 是如何生成的？和上面的串思路差不多，发现是由 100 生成的。 10110 是如何生成的？也和上面的串思路差不多，发现是由 001 生成的。 0011001100 是如何生成的？沿着刚刚的思路推，发现是由 101010 生成的。而 101010 是由 111 生成的。由于 111 不是 $\text{T.M.}$ 串的子串，所以 0011001100 不是 $\text{T.M.}$ 串的子串。 通过上面的几个例子，又可以大致看出一个结论： 对于一个长度大于 $3$ 的串 $s$ ，如果其是 $\text{T.M.}$ 串的子串，它必然是由且仅可能由一长度为 $\lceil\dfrac{n}{2}\rceil$ 或 $\lceil\dfrac{n + 1}{2}\rceil$ 的 $\text{T.M.}$ 串的子串 $t$ 生成的。即不可能通过两个不同的串生成出相同的串。 如何证明？ 如果串 $s$ 有子串 00 或子串 11 ，因为 0 和 1 生成一次产生的串不能是 00 或 11 ，若 $s$ 是 $\text{T.M.}$ 串的子串则 $s$ 只有一种生成方式。 如果串 $s$ 无子串 00 或子串 11 ： 若长度大于 $4$ ，则可以由 0...0 （或 1...1） 生成，但由于长度大于 $4$ ，所以 0 （或 1） 的数量不小于 $3$ ，该串不在 $\text{T.M.}$ 串中。 若长度等于 $4$ ，则 0101 由 00 、 1010 由 11 构成。 所以我们终于得出了这题最重要的一个结论。 利用该结论 dp考虑 $dp(k)$ 为，一个长为 $1$ 的 $\text{01}$ 字符串后任意插入一个长为 $k$ 的后缀，这个串是 $\text{T.M.}$ 的子串的总数。 发现这个串 $1$ 开始是 0 或是 1 答案是相同的。下文钦定这个长为 $1$ 的字符串从 0 开始。 由于这个串一定是由唯一的 $t$ 串生成的，考虑像上文一般寻找这个 $t$ 串。 如果不在串前补 1 ，则 $t$ 串是从 0 开始的一个串，后接了长度是 $\lceil\dfrac{k - 1}{2}\rceil$ 的任意后缀，即有 $dp(\lceil\dfrac{k - 1}{2}\rceil)$ 种串在 $\text{T.M.}$ 串内；如果在串前补 1 ，则 $t$ 串是从 1 开始的一个串，同理可得有 $dp(\lceil\dfrac{k}{2}\rceil)$ 种 $t$ 串。故得到 $dp(k) = dp(\lceil\dfrac{k - 1}{2}\rceil) + dp(\lceil\dfrac{k}{2}\rceil)$ 。 考虑边界状态。显然，若 $k&lt;3$ 可以预处理出来。$dp(0) = 1, dp(1) = 2, dp(2) = 3$ 。（由于不能是 000 所以 $dp(2) = 3$ ） 最后推得答案设 $Calc(S,k)$ 是询问串为 $S$ ，后缀长度为 $k$ 的答案。 类似 $|S| = 1$ 的询问，可以先确定 $S$ 串是由什么串生成而来的。同样类似 $|S| = 1$ 的询问讨论 $k$ 的取值，注意细节即可。 复杂度没仔细分析……大概一个询问是 $O(|S| + \log_2k)$ 左右？ 参考代码其实代码挺短的，但是为啥把同步关了之后在洛谷 MLE ，在 LOJ RE …… 然而即使没关同步也跑得飞快。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef unsigned long long uLL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline LL read()&#123; reg LL ans=0,f=1;reg char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=ans*10+c-'0'; return f?ans:-ans; &#125; Templ(_Tp) inline void write(_Tp x)&#123; if(x &lt; 0) return (void)(putchar('-'), write(-x)); if(x &lt; 10) return void(putchar( int(x) ^ 48 )); return (void)(write(x / 10), putchar( int(x % 10) ^ 48 )); &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 1000000009; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;#define rsiz(x) (int)(x.size())map&lt;LL, int&gt; dp;inline int moded_add(int a, int b)&#123; return (a += b) &gt;= mod ? a -= mod : a; &#125;int Function(LL k)&#123; if(dp[k]) return dp[k]; if(k &lt; 3) return k + 1; return (dp[k] = moded_add(Function(k &gt;&gt; 1), Function((k + 1) &gt;&gt; 1)));&#125;inline int Generate(const string &amp;S, string &amp;T)&#123;//判断 S 串是否能被生成并反推得可生成 S 串的 T 串 T.clear(); for(Rint i = 0, ed_i = rsiz(S); i &lt; ed_i; i += 2)&#123; if(i + 1 == ed_i) T += (S[i] == '0') ? "0" : "1"; else&#123; if(int(S[i]) ^ int(S[i + 1])) T += (S[i] == '0') ? "0" : "1"; else return 0; &#125; &#125; return 1;&#125;int Calc(const string &amp;S, const LL &amp;k)&#123; Rint siz = rsiz(S); if(siz == 1) return Function(k); if(siz == 2 &amp;&amp; k &lt; 2) return k == 1 ? (S[0] == S[1] ? 1 : 2) : 1; if(siz == 3 &amp;&amp; k == 0) return S[0] != S[1] || S[1] != S[2]; string T; Rint res = 0; if(Generate(S, T))&#123; inc(res, Calc(T, (k + (!(siz &amp; 1))) &gt;&gt; 1)); &#125; if(Generate((S[0] == '0' ? "1" : "0") + S, T))&#123; inc(res, Calc(T, (k + (siz &amp; 1)) &gt;&gt; 1)); &#125;//缩串，注意处理后缀串长度 return res;&#125;inline void sdoi_work()&#123; string S; LL k; cin &gt;&gt; S &gt;&gt; k; write(Calc(S, k)), putchar('\n');&#125;int main()&#123;// ios::sync_with_stdio(false); Rint sdoi_2019_score = read(); while(sdoi_2019_score --) sdoi_work(); return 0;&#125; 参考资料zxyoi_dreamer 的 blog]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>猜结论</tag>
        <tag>dp</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「雅礼集训2018Day2」颜色]]></title>
    <url>%2Fblog%2F%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD2018Day2%E3%80%8D%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[所以这个题场上没写出来就是完全蠢了吧…… 而且为啥加了各种优化还是跑不过最优解…… [LOJ 6499] 题意简述给定一个长 $n$ 的整数序列， $m$ 次询问，每次给定 $k_i$ 个区间 $[i_{i,j},r_{i,j}]$ ，求这些区间中一共出现了多少种不同的数字。 部分数据强制在线。 $1\le n,m,a_i,\sum k_i\le 10^5$ 。 ML : 8MiB, TL : 1000ms. 主要思路对序列分块。设分成 $K$ 块。 考虑如何记录答案。一个比较显然的想法是对每个块记录一个 bitset 来表示这个块有哪些数，询问就暴力把所有块或起来。 这样做出一个总时间复杂度 $O(n(\dfrac{nK}{\omega}+\dfrac{n}{K}))$ ，空间复杂度 $O(K\dfrac{n}{\omega})$ 的垃圾，然后跑得比暴力还慢。 然后发现可以用 $K^2$ 个 bitset 来维护两个块之间有哪些数，时间复杂度 $O(\dfrac{n^2}{K})$ 但是空间 $O(K^2\dfrac{n}{\omega})$ 。发现如果这样 $K$ 只能开几十，然后也跑得慢得一批。 考虑如何保持快速求出两个块之间答案的同时减少需要的空间。接下来就是本题最神仙的思路：可以使用一个ST表来维护两个块之间的答案。 这样总时间复杂度变为 $O(n(\dfrac{n}{\omega}+\dfrac{n}{K}))$ ，空间复杂度降至 $O(\dfrac{n}{\omega}\times K\log_2 K)$ ， $K$ 可以开到一百，手写个 bitset 大概就能过了。 参考代码主要有两个优化： 首先， $k_i$ 个区间先排个序，然后取并集，再把并集分成互不相交的若干个区间来做，具体详见代码。 其次，可以把序列中只出现一次的数丢出来做一个前缀和，不加到 bitset 里，询问一个区间把前缀和直接加到答案。这样 bitset 的长度减小到原来的 $\dfrac{1}{2}$ 。 代码可读性极差 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#define __AVX__ 1#define __AVX2__ 1#define __SSE__ 1#define __SSE2__ 1#define __SSE2_MATH__ 1#define __SSE3__ 1#define __SSE4_1__ 1#define __SSE4_2__ 1#define __SSE_MATH__ 1#define __SSSE3__ 1// #pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")//神奇优化 #include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef unsigned long long uLL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; Rint ans=0,f=1;reg char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=ans*10+c-'0'; return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 100010, MX = 100000, BC = 145, ToT = 782; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;struct my_bitset&#123; uLL val[ToT]; inline void operator |= (const my_bitset &amp;A)&#123; FOR(i, 0, ToT - 1) val[i] |= A.val[i]; &#125; inline my_bitset operator | (const my_bitset &amp;A)const&#123; my_bitset res; FOR(i, 0, ToT - 1) res.val[i] = val[i] | A.val[i]; return res; &#125; inline void set(int k)&#123; val[k &gt;&gt; 6] |= (1ull &lt;&lt; (k &amp; 63)); &#125; inline void reset()&#123; FOR(i, 0, ToT - 1) val[i] = 0; &#125; inline int count()&#123; Rint res = 0; FOR(i, 0, ToT - 1) res += __builtin_popcountll(val[i]); return res; &#125;&#125;st[BC][8], ans;//手写 bitset int n, m, datatype, a[N], bl[N], loog[BC], blo, bcnt, cnt[N], real_num[N], rcnt, S[N];int Blo_L[BC], Blo_R[BC];struct Query&#123; int l, r; inline bool operator &lt; (const Query &amp;A)const&#123; return r == A.r ? l &lt; A.l : r &lt; A.r ; &#125;&#125;Q[N], RQ[N], *rtop;int main()&#123; Rint lastans = 0; n = read(), m = read(), datatype = read(), blo = ceil(n / 140.0); Rint cb = 1, qk; FOR(i, 1, n) cnt[a[i] = read()]++; FOR(i, 1, MX) real_num[i] = cnt[i] &gt; 1 ? rcnt++ : -1; FOR(i, 1, n)&#123; S[i] = S[i - 1] + (cnt[ a[i] ] == 1); a[i] = real_num[ a[i] ]; bl[i] = (i % blo) ? cb : cb++; if(a[i] != -1) st[ bl[i] ][0].set(a[i]); &#125; //把数量是 1 的数扔出来搞个前缀和 bcnt = bl[n], cb = -1; FOR(i, 1, bcnt)&#123; Blo_L[i] = (i - 1) * blo + 1; Blo_R[i] = (i == bcnt) ? n : i * blo ; if(i == 1) continue; loog[i] = loog[i &gt;&gt; 1] + 1; &#125; FOR(i, 1, loog[bcnt])&#123; FOR(j, 1, bcnt - (1 &lt;&lt; i) + 1) st[j][i] = st[j][i - 1] | st[j + (1 &lt;&lt; (i - 1))][i - 1]; &#125; FOR(qry, 1, m)&#123; ans.reset(), qk = read(); FORit(Query, Q, i, 0, qk - 1)&#123; i-&gt;l = read(), i-&gt;r = read(); if(datatype &amp;&amp; qry &gt; 1)&#123; i-&gt;l = (i-&gt;l ^ lastans) % n + 1, i-&gt;r = (i-&gt;r ^ lastans) % n + 1; if(i-&gt;l &gt; i-&gt;r) swap(i-&gt;l, i-&gt;r); &#125; &#125; if(qk &gt; 1) sort(Q, Q + qk); *(rtop = RQ) = Q[0]; FORit(Query, Q, i, 1, qk - 1)&#123; if(rtop-&gt;r == i-&gt;r &amp;&amp; rtop-&gt;l &lt;= i-&gt;l) continue; while(rtop != RQ - 1 &amp;&amp; rtop-&gt;l &gt;= i-&gt;l) --rtop; if(rtop != RQ - 1 &amp;&amp; rtop-&gt;r &gt;= i-&gt;l) rtop-&gt;r = i-&gt;r; else *(++rtop) = *i; &#125;//把 k 个区间排序再把这些区间的并分为不交的区间 Rint l, r, lb, rb, k_k; lastans = 0; FORit(Query, 0, i, RQ, rtop)&#123; l = i-&gt;l, r = i-&gt;r, lb = bl[l], rb = bl[r]; lastans += S[r] - S[l - 1]; if(lb == rb)&#123; FOR(i, l, r) if(a[i] != -1) ans.set(a[i]); &#125; else&#123; FOR(i, l, Blo_R[lb]) if(a[i] != -1) ans.set(a[i]); FOR(i, Blo_L[rb], r) if(a[i] != -1) ans.set(a[i]); k_k = loog[rb - lb - 1]; if(lb + 1 &lt;= rb - 1) ans |= st[lb + 1][k_k] | st[rb - (1 &lt;&lt; k_k)][k_k]; &#125; &#125; printf("%d\n", lastans += ans.count()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>卡常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zory的n0ip模拟赛题解]]></title>
    <url>%2Fblog%2FZory%E7%9A%84n0ip%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在这里必须吐槽一下组题人和出题人的语文水平……愣是把这场打成了语文场…… 「CEOI2019」Cubeword (D1T3)[LOJ 3164] [CF 1192C] 居然这个题是完全机翻的……怪不得难以理解…… 题意简述给定 $n$ 个互不相同的有意义的单词( $1\le n\le 10^5$ )，每个单词都是一个长度在 $[3,10]$ 间的字符串，单词中包含小写的a到z，大写的A到Z，数字0到9。 然后，你选定正方体的棱长 $a$ ，建立一个有 $a^3$ 单位的立方体。你要在这个大正方体的 $12$ 条边上的所有单位正方体上填上一个字母（这里字母的定义是小写的a到z，大写的A到Z，数字0到9）。边上的所有单位立方体填上字母后，每条边都必须是一个有意义的长度为 $a$ 的单词。每条边可以双向阅读，即只要从一个方向读起来是有意义的单词即可。 例如上图就是 $a=6$ 时，只填了 $3$ 条边时的情况。此时已填的三条边分别可以看出单词SUBMIT(或TIMBUS)、ACCEPT(或TPECCA)、TURING(或GNIRUT)。 如果一个立方体可以通过旋转或镜像变成另一个立方体，则认为这两个立方体是不同的。 主要思路以 $S$ 表示字符集。考虑如何处理长度为 $len$ 的单词。 当一个顶点所在的三条棱的另一端的顶点都已经确定填什么字母时，显然这三条棱的填法种类是固定的。这里使用 $f(i_1,i_2,i_3)$ 来描述。显然处理单个 $f(i_1,i_2,i_3)$ 的复杂度是 $O(|S|)$ 。 枚举正方体四个互不相邻的顶点该位置填什么字母。设这四个顶点分别填 $i_1,i_2,i_3,i_4$ ，则此时整个正方体满足要求的方案数是 $f(i_1,i_2,i_3)\times f(i_2,i_3,i_4) \times f(i_3,i_4,i_1) \times f(i_4,i_1,i_2)$ 。则最终的答案就是$$\sum\limits_{i_1\in S}\sum\limits_{i_2\in S}\sum\limits_{i_3\in S}\sum\limits_{i_4\in S} f(i_1,i_2,i_3)\times f(i_2,i_3,i_4) \times f(i_3,i_4,i_1) \times f(i_4,i_1,i_2)$$ 此时总时间复杂度是 $O(8 \times |S|^4)$ ，据说会被卡常。 考虑处理答案时可以钦定 $i_1\le i_2\le i_3\le i_4$ ，处理 $f(i_1,i_2,i_3)$ 时可以钦定 $i_1\le i_2\le i_3$ 。如此常数减小，完全可过。 注意最后求答案时需要处理 $i_1,i_2,i_3,i_4$ 的出现次数。 参考代码字符串正反去重处理使用了hash。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; Rint ans=0,f=1;reg char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=ans*10+c-'0'; return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 0x3B800001 , N = 100010; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;template &lt;typename Tp&gt; inline Tp mul_(Tp t)&#123; return t; &#125;template &lt;typename Tp,typename... Args&gt; inline Tp mul_(Tp t, Args ...args)&#123; return 1ll * t * mul_(args...) % mod; &#125;const LL mod1 = 0x3B800001 , mod2 = 0x3BE00001;const int board[2][2][2] = &#123; &#123; &#123;24 , 12&#125; , &#123;12 , 4&#125; &#125; , &#123; &#123;12 , 6&#125; , &#123;4 , 1&#125; &#125; &#125;;int n , cnt[62][62] , tot[62][62][62] , ans;char str[N][13] , len[N] , rev[N];map&lt;PII,int&gt; map_;inline int chg_chr(char csp)&#123; if(isdigit(csp)) return csp - '0'; if('a' &lt;= csp &amp;&amp; csp &lt;= 'z') return csp - 'a' + 10; return csp - 'A' + 36;&#125;inline void add_str(int x)&#123; reg LL tme1 = 0,tme2 = 0; FOR(i,0,len[x] - 1) (tme1 = tme1 * 233 + str[x][i]) %= mod1 , (tme2 = tme2 * 233 + str[x][i]) %= mod2; reg PII pr = MP(int(tme1),int(tme2)); if(map_[pr]) return; map_[pr] = 1; cnt[chg_chr(str[x][0])][chg_chr(str[x][len[x] - 1])] ++; if(!rev[x])&#123; tme1 = 0 , tme2 = 0; ROF(i,len[x] - 1,0) (tme1 = tme1 * 233 + str[x][i]) %= mod1 , (tme2 = tme2 * 233 + str[x][i]) %= mod2; pr = MP(int(tme1),int(tme2)); map_[pr] = 1; cnt[chg_chr(str[x][len[x] - 1])][chg_chr(str[x][0])] ++; &#125; return;&#125;inline void work_len(int now_len)&#123; MEM(cnt , 0) , MEM(tot , 0) , map_.clear(); FOR(i,1,n) if(len[i] == now_len) add_str(i); FOR(i1,0,61) FOR(i2,i1,61) FOR(i3,i2,61) FOR(i4,0,61)&#123; inc(tot[i1][i2][i3] , mul_(cnt[i1][i4],cnt[i2][i4],cnt[i3][i4]) ); &#125; Rint pre; FOR(i1,0,61) FOR(i2,i1,61) FOR(i3,i2,61) FOR(i4,i3,61)&#123; pre = mul_(tot[i1][i2][i3] , tot[i1][i2][i4] , tot[i1][i3][i4] , tot[i2][i3][i4]); inc(ans , 1ll * pre * board[i1 == i2][i2 == i3][i3 == i4] % mod); &#125;&#125;int main()&#123; n = read(); FOR(i,1,n)&#123; scanf("%s",str[i]); len[i] = strlen(str[i]); rev[i] = 1; FOR(j,0,len[i] - 1) if(str[i][j] != str[i][len[i] - 1 - j])&#123; rev[i] = 0; break; &#125; &#125; FOR(now_len,3,10) work_len(now_len); return printf("%d\n",ans),0;&#125; 「LOJ 6364」烂柯[LOJ 6364] 居然是原创题，然而还是很难懂…… 题意简述给定一棵 $n$ 个节点的树，其中 $m$ 个节点上有柿子。在这棵树上进行博弈。双方轮流操作，每次选择一个有柿子的节点，将上面至少一个柿子移动到相邻节点，或如果这个节点是叶子节点且与开始给定的一个节点 $k$ 的距离是奇数，将上面至少一个柿子删除。每个柿子都不能移动到该柿子曾经位于的节点上。最后不能操作的人就输了。 给出树的形态和开始 $m$ 个节点上柿子的位置及个数，求双方最优策略下先手胜负。 有 $case$ 组数据， $case \le 10,\ n,a_i \le 100,\ m\le 18$ 。 主要思路数据出得如此小，简直考验选手心理。 考虑以 $k$ 为根，能删除柿子的节点是深度为奇数的叶子（深度从 $0$ 开始）。这样，在节点上删柿子可以看作在该节点下挂了一个虚节点，将柿子移动到了该节点。所以当不能移动柿子时，柿子深度均为偶数。 发现每个柿子会被移动次数的奇偶性与深度的奇偶性相同，而游戏显然不能无限进行，因此该游戏和普通阶梯博弈等价。只需将所有距离 $k$ 为奇数的节点的柿子数量异或起来（记为 $cnt$ ）， $cnt &gt; 0$ 就是先手必胜， $cnt = 0$ 就是后手必胜。 代码难度小，不放代码了。 「CF 567F」Mausoleum[CF 567F] Zory说这是签到题，然而本人场上没想出来…… 题意简述一个长为 $2n$ 的数列，其中 $1,2,\dots,n$ 各出现两次，并且是单峰的（先一段不降再一段不升，长度可以为 $0$ ）。并且给出了 $k$ 个限制，要求第 $x_i$ 个位置的数必须 $\mathtt{sign_i}$ 第 $y_i$ 个位置上的数，其中 $\mathtt{sign_i}$ 是等于、大于、小于、大于等于、小于等于中的一种。 求该数列的可能种数。 $n \le 35, k\le 100$ 。 主要思路考虑 $f(l,r)$ 表示 $[l,r]$ 中的位置还没有填数并且峰顶在 $[l,r]$ 中时的方案总数，初始时 $f(0,2n + 1) = 0$ ，我们要求的答案是 $\sum\limits_{i=1}^{2n-1}f(i,i + 1)$ （因为剩下两个 $n$ 只能填在空缺的两个位置）。 $f(l,r)$ 可以转移到 $f(l+1,r+1),f(l+2,r),f(l,r-2)$ ，注意限制，具体实现见代码，大概就是每个位置开一个 $\text{vector}$ 存一下这个位置要等于哪些位置、小于等于哪些位置、小于哪些位置，然后转移时暴力判断。 参考代码细节有点多： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353, N = 120; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;int n, k;LL f[N][N], ans;vector&lt;PII&gt; lim[N];inline int read_sign()&#123; reg char scoi[5]; scanf("%s",scoi); if(scoi[0] == '=') return 0; if(scoi[1] == '=') return scoi[0] == '&lt;' ? -1 : 1; return scoi[0] == '&lt;' ? -2 : 2;&#125;// &lt; &lt;= = &gt;= &gt;//-2 -1 0 1 2inline int check_lim(int l, int r, int x, int y)&#123; Rint xx = (x - 1 &gt; l) ? x - 1 : y + 2 , yy = (y + 1 &lt; r) ? y + 1 : x - 2; Rint opt, pos; for(auto tmp : lim[xx])&#123; opt = tmp.fir, pos = tmp.sec; if(opt == 0 &amp;&amp; pos != xx &amp;&amp; pos != yy) return 0; if(opt == -1 &amp;&amp; (l + 1 &gt; pos || pos &gt; r - 1)) return 0; if(opt == -2 &amp;&amp; (x &gt; pos || pos &gt; y)) return 0; &#125; for(auto tmp : lim[yy])&#123; opt = tmp.fir, pos = tmp.sec; if(opt == 0 &amp;&amp; pos != xx &amp;&amp; pos != yy) return 0; if(opt == -1 &amp;&amp; (l + 1 &gt; pos || pos &gt; r - 1)) return 0; if(opt == -2 &amp;&amp; (x &gt; pos || pos &gt; y)) return 0; &#125; return 1;&#125;int main()&#123; n = read(), k = read(); Rint xx, yy, opt; FOR(i, 1, k)&#123; xx = read(), opt = read_sign(), yy = read(); lim[xx].push_back(MP(opt, yy)), lim[yy].push_back(MP(-opt, xx)); &#125; f[0][n &lt;&lt; 1 | 1] = 1; ROF(i, n, 1) for(Rint l = 0, r; l &lt;= ((n - i) &lt;&lt; 1); ++l)&#123;//i : n -&gt; 1 ; l &lt;= 2 * (n - i) ; r - l = 1 + 2 * i r = (i &lt;&lt; 1 | 1) + l; if(!f[l][r]) continue; if(i == 1)&#123; if(check_lim(l, r, l + 2, r - 2)) ans += f[l][r]; continue; &#125; if(check_lim(l, r, l + 2, r - 2)) f[l + 1][r - 1] += f[l][r]; if(check_lim(l, r, l + 3, r - 1)) f[l + 2][r] += f[l][r]; if(check_lim(l, r, l + 1, r - 3)) f[l][r - 2] += f[l][r]; &#125; printf("%I64d\n",ans); return 0;&#125; 「HDU 5181」numbers[HDU 5181] 实在是搞不懂为什么一个意义简明的题面可以被解释得如此难懂，导致本人在考试结束前 1h 才看懂题面。 题意简述你手上有个栈，你要将 $1,2,\dots,n$ 依次入栈，然后有 $m$ 个限制，限制 $A_i$ 必须早于 $B_i$ 出栈，其余出栈顺序不限。求有多少种合法的进出栈序列。 $case$ 组数据， $case \le 5,n \le 300,m \le 90000$ 。 主要思路我们添加一个数 $0$ ，让 $0$ 在所有数进栈之前进栈，所有数出栈之后出栈。这样进出栈序列可以写成一棵以 $0$ 为根的树，dfs 序为 $0,1,2,\dots,n$ ，每个元素 $x$ 将在自己子树内（除自己）的所有元素进栈前进栈，出栈后出栈。 如果没有限制，显然我们可以设 $dp(x,k)$ 为考虑 $[x,n]$ 的进出栈顺序， $x$ 的子树大小为 $k$ 的种数。枚举 $x$ 除最右子树外其他子树大小和 $t$，则有 $dp(x,k) = \sum\limits_{t=1}^{k-1}dp(x,t)\times dp(x+t,k-t)$ 。 考虑限制 $(A_i,B_i)$ 在这棵数上的意义。 如果 $A_i=B_i$ ，显然直接无解。 如果 $A_i&lt;B_i$ ， $A_i$ 的子树内不能包含 $B_i$ ，即 $A_i$ 的子树大小最大是 $\operatorname{Maxsiz}(A_i)=B_i - A_i$ 。 如果 $A_i&gt;B_i$ ， $B_i$ 的子树内必须包含 $A_i$ ，即 $B_i$ 的子树大小最小是 $\operatorname{Minsiz}(B_i)=A_i - B_i + 1$ 。 仍设 $dp(x,k)$ ，此时 $k\in [\operatorname{Minsiz}(x),\operatorname{Maxsiz}(x)]$ 时才有意义。 由于某个点在挂到别的点上时，子树大小并不改变，所以可以仍如上述方法做 dp ，在处理完 $dp(x,k)$ 后再把无意义的位置设为 $0$ 即可。 复杂度 $O(n^3)$ ，完全可过。 参考代码都9102年了HDU还是不支持万能头…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//#include&lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define MP make_pair typedef long long LL; typedef double DB; typedef pair&lt;int,int&gt; PII; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 1000000007, N = 310; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define PBTXDY&#125;using namespace my_std;int n, m, f[N][N], Mins[N], Maxs[N]/*Min_siz, Max_siz*/;inline void hdu5181()&#123; n = read(), m = read(); Rint flag = 1, xx, yy; FOR(i, 0, n) Mins[i] = 0, Maxs[i] = n + 1; FOR(i, 1, m)&#123; xx = read(), yy = read(); if(xx == yy) flag = 0; else (xx &lt; yy) ? chkmin(Maxs[xx], yy - xx) : chkmax(Mins[yy], xx - yy + 1); &#125; if(!flag) return void(puts("0")); ROF(x, n, 0)&#123; FOR(siz, 1, n + 1) f[x][siz] = 0; f[x][1] = 1; FOR(siz, 2, n - x + 1) FOR(t, 1, siz - 1) inc(f[x][siz], 1ll * f[x][t] * f[x + t][siz - t] % mod); FOR(siz, 1, Mins[x] - 1) f[x][siz] = 0; FOR(siz, Maxs[x] + 1, n + 1) f[x][siz] = 0; &#125; printf("%lld\n", f[0][n + 1]);&#125;int main()&#123; Rint esac = read(); while(esac--) hdu5181(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP-S2019第一轮游记]]></title>
    <url>%2Fblog%2FCSP-S2019%E7%AC%AC%E4%B8%80%E8%BD%AE%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最后一次 NOIP 没写游记，简直亏大了…… 早上八点半不到就到考场了，由于没有熟识的外校同学所以没找人面基（然后被某神仙怼了说初赛面什么基）。 不一会几辆大巴把就读于考场中学的考生直接送进校园内（虽然不能进考室），羡慕就读于考场中学的考生居然可以先进考场。 大概九点才进考场，一堆人拥进考室然后在十分钟后被监考员叫了出去，又过了几分钟才给进，真实今日迷惑。 发卷。居然分AB卷，难道这些鸽子愿意出两套题了？ 九点半还没发完卷……然后答题卡还印错了，开考 45 分钟左右原来的答题卡被收回去了。今年怎么出锅那么多？ 奶了硬件、计算机架构、网络与协议、 NOIP 与 CSP-J/S 关系不考，结果真就没考。 今年最难的居然是看程序写结果……考场上做得头昏。 考试结束前半分钟感觉有道题做错了，刚想改就打铃收卷了。 一出考室发现AB卷题目完全一样，只有选项位置不同。就是，这些鸽子怎么会出两套题呢！ 感觉总体难度比较简单？ 下午对了答案，发现好像最后想改的那道题本来就是对的……]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2018」未来日记]]></title>
    <url>%2Fblog%2FYnoi2018-%E6%9C%AA%E6%9D%A5%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第二道 ynoi ……前前后后不知道写了多久。 Idea：fdy Solution：fdy&amp;lxl Std：lxl&amp;csy Data：lxl “望月悲叹的最初分块” （妈呀这名字好中二啊（谁叫我要用日本轻小说中的东西命名真是作死）） 这个是这个系列中第一个被出出来的题，当时给了多校（然后的确没人做出来耶），然后被搬到了毛营（然后还是没人做出来耶） 这个是我同学出的，不是我出的（当时问我我也不会这题来着），来源似乎是有个 cdqz 高新校区的小朋友看错了一个 cf 题，然后被加强造出来的 这里就直接挂csy的题解了，和我的不太一样，但是大概思路还是差不多的，我的做法是和T1有点类似的维护方法 对这题的评价：8.5/11 —— lxl 博客 [BZOJ 5145] bzoj怎么挂了 [Luogu 4119] [HDU 6079] 我是不是什么时候也该去看看未来日记 题意简述给定一个长 $n$ 的整数序列， $1\le n,m,a_i\le 100000$ ， $m$ 个操作，操作包括： 把区间 $[l,r]$ 中所有 $x$ 变为 $y$ ； 查询区间 $[l,r]$ 中的第 $k$ 小值。 没强制在线，然而好像并没有离线做法。 主要思路首先先分块，对序列与值域都分块。以下均在块长 $O(\sqrt{n})$ 下讨论。 分块无修区间第 k 大先考虑怎么分块做无修区间第 $k$ 大。可以维护两个数组 $C[val][d]$ 表示前 $d$ 块中值为 $val$ 的数的个数， $B[valid][d]$ 表示前 $d$ 块中值在第 $valid$ 个值域块里的数的个数。 询问时维护两个临时数组 $tc[val]$ 与 $tb[valid]$ ，用来处理零碎块的贡献。 然后枚举答案位于哪一个值域块，再在这一个块里暴力枚举答案就可以 $O(\sqrt{n})$ 求出区间第 $k$ 大。 维护修改操作如何实现将 $[l,r]$ 中 $x$ 变为 $y$ 的操作？ 发现 $x$ 变为 $y$ 的操作类似并查集。维护数组 $rt[val][d]$ 表示第 $d$ 块中某个为 $val$ 的数的位置（即任意时刻保证 $a[\ rt[val][d]\ ] = val$ ，若块中无 $val$ 则将 $rt[val][d]$ 设为 $0$）。 再维护并查集数组与函数 $fth[id],find(id)$ ，将第 $d$ 块的值为 $val$ 的数挂到 $rt[val][d]$ 子树上。 此时再来考虑如何实现修改操作。 对于散块，直接将 $x$ 与 $y$ 两棵子树重置。 对于整块 $bid$ ： 如果没有 $x$ ，直接跳了； 如果没有 $y$ ，把 $rt[y][bid]$ 设为 $rt[x][bid]$； 如果有 $y$ ，把 $fth[\ rt[x][bid]\ ]$ 设为 $rt[y][bid]$。 最后把$a[\ rt[x][bid]\ ]$ 设为 $y$ ，把 $rt[x][bid]$ 设为 $0$ ，大概想一下应该可以知道为什么。 还要修改 $C[val][d]$ 与 $B[valid][d]$ ，由于只涉及 $x$ 与 $y$ 这两个值，所以暴力修改这两个数组完全可以承受。 最后修改的时间复杂度就是 $O(\sqrt{n})$ 。 参考代码内存限制 $\text{500MB}$ ，所以块长不能取 $O(\sqrt{n})$ （会爆空间），要稍微开大一点。 记得判 $x$ 与 $y$ 相等的情况，如果不判会莫名挂。 更多细节参考代码。 至于函数名称和大常数就不要在意了…… 又长又丑的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i&lt;=ed_##i;++i) #define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i&gt;=ed_##i;--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; #define Templ(T) template&lt;typename T&gt; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(c&gt;'9'||c&lt;'0')&#123; f^=(c=='-'); c=getchar(); &#125; for(;c&lt;='9'&amp;&amp;c&gt;='0';c=getchar()) ans=ans*10+c-'0'; return f?ans:-ans; &#125; Templ(_Tp) inline int chkmin(_Tp &amp;x,_Tp y)&#123; return x&gt;y?x=y,1:0; &#125; Templ(_Tp) inline int chkmax(_Tp &amp;x,_Tp y)&#123; return x&lt;y?x=y,1:0; &#125; #define using_mod const int mod = 998244353 , N = 100010 , SN = 260 , Vmax = 100000; #ifdef using_mod inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; #endif Templ(_Tp) inline _Tp gcd(_Tp x,_Tp y)&#123; return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;int n,m,a[N],B[SN][SN],C[N][SN],rt[N][SN],fth[N],tb[SN],tc[N];int find(int id)&#123; return fth[id] == id ? id : fth[id] = find(fth[id]) ; &#125;//B[valid][d] : 前 d 块中在值域第 valid 块的数的数量 ; C[val][d] : 前 d 块中值为 val 数的数量 //rt[val][d] : 第 d 块中第一个为 val 的数的位置 ; fth[id] / find(id) : 序号为 id 的位置的并查集数组/函数 const int vblo = 400, vBcnt = 250;int blo,bl[N],vbl[N],Bcnt;//blo , vblo : 块长 / 值域块长 ; Bcnt , vBcnt : 块数 / 值域块数 //bl[i] : 序列中第 i 个数所在块 ; vbl[val] : 权值 val 所在的值域块#define Blo_L(bk) (((bk) - 1) * blo + 1)//块的开头/结尾 #define Blo_R(bk) (min(n , (bk) * blo))#define Vblo_L(bk) (((bk) - 1) * vblo + 1)//值域块的开头/结尾 #define Vblo_R(bk) (min(Vmax , (bk) * vblo))int Q[vblo &lt;&lt; 1] , *Qt = Q;//手开队列, Q 存 tc[val] 有值的 val (便于下次使用时更新) int Tmp[vblo &lt;&lt; 1];//Tmp 暂存修改零散块时, a[i] 值为 x 或 y 的位置 inline void a_upd(int id)&#123; return void(a[id] = a[find(id)]); &#125;//a_upd : 字面意思, 将某个位置的值(可能不是当前值)更新为当前的实际值inline void SBadd(int val)&#123; if(!tc[val]) *(++Qt) = val; ++tc[val]; ++tb[ vbl[val] ]; return;&#125;//SBadd : 零散块(Scattered Block)求 tc[val] 和 tb[valid] 时加入一个值 val inline void CBupd(int bid,int x,int y,int res)&#123; C[x][bid] -= res , C[y][bid] += res; if(vbl[x] != vbl[y]) B[ vbl[x] ][bid] -= res , B[ vbl[y] ][bid] += res; return;&#125;//CBupd : 整块(Completed Block)中修改 C[val][bid] 和 B[valid][bid] (x -&gt; y)inline void SBupd(int bid,int l,int r,int x,int y,int &amp;res)&#123; Rint *top = Tmp; FOR(i,Blo_L(bid),Blo_R(bid))&#123; a_upd(i); if(a[i] == x || a[i] == y) *(top++) = i; &#125;//改 a[i] 和把 x 与 y 子树上的点拿出来 rt[x][bid] = rt[y][bid] = 0;//将这两棵子树重置 for(Rint *i = Tmp;i != top;++i)&#123; if(l &lt;= *i &amp;&amp; *i &lt;= r &amp;&amp; a[*i] == x) a[*i] = y , ++res; if(!rt[ a[*i] ][bid]) rt[ a[*i] ][bid] = *i; fth[ *i ] = rt[ a[*i] ][bid]; &#125;//更新这两棵子树 CBupd(bid,x,y,res); return;&#125;//SBupd : 散块(Scattered Block)修改 inline void update(int l,int r,int x,int y)&#123; if(x == y) return; Rint lb = bl[l] , rb = bl[r] , res = 0; if(lb == rb)&#123; SBupd(lb,l,r,x,y,res); FOR(bid,lb + 1,Bcnt) CBupd(bid,x,y,res);//更新后续的块 return; &#125; SBupd(lb,l,Blo_R(lb),x,y,res); FOR(bid,lb + 1,rb - 1)&#123;//改整块 if(!rt[x][bid])&#123;//块里没有 x CBupd(bid,x,y,res); continue; &#125; if(!rt[y][bid])&#123;//有 x 无 y a[ rt[y][bid] = rt[x][bid] ] = y; &#125; else&#123;//有 x 有 y fth[ rt[x][bid] ] = rt[y][bid]; &#125; res += C[x][bid] - (C[x][bid - 1] + res); rt[x][bid] = 0; CBupd(bid,x,y,res); &#125; SBupd(rb,Blo_L(rb),r,x,y,res); FOR(i,rb + 1,Bcnt) CBupd(i,x,y,res);//更新后续的块 return;&#125;inline int query(int l,int r,int k)&#123; Rint lb = bl[l] , rb = bl[r] , res = 0; Rint val = 1 , lim = vBcnt; FOR(i,1,vBcnt) tb[i] = 0; while(Qt != Q) tc[*(Qt--)] = 0;//清理 tc[val] , tb[valid] if(lb == rb)&#123; FOR(i,l,r) a_upd(i) , SBadd(a[i]); while(res + tb[val] &lt; k &amp;&amp; val &lt;= lim) res += tb[val++]; lim = Vblo_R(val) , val = Vblo_L(val); while(res + tc[val] &lt; k &amp;&amp; val &lt;= lim) res += tc[val++]; return val; &#125; ROF(i,Blo_R(lb),l) a_upd(i) , SBadd(a[i]); FOR(i,Blo_L(rb),r) a_upd(i) , SBadd(a[i]); while(res + tb[val] + B[val][rb - 1] - B[val][lb] &lt; k &amp;&amp; val &lt;= lim)&#123; res += tb[val] + B[val][rb - 1] - B[val][lb] , val++; &#125; lim = Vblo_R(val) , val = Vblo_L(val); while(res + tc[val] + C[val][rb - 1] - C[val][lb] &lt; k &amp;&amp; val &lt;= lim)&#123; res += tc[val] + C[val][rb - 1] - C[val][lb] , val++; &#125; return val;&#125;int main()&#123; n = read() , m = read();// , blo = ceil(sqrt(n)); blo = ceil(pow(n,0.5204)); Rint cb = 1; FOR(i,1,n) a[i] = read() , bl[i] = cb , cb += (!(i % blo));//处理 bl[i] cb = 1; FOR(i,1,Vmax) vbl[i] = cb , cb += (!(i % vblo));//处理 vbl[val] Bcnt = bl[n]; FOR(bid,1,Bcnt)&#123; FOR(val,1,Vmax) C[val][bid] = C[val][bid - 1]; FOR(valid,1,vBcnt) B[valid][bid] = B[valid][bid - 1]; FOR(i,Blo_L(bid),Blo_R(bid))&#123; if(!rt[ a[i] ][bid]) rt[ a[i] ][bid] = i; fth[i] = rt[ a[i] ][bid]; ++B[ vbl[a[i]] ][bid] , ++C[ a[i] ][bid]; &#125; &#125;//求出初始 B[valid][d] , C[val][d] , rt[val][d] , fth[id] Rint sta,ql,qr,qx; FOR(qry,1,m)&#123; sta = read() - 1 , ql = read() , qr = read() , qx = read(); sta ? (void)(printf("%d\n",query(ql,qr,qx))) : (update(ql,qr,qx,read())); &#125; return 0;&#125; 参考资料lxl 原博客 fr200110217102 的博客]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>Ynoi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode配置二三事]]></title>
    <url>%2Fblog%2FVSCode%E9%85%8D%E7%BD%AE%E4%BA%8C%E4%B8%89%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[自从半年前装了 VS Code (下称 VSC ) 以后，只用 VSC 来写一些yml,json,html啥的。从来没有用过来写cpp。 这几天突然心血来潮，在家里配置了一下 VSC ，现在可以在家使用 VSC 写代码了。 环境准备首先将MinGW-w64中bin的位置加入环境变量里的Path里。我个人由于以前都在用 Dev-C++ 所以直接添加了Dev-C++\Dev-Cpp\MinGW64\bin。 添加后就可以在cmd中使用g++ -o test test.cpp之类的命令来编译cpp文件了。 因为要写cpp，故在 VSC 的扩展商店( Extensions )里下载扩展C/C++，这个扩展是官方的C/C++扩展。 然后把User Settings随便改一改就进入正文了。 键盘快捷键等等忘记说快捷键了。 VSC 的快捷键和 Dev-C++ 的不太一样，所以这里指出一些常用快捷键。 编辑器与窗口管理 打开 Ctrl+O 新窗口 Ctrl+Shift+N 新标签页 Ctrl+N 关闭整个 VSC 窗口 Ctrl+Shift+W 关闭当前标签页 Ctrl+W 重新打开刚刚关闭的标签页 Ctrl+Shift+T 切换标签页 Ctrl+Tab 创建一个新编辑器并将当前页面复制过去 Ctrl+\ 在前三个编辑器之间切换 Ctrl+1 2 3 将焦点编辑器移动位置 先按下 Ctrl+K 左下角出现提示后用 ← → 移动 或者可以 Ctrl+Alt+←→ 在标签页之间切换 Alt+1~9 代码编辑 搜索 Ctrl+F 替换 Ctrl+H 复制光标所在行 只需Ctrl+C 去掉行尾空格 Ctrl+K 然后 Ctrl+X 切换行注释 Ctrl+/ 代码缩进 Ctrl+[ 与 Ctrl+] 当前行上下移动 Alt+↑↓ 当前行后插入一行 Ctrl+Enter 当前行前插入一行 Ctrl+Shift+Enter 选中下一行 Ctrl+i 撤销光标上次移动 Ctrl+U 选中下个高亮的匹配项 Ctrl+D 多光标模式 Atl+鼠标单击即可在单击处创建新的光标 速览定义 Alt+F12 转到定义 F12 Zen模式(一个奇怪的类似全屏的模式) Ctrl+K 然后 Z 打开自动保存 Ctrl+Shift+P之后输入AutoSave，选中，按下回车。 打开终端 Ctrl+~ 配置 .json 文件首先我搞了个文件夹做工作区。 在工作区里新建名为.vscode的文件夹，在里面创建launch.json,tasks.json,settings.json三个.json文件。 launch.json由于学疏才浅，这个文件(包括下面的其他文件)基本是直接从参考资料里抄的…… 个人配置： 123456789101112131415161718192021222324252627&#123; "version": "0.2.0", "configurations": [ &#123; "name": "(gdb) Launch", "type": "cppdbg", "request": "launch", "program": "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe", "args": [], "stopAtEntry": false, "cwd": "$&#123;workspaceFolder&#125;", "environment": [], "externalConsole": true, "internalConsoleOptions": "neverOpen", "MIMode": "gdb", "miDebuggerPath": "gdb.exe", "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": false &#125; ], "preLaunchTask": "Compile" &#125; ]&#125; tasks.json个人配置： 123456789101112131415161718192021222324252627282930313233&#123; "version": "2.0.0", "tasks": [ &#123; "label": "Compile", "command": "g++", //本人直接用的 g++ 编译 "args": [ "$&#123;file&#125;", "-o", "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe", //这东西必须要加，不然编译出来全是a.exe "-g", "-Wall", // "-static-libgcc", // "--target=x86_64-w64-mingw", "-std=c++11", //这里用 g++11 会出现不明错误，原因未知 "-O2", "-Wl,--stack=67108864", "-DVSC_Compile", ], "type": "process", "group": &#123; "kind": "build", "isDefault": true &#125;, "presentation": &#123; "echo": true, "reveal": "always", "focus": false, "panel": "shared" &#125; &#125; ]&#125; 至今不明白为什么使用std=g++11指令会不明错误。 setting.json配置了前两个.json文件后已经可以正常F5编译运行工作区的cpp文件了。原因本人未知，或许是因为我用的是g++？ 但是基本所有教程都有配置此文件，故本人也搞了一个。 个人配置： 123456789101112&#123; "files.defaultLanguage": "cpp", "code-runner.executorMap": &#123; "c": "cd $dir &amp;&amp; clang $fileName -o $fileNameWithoutExt.exe -Wall -g -O2 -static-libgcc --target=x86_64-w64-mingw -std=c11 &amp;&amp; $dir$fileNameWithoutExt", "cpp": "cd $dir &amp;&amp; clang++ $fileName -o $fileNameWithoutExt.exe -Wall -g -O2 -static-libgcc --target=x86_64-w64-mingw -std=c++11 &amp;&amp; $dir$fileNameWithoutExt" &#125;, "code-runner.saveFileBeforeRun": true, "code-runner.preserveFocus": true, "code-runner.clearPreviousOutput": false, "code-runner.ignoreSelection": true, "C_Cpp.clang_format_sortIncludes": true&#125; 其他因为搞完前三个(其实是前两个)之后已经可以正常编译，compile_flags.txt等文件并未配置。 使用反馈可能由于是刚开始使用，感觉并没有很方便。 也许用着用着就习惯了？ 参考资料及鸣谢知乎 谭九鼎 洛谷日报 现代编辑器食用指北-VSCode]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sqrt-Tree 学习笔记]]></title>
    <url>%2Fblog%2FSqrt-Tree-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[神仙p_b_p_b发现了一种神奇的分块思路，然后发现给别人造了轮子。 给你一个长度为 $n$ 的序列 $\left\langle a _i\right\rangle^{n} _{i=1}$和一个满足结合律的运算 $\circ$ 。Sqrt Tree可以在 $O(n \log_2\log_2n)$ 的时间内预处理，并在 $O(1)$ 的时间回答计算 $a _l\circ a _{l+1}\circ\cdots\circ a _r$ 的询问。 做法描述无论如何先分块首先给原序列分块，块大小 $\sqrt{n}$ 。对于每个块，计算： $P_i$ 块内的前缀询问答案 $S_i$ 块内的后缀询问答案 再维护一个额外的数组 $\left\langle B_{i,j}\right\rangle$ 表示第 $i$ 个块到第 $j$ 个块的答案。 预处理上述的值可以在 $O(n)$ 时间与空间内完成。然后我们就可以在 $O(1)$ 时间内回答跨块的询问。然而对于整个区间都在块内部的询问需要 $O(\sqrt{n})$ 的时间才能回答。 构建一棵树可以在每个块内递归地构造上述结构来支持块内的查询。此时我们相当于建出一棵树，每个节点代表序列的一个区间。由于大小为 $k$ 的结点有 $O(\sqrt{k})$ 个子节点，于是整棵树的高度是 $O(\log_2\log_2n)$ 的。而每一层的区间总长为 $n$ ，因此建树的复杂度是 $O(n\log_2\log_2n)$ 的。 于是我们可以在 $O(\log _2\log _2n)$ 时间内回答询问。只需要找到一个区间长度最小的结点使得其能包含询问区间 $[ l,r ]$ ，这样 $[ l,r ]$ 在 $u$ 的分块区间中一定是跨块的，就可以 $O(1)$ 计算答案了。所以查询一次复杂度相当于树 $O(\log _2\log _2n)$ 。然而还能继续优化此过程。 优化询问可以二分高度，再 $O(1)$ 判断合不合法。这样复杂度就被优化到 $O(\log _2\log _2\log _2n)$ 。然而我们希望能够优化到 $O(1)$ 。 我们假设 每一个块的大小都是 $2$ 的整数幂次； 相同层的块大小相同。 此时可以将原序列补成 $2$ 的幂次，预处理复杂度不变。 现在可以快速确定一个区间是否在同一个块中了。令序列的下标从 $0$ 开始，可以发现，一个大小为 $2^k$ 的块内，元素的下标（二进制表示）仅有后 $k$ 位不同。所以，对于询问区间 $[l,r]$ ，计算 $l\ \operatorname{xor}\ r$ 的最高位的 $1$ 就可以快速确定答案区间所在的层。 如此就可以在 $O(1)$ 时间内回答询问。 单点修改Sqrt Tree 支持单点修改。 朴素实现考虑长度为 $len$ 的结点中储存的信息（分块后的前缀询问数组 $P_i$ ，后缀询问数组 $S_i$ ，块间询问数组 $B_{i,j}$），可得 $P_i$ 及 $S_i$ 中都只有 $O(\sqrt{l})$ 个元素改变，而 $B_{i,j}$ 中有 $O(l)$ 个元素改变。因此，朴素地在Sqrt Tree上修改的时间复杂度是 $O(n+\sqrt{n}+\sqrt{\sqrt{n}}+\cdots)=O(n)$ 。 使用 Sqrt Tree 替代 B 数组发现复杂度瓶颈在于更新根节点的 $\left\langle B_{i,j}\right\rangle$ 。注意到 $\left\langle B_{i,j}\right\rangle$ 的作用：表示块 $i$ 到块 $j$ 的答案。把根节点分的每个块当做一个序列，在块上再开一棵 Sqrt Tree，称作 $\text{index}$ ，长度为 $O(\sqrt{n})$ 。此时，它就可以用来充当原树根节点上的 $\left\langle B_{i,j}\right\rangle$ 的作用了，而其他非根节点仍使用 $\left\langle B_{i,j}\right\rangle$ 来维护。 所以我们可以先 $O(\sqrt{n})$ 地更新原树上的结点（根节点只更新 $P_i$ 与 $S_i$），再对 $\text{index}$ 进行更新。由于 $\text{index}$ 也是单点更新（原序列单点修改只影响一个块的答案），需要 $O(\sqrt{n})$ 的时间。所以单点修改需要 $O(\sqrt{n})$ 。 同时仍能保证询问能在 $O(1)$ 时间内回答（即使调用 $\text{index}$ 也只会调用一次）。 参考代码鸽了。 参考资料OI Wiki]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强制在线不带修区间众数相关 学习笔记]]></title>
    <url>%2Fblog%2F%E5%BC%BA%E5%88%B6%E5%9C%A8%E7%BA%BF%E4%B8%8D%E5%B8%A6%E4%BF%AE%E5%8C%BA%E9%97%B4%E4%BC%97%E6%95%B0%E7%9B%B8%E5%85%B3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[区间众数是和分块脱不了干系的。 [BZOJ 2724][Violet 6]蒲公英 草怎么是权限题 [Luogu 4168][Violet]蒲公英 题意简述给出一个长为$n$的数列，$m$次询问一段区间内最小的区间众数，强制在线。 $1\leq l\leq r\leq40000,m\leq50000,1\leq a_i\leq 10^9$。 主要思路1引理1设$\operatorname{mode}(A)$为可重集合$A$的最小众数，则有$\operatorname{mode}(A\cup B)\in\operatorname{mode}(A)\cup B$。 引理1的证明几乎是显然的。令$t=\operatorname{mode}(A\cup B)$，若$t$既不是$\operatorname{mode}(A)$，也不属于$B$，则$t$的出现次数就是在$A$中出现的次数。而这个次数应是不大于$\operatorname{mode}(A)$出现的次数的，出现矛盾。故引理1成立。 算法离散化，分块，块大小$S$。 对于询问$[l,r]$，根据引理1，答案只可能是 $l,r$间所有完整块的最小众数 或 不完整块中出现的数。 对于一段完整块的最小众数$f[a][b]$，可以预处理，选定最左的块$a$后$O(n)$求出$f[a][i]$，其中$a\leq i$，总预处理复杂度$O(n\lfloor\frac{n}{S}\rfloor)$。 对于不完整的块，我们可以求出每种数在$[l,r]$中出现的次数。 怎么求出某种数在$[l,r]$中出现的次数？我们可以把每种数出现的位置按顺序丢到一个$\text{vector}$里，查找时找到第一个在$l$或其后出现的位置和最后一个在$r$或其前出现的位置即可，每次查询复杂度$O(\log_2cnt[a_i])=O(\log_2n)$。 所以每次询问区间$[l,r]$时间复杂度$O(Slog_2n)$。 平衡一下，块大小取$\sqrt{\frac{n}{\log_2n}}$，总复杂度$O(n\sqrt{n\log_2n})$（$n,m$同阶）。 若本人推错了请指出 优化有没有办法把这个$\sqrt{\log_2n}$去掉呢？ 观察发现这个常数来自求某种数在$[l,r]$中出现的次数。 设$Sum(i,x)$表示$[1,i]$间$x$的个数，我们需要回答的就是$Sum(r,x)-Sum(l-1,x)$。 处理$C[b][x]$表示第$1$到第$b$块中$x$出现的次数，需要$O(n\lfloor\frac{n}{S}\rfloor)$的空间与时间。 处理$A[b][i][x]$表示从第$b$块开头开始的$i$个数中$x$的出现次数。因为每个块最多只有$S$种数，故复杂度$O(S^2\lfloor\frac{n}{S}\rfloor)=O(nS)$。 然后就可以$O(1)$地回答$Sum(i,x)$，可以将块大小设为$\sqrt{n}$，时空复杂度均为$O(n\sqrt{n})$（$n,m$同阶）。 参考代码然后你就会发现这玩意难写得很，所以我放弃了…… 主要思路2我们希望找到一个空间可以较小，且码量也较小的方法。 仍然离散化分块，块大小$S$，仍求出$f[a][b]$为一段完整块的最小众数，并附带求出该数的出现次数$num[a][b]$。 仍把每种数$x$的出现位置开一个$\text{vector}$（名$pos[x]$）按顺序存起来，同时对于数列中每个位置标记该位置在$\text{vector}$中的下标$id[i]$。 什么？没看懂？那就多看几遍 算法设询问区间为$[l,r]$，包含完整块$[a,b]$。 首先$mode=f[a][b]$，出现次数$cnt=num[a][b]$。 然后处理两边的不完整块。 例如，对于$l$到块$a-1$的结尾处这部分： 假设处理到位置$i$，$a_i=x$。 那么，若$pos[x][id[i]+cnt]$仍存在且不在$r$的右边，显然可以更新$mode=x,cnt++$。 对于块$b+1$开头到$r$的这一部分，同理，只不过改成看$pos[x][id[i]-cnt]$是否不在$l$的左边。 可以发现，$cnt$最多更新$2S$次，若超过$2S$次则说明有数$x$在这段完整块$[a,b]$中出现次数大于$num[a][b]$，固然矛盾。所以每次询问时间复杂度$O(S)$。 预处理时间复杂度$O(n\lfloor\frac{n}{S}\rfloor)$，询问总时间复杂度$O(nS)$，故$S$取$\sqrt{n}$时复杂度降至最优$O(n\sqrt{n})$。 而空间复杂度，我们发现无论是$f,num$，还是$id,pos$，总共都只有$O(n)$的大小。 什么？没看懂？那就看看代码吧 参考代码由于STL依赖症心血来潮，直接写了个$\text{pair}$…… 码量确实不大…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define pb push_back #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 100010 , SN = 320; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;#define rsiz(h) ((int)((h)-&gt;size()))int n,blo,ary[N],a[N],bl[N],id[N],cnt[N],m;vector&lt;int&gt; pos[N];PII f[SN][SN];inline void checkR(int l,int r,int R,PII &amp;res)&#123; Rint ans = res.sec; FOR(i,l,r)&#123; while(id[i] + ans &lt; rsiz(pos + a[i]) &amp;&amp; pos[a[i]][id[i] + ans] &lt;= R) ++ans; if(ans &gt; res.sec) res = MP(a[i],ans); else if(a[i] &lt; res.fir &amp;&amp; id[i] + ans &lt;= rsiz(pos + a[i]) &amp;&amp; pos[a[i]][id[i] + ans - 1] &lt;= R) res.fir = a[i]; &#125; return;&#125;inline PII query(int l,int r)&#123; Rint lb = bl[l] , rb = bl[r] , ans; reg PII res = (rb - lb &lt; 2) ? MP(a[l],1) : f[lb + 1][rb - 1]; if(lb == rb)&#123; checkR(l,r,r,res); return res; &#125; checkR(l,blo * lb,r,res); ans = res.sec; FOR(i,blo*(rb-1)+1,r)&#123; while(id[i] - ans &gt;= 0 &amp;&amp; pos[a[i]][id[i] - ans] &gt;= l) ++ans; if(ans &gt; res.sec) res = MP(a[i],ans); else if(a[i] &lt; res.fir &amp;&amp; id[i] - ans &gt;= -1 &amp;&amp; pos[a[i]][id[i] - ans + 1] &gt;= l) res.fir = a[i]; &#125; return res;&#125;int main()&#123; n = read() , blo = ceil(sqrt(n)) , m = read(); Rint c = 1; FOR(i,1,n)&#123; ary[i] = a[i] = read(); bl[i] = c; if(!(i % blo)) ++c; &#125; sort(ary + 1,ary + n + 1); Rint siz = unique(ary + 1,ary + n + 1) - ary - 1 , l , r , lastans = 0; FOR(i,1,n)&#123; a[i] = lower_bound(ary + 1,ary + siz + 1,a[i]) - ary; pos[a[i]].pb(i); id[i] = rsiz(pos + a[i]) - 1; &#125; FOR(i,1,bl[n])&#123; MEM(cnt,0); reg PII res = MP(0,0); FOR(j,blo * (i - 1) + 1,n)&#123; ++cnt[a[j]]; if(cnt[a[j]] &gt; res.sec) res = MP(a[j],cnt[a[j]]); else if(cnt[a[j]] == res.sec &amp;&amp; a[j] &lt; res.fir) res.fir = a[j]; f[i][bl[j]] = res; &#125; &#125; FOR(i,1,m)&#123; l = (read() + lastans - 1) % n + 1 , r = (read() + lastans - 1) % n + 1; if(l &gt; r) swap(l,r); printf("%d\n",lastans = ary[query(l,r).fir]); &#125; return 0;&#125; 扩展[Ynoi2019模拟赛]Yuno loves sqrt technology III 这题是求区间众数的在区间中的出现次数。做法同上主要思路2（实际上$\text{lxl}$可能是国内第一个写这个思路的人？）。 注意卡常。 留下了卡不进总时间6.5s的泪水…… 参考代码最快的一次…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define pb push_back #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 500005 , SN = 1505; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;#define rsiz(h) ((int)((h)-&gt;size()))int n,blo,ary[N],a[N],bl[N],id[N],cnt[N],m;vector&lt;int&gt; pos[N];int f[SN][SN];inline int query(int l,int r)&#123; Rint lb = bl[l] , rb = bl[r] , ans = f[lb + 1][rb - 1]; if(!ans) ans = 1; if(lb == rb)&#123; FOR(i,l,r)&#123; while(id[i] + ans &lt; rsiz(pos + a[i]) &amp;&amp; pos[a[i]][id[i] + ans] &lt;= r) ++ans; &#125; return ans; &#125; FOR(i,l,blo * lb)&#123; while(id[i] + ans &lt; rsiz(pos + a[i]) &amp;&amp; pos[a[i]][id[i] + ans] &lt;= r) ++ans; &#125; FOR(i,blo*(rb-1)+1,r)&#123; while(id[i] - ans &gt;= 0 &amp;&amp; pos[a[i]][id[i] - ans] &gt;= l) ++ans; &#125; return ans;&#125;int main()&#123; n = read() , m = read() ; blo = ceil(sqrt(n)); Rint c = 1; FOR(i,1,n)&#123; ary[i] = a[i] = read(); bl[i] = c; if(!(i % blo)) ++c; &#125; sort(ary + 1,ary + n + 1); Rint siz = unique(ary + 1,ary + n + 1) - ary - 1 , l , r , lastans = 0; FOR(i,1,n)&#123; a[i] = lower_bound(ary + 1,ary + siz + 1,a[i]) - ary; pos[a[i]].pb(i); id[i] = rsiz(pos + a[i]) - 1; &#125; FOR(i,1,bl[n])&#123; MEM(cnt,0); FOR(j,i,bl[n])&#123; f[i][j] = f[i][j - 1]; FOR(k,(j - 1) * blo + 1,min(j * blo,n))&#123; f[i][j] = max(f[i][j] , ++cnt[a[k]]); &#125; &#125; &#125; FOR(i,1,m)&#123; l = read() ^ lastans , r = read() ^ lastans; if(l &gt; r) swap(l,r); printf("%d\n",lastans = query(l,r)); &#125; return 0;&#125; 参考区间众数解题报告 - 陈立杰 OldDriverTree(lxl)的博客 Tiger0132 Ynoi2019T3题解]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数列分块入门」系列]]></title>
    <url>%2Fblog%2F%E3%80%8C%E6%95%B0%E5%88%97%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8%E3%80%8D%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[谈到分块，不得不说说 $\text{hzwer}$ 学长的「数列分块入门」系列。 若未特别指出$\text{ML}$或$\text{TL}$，则$\text{ML:256MB,TL:500ms}$。 数列分块入门 1[LOJ 6277] 题意给出一个长为$n$的数列，有$n$个操作，操作涉及区间加法，单点查值。 $1\leq l\leq r\leq n\leq 50000$，输入的所有数均为$\text{int}$范围的整数。 $\text{TL:100ms}$ 思路啥？这题还要思路？ 代码码风丑见谅： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 50010 , SN = 230; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;int n,blo;int a[N],bl[N],tag[SN];inline void update(int l,int r,int x)&#123; Rint tem = min(bl[l] * blo , r); FOR(i,l,tem) a[i] += x; if(bl[l] != bl[r]) FOR(i,(bl[r] - 1) * blo + 1,r) a[i] += x; FOR(i,bl[l] + 1,bl[r] - 1) tag[i] += x; return;&#125;int main()&#123; n = read(),blo = sqrt(n); FOR(i,1,n) a[i] = read(); FOR(i,1,n) bl[i] = (i - 1)/blo + 1; Rint opt,l,r,c; FOR(i,1,n)&#123; opt = read() , l = read() , r = read() , c = read(); opt ? (void)(printf("%d\n",a[r] + tag[bl[r]])) : update(l,r,c); &#125; return 0;&#125; 数列分块入门 2[LOJ 6278] 题意给出一个长度为$n$的数列，以及$n$个操作，操作涉及区间加法，询问区间内小于某个值$x$的元素个数。 $1\leq l\leq r\leq n\leq 50000$，输入的所有数均为$\text{int}$范围的整数。 思路将数列分成长为$S$的块。 修改就对整块打$\text{tag}$，对不完整的块暴力修改、排序，复杂度$O(\lfloor\frac{n}{S}\rfloor+S\log_2S)$。 询问就对整块$\text{lower_bound}$，对不完整的块暴力，复杂度$O(\lfloor\frac{n}{S}\rfloor\log_2S+S)$。 然后平衡一下，$S$ 取$\sqrt{n}$就好了。 代码こ↑こ↓ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 50010 , SN = 250; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;int n,blo,bl[N],bid[SN];LL a[N],b[N],tag[SN];inline int query(int l,int r,LL val)&#123; Rint lb = bl[l] , rb = bl[r] , res = 0; if(lb == rb)&#123; FOR(i,l,r) res += a[i] &lt; (val - tag[lb]); return res; &#125; FOR(i,lb + 1,rb - 1) res += lower_bound(b + bid[i - 1] + 1,b + bid[i] + 1,val - tag[i]) - b - bid[i - 1] - 1; FOR(i,l,bid[lb]) res += a[i] &lt; (val - tag[lb]); ROF(i,r,bid[rb - 1] + 1) res += a[i] &lt; (val - tag[rb]); return res;&#125;inline void update(int l,int r,LL val)&#123; Rint lb = bl[l] , rb = bl[r]; if(lb == rb)&#123; FOR(i,bid[lb - 1] + 1,bid[lb])&#123; if(l &lt;= i &amp;&amp; i &lt;= r) a[i] += val; b[i] = a[i]; &#125; return sort(b + bid[lb - 1] + 1,b + bid[lb] + 1); &#125; FOR(i,lb + 1,rb - 1) tag[i] += val; FOR(i,bid[lb - 1] + 1,bid[lb])&#123; if(l &lt;= i) a[i] += val; b[i] = a[i]; &#125; FOR(i,bid[rb - 1] + 1,bid[rb])&#123; if(i &lt;= r) a[i] += val; b[i] = a[i]; &#125; return sort(b + bid[lb - 1] + 1,b + bid[lb] + 1),sort(b + bid[rb - 1] + 1,b + bid[rb] + 1);&#125;int main()&#123; n = read() , blo = sqrt(n); FOR(i,1,n) b[i] = a[i] = read(); Rint opt,l,r,c = 1; FOR(i,1,n - 1)&#123; bl[i] = c; if(!(i % blo)) bid[c++] = i; &#125; bl[n] = c , bid[c] = n; FOR(i,1,c) sort(b + bid[i - 1] + 1,b + bid[i] + 1); FOR(i,1,n)&#123; opt = read() , l = read() , r = read() , c = read(); if(opt) printf("%d\n",query(l,r,1ll * c * c)); else update(l,r,1ll * c); &#125; return 0;&#125; 数列分块入门 3[LOJ 6279] 题意给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，询问区间内$x$的前驱。 $1\leq l\leq r\leq n\leq 100000$，输入的所有数均为$\text{int}$范围的整数。 $\text{TL:1500ms}$ 思路基本同上「数列分块入门 2」，但是不能直接排序（复杂度$O(n\sqrt{n}\log_2n)$）而是需要用一些数据结构存储每个块的信息。 本人代码使用$set$存储每个块的信息。 微妙地调整块大小应该可以过吧……本人代码采用的是$S=n^{0.612}$ 代码こ↑こ↓ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 100010 , SN = 330; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;int n,blo,a[N],bl[N],bid[SN],tag[SN];set&lt;int&gt; s[SN];inline void update(int l,int r,int v)&#123; Rint lb = bl[l] , rb = bl[r]; if(lb == rb)&#123; FOR(i,l,r)&#123; s[lb].erase(a[i]); a[i] += v; s[lb].insert(a[i]); &#125; return; &#125; FOR(i,lb + 1,rb - 1) tag[i] += v; FOR(i,l,bid[lb]) s[lb].erase(a[i]),a[i] += v,s[lb].insert(a[i]); ROF(i,r,bid[rb-1]+1) s[rb].erase(a[i]),a[i] += v,s[rb].insert(a[i]); return;&#125;inline int query(int l,int r,int v)&#123; Rint lb = bl[l] , rb = bl[r] , ans = INT_MIN; if(lb == rb)&#123; FOR(i,l,r) if(a[i] + tag[lb] &lt; v &amp;&amp; ans &lt; a[i] + tag[lb]) ans = a[i] + tag[lb]; return ans &gt; INT_MIN ? ans : -1 ; &#125; FOR(i,lb + 1,rb - 1)&#123; reg auto it = s[i].lower_bound(v - tag[i]);//set&lt;int&gt;::iterator if(it == s[i].begin()) continue; --it; if(ans &lt; *it + tag[i]) ans = *it + tag[i]; &#125; FOR(i,l,bid[lb]) if(a[i] + tag[lb] &lt; v &amp;&amp; ans &lt; a[i] + tag[lb]) ans = a[i] + tag[lb]; ROF(i,r,bid[rb-1]+1) if(a[i] + tag[rb] &lt; v &amp;&amp; ans &lt; a[i] + tag[rb]) ans = a[i] + tag[rb]; return ans &gt; INT_MIN ? ans : -1;&#125;int main()&#123; n = read() , blo = ceil(pow(n,0.612)); FOR(i,1,n) a[i] = read(); Rint opt,l,r,c = 1; FOR(i,1,n - 1)&#123; bl[i] = c; if(!(i % blo)) bid[c++] = i; &#125; bl[n] = c , bid[c] = n; FOR(i,1,n) s[bl[i]].insert(a[i]); FOR(i,1,n)&#123; opt = read() , l = read() , r = read() , c = read(); if(opt) printf("%d\n",query(l,r,c)); else update(l,r,c); &#125; return 0;&#125; 数列分块入门 4[LOJ 6280] 题意给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，区间求和并对$c$取模(每个询问给出)。 $1\leq l\leq r\leq n\leq 50000,c&gt;0$,输入的所有数均为$\text{int}$范围的整数。 思路经典问题，经典中的经典。 代码こ↑こ↓ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 50010 , SN = 250; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;int n,blo,bl[N],bid[SN];LL a[N],tag[SN],sum[SN];int query(int l,int r,LL p)&#123; Rint lb = bl[l] , rb = bl[r]; reg LL ans = 0; if(lb == rb)&#123; FOR(i,l,r) ans += a[i] + tag[lb]; return (int)(((ans %= (p + 1)) &lt; 0) ? ans + p + 1 : ans); &#125; FOR(i,lb + 1,rb - 1) ans += sum[i]; FOR(i,l,bid[lb]) ans += a[i] + tag[lb]; ROF(i,r,bid[rb-1]+1) ans += a[i] + tag[rb]; return (int)(((ans %= (p + 1)) &lt; 0) ? ans + p + 1 : ans);&#125;inline void update(int l,int r,LL val)&#123; Rint lb = bl[l] , rb = bl[r]; if(lb == rb)&#123; FOR(i,l,r) a[i] += val , sum[lb] += val; return; &#125; FOR(i,lb + 1,rb - 1) tag[i] += val , sum[i] += val * blo; FOR(i,l,bid[lb]) a[i] += val , sum[lb] += val; ROF(i,r,bid[rb-1]+1) a[i] += val , sum[rb] += val; return;&#125;int main()&#123;// FILE("a13"); n = read() , blo = sqrt(n); FOR(i,1,n) a[i] = read(); Rint opt,l,r,c = 1; FOR(i,1,n - 1)&#123; bl[i] = c; if(!(i % blo)) bid[c++] = i; &#125; bl[n] = c,bid[c] = n; FOR(i,1,n) i[bl][sum] += a[i]; FOR(i,1,n)&#123; opt = read() , l = read() , r = read() , c = read(); opt ? (void)(printf("%d\n",query(l,r,(LL)c))) : update(l,r,(LL)c); &#125; return 0;&#125; 数列分块入门 5[LOJ 6281] 题意给出一个长为$n$的数列，以及$n$个操作，操作涉及区间开方，区间求和。 $1\leq l\leq r\leq n\leq 50000$,输入的所有数均为$\text{int}$范围的自然数。 思路什么这不是线段树题吗 代码只写了线段树的代码，就不放了…… 数列分块入门 6[LOJ 6282] 题意给出一个长度为$n$的数列，以及$n$个操作，操作涉及单点插入，单点查询。 $1\leq l\leq r\leq n\leq 100000$,输入的所有数均为$\text{int}$范围的整数。 输入输出： 第一行，一个数字$n$。 第二行$n$个数字，第$i$个数字为$a_i$。 接下来$n$行操作，每组操作输入四个数字$opt,l,r,c$。 若$opt=0$，表示在第$l$个数字前插入数字$r$。 若$opt=1$，表示询问$a_r$的值。 对每组$opt=1$的询问，输出一行一个整数，为$a_r$的值。 什么？你问我c干啥用的？我也想知道 思路先把原序列分块，块大小$S$，块数$Bl$。 使用$\text{vector}$存储每一块信息。插入时暴力插入，将该块后面的元素都后移一位，复杂度$O(S)$；查询也是暴力，复杂度$O(Bl)$。 但是可能在一个块里有大量插入，此时该块大小将远远超过$S$，复杂度退化。 可以当某个块过大时，将该块分为两个，暴力重构，时间复杂度$O(n)$（若使用链表，可以锐减至$O(S+Bl)$。） 也可以考虑每$m$次插入后对序列进行重构，复杂度也为$O(n)$。 喂这种要”保持平衡”的思想不是和平衡树差不多吗你怎么不写棵平衡树 代码本人采用的是$S=\sqrt{n}$，在块大小不小于$2S$时将该块分为两个，暴力拆块，复杂度$O(n)$。 由于最多只会拆$\sqrt{n}$次块，拆块复杂度$O(n\sqrt{n})$，可以通过此题。 指针恐惧症慎入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define pb push_back #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 200010 , SN = 650; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;int n,blo,bn;vector&lt;int&gt;a[SN];#define rsiz(h) ((int)((h)-&gt;size()))inline void update(int t,int val)&#123;//在序号t的数后面插入数val reg vector&lt;int&gt; *k = a; while(rsiz(k + 1) &lt;= t &amp;&amp; (k - a) &lt; bn) ++k,t -= rsiz(k); ++k; if((k - a) &gt; bn) return; if(t &lt; 0) return; k -&gt; insert((k -&gt; begin()) + t,val); if(rsiz(k) &gt;= 2 * blo)&#123; ROF(i,bn,k - a + 1) a[i + 1] = a[i]; (k + 1) -&gt; clear(); FOR(i,blo,rsiz(k) - 1) (k + 1) -&gt; pb((*k)[i]); while(rsiz(k) &gt; blo) k -&gt; erase((k -&gt; end()) - 1); ++bn; &#125; return;&#125;inline int query(int t)&#123;//查找序号为t的数 --t; reg vector&lt;int&gt; *k = a; while(rsiz(k + 1) &lt;= t &amp;&amp; (k - a) &lt; bn) ++k,t -= rsiz(k); ++k; if((k - a) &gt; bn) return 0; if(t &lt; 0) return 0; return (*k)[t];&#125;int main()&#123; n = read() , blo = sqrt(n); Rint opt,l,r = 0,c = 1; bn = ceil(sqrt(n)); FOR(i,1,n)&#123; a[c].pb(read()); ++r; if(r == blo) ++c,r = 0; &#125; FOR(i,1,n)&#123; opt = read() , l = read() , r = read() , read(); opt ? (void)(printf("%d\n",query(r))) : update(l - 1,r);// printf("Siz : "); FOR(i,1,bn) printf("%d ",rsiz(a + i)); puts("");// FOR(i,1,bn)&#123; printf("a[%d] : ",i); FOR(j,0,rsiz(a + i) - 1) printf("%d ",a[i][j]); puts(""); &#125; &#125; return 0;&#125; 数列分块入门 7[LOJ 6283] 题意给出一个长为$n$的数列，以及$n$操作，操作涉及区间加法，区间乘法，单点询问。 $1\leq l\leq r\leq n\leq 100000$,输入的所有数均为$\text{int}$范围的整数，询问对$10007$取模。 所以为什么不是查询区间和 思路右转线段树模板，请 反正分块的思路基本相同，只是tag不用下传 代码只写了线段树，所以不贴了。 数列分块入门 8[LOJ 6284] 题意给出一个长为$n$的数列，以及$n$个操作，操作涉及区间询问等于一个数 的元素，并将这个区间的所有元素改为$c$。 $1\leq l\leq r\leq n\leq 100000$,输入的所有数均为$\text{int}$范围的整数。 输入输出： 第一行，一个数字$n$。 第二行，$n$个数字，第$i$个为$a_i$。 接下来输入$n$行询问，每行三个数字$l,r,c$。 表示先查询位于$[l,r]$的数字有多少个是$c$，再将$[l,r]$内的数字都改为$c$。 数据不随机。 思路分块，块大小$\sqrt{n}$，每块记录一下是否全部相等，若是则$O(1)$处理，不是则暴力扫一遍。不完整的块也暴力处理。 这样复杂度看上去最坏是$O(n)$的。然而，当经过了一次$O(n)$的询问后，几乎所有块都变得相等了。而一次操作最多将$2$个块变得不等，所以至少需要$\sqrt{n}$次操作后才可能再次出现$O(n)$的最坏复杂度。综合一下，可得复杂度是$O(n\sqrt{n})$，可以通过此题。 本人的说法可能不够严谨，希望有人可以提供更好的解释方法！ 代码こ↑こ↓ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 100010 , SN = 450; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;int n,blo,a[N],sam[SN],bl[N],bid[SN];inline void update(int b)&#123;//更新某个块状态 if(!sam[b]) return; FOR(i,bid[b - 1] + 1,bid[b] - 1) a[i] = b[bid][a]; return (void)(sam[b] = 0);&#125;inline int slove(int l,int r,int val)&#123; Rint lb = bl[l] , rb = bl[r] , res = 0; if(lb == rb)&#123; update(lb); FOR(i,l,r) (a[i] == val) ? (++res) : (a[i] = val) ; sam[lb] = (l == bid[lb - 1] + 1 &amp;&amp; r == bid[lb]); return res; &#125; update(lb); ROF(i,bid[lb],l) (a[i] == val) ? (++res) : (a[i] = val) ; sam[lb] = (l == bid[lb - 1] + 1); update(rb); FOR(i,bid[rb-1]+1,r) (a[i] == val) ? (++res) : (a[i] = val) ; sam[rb] = (r == bid[rb]); FOR(i,lb + 1,rb - 1)&#123; if(sam[i])&#123; (i[bid][a] == val) ? (res += blo) : (i[bid][a] = val); continue; &#125; FOR(j,bid[i - 1] + 1,bid[i]) (a[j] == val) ? ++res : a[j] = val ; sam[i] = 1; &#125; return res;&#125;int main()&#123; n = read() , blo = sqrt(n); Rint l,r,c = 1; FOR(i,1,n - 1)&#123; a[i] = read() , bl[i] = c; if(!(i % blo)) sam[c] = 1,bid[c++] = i; &#125; a[n] = read() , bl[n] = c , bid[c] = n; FOR(i,1,c) FOR(j,bid[i-1] + 1,bid[i] - 1) if(a[j] != i[bid][a])&#123; sam[i] = 0; break; &#125; FOR(i,1,n)&#123; l = read() , r = read() , c = read(); printf("%d\n",slove(l,r,c)); &#125; return 0;&#125; 加强啊说起来本题还可以加强的来着。 给出一个长为$n$的数列，以及$n$个操作，操作涉及区间询问等于一个数 的元素，或将这个区间的所有元素改为$c$。 具体地： 第一行，一个整数$n$。 第二行，$n$个整数，第$i$个为$a_i$。 接下来输入$n$行询问，每行四个整数$opt,l,r,c$。 若$opt=0$，表示将$[l,r]$内的所有数改为$c$。 若$opt=1$，输出一行一个整数，表示$[l,r]$内有多少个数是$c$。 数据不随机。 $1\leq l\leq r\leq n\leq 100000$，所有输入的数均在$\text{int}$范围内，不强制在线。 $1\leq l\leq r\leq n\leq 50000$，所有输入的数均在$\text{int}$范围内，强制在线。 $\text{TL:1000ms}$ 思路好像和原题没什么关系了…… 不强制在线的话，可以先离散化，然后分成$\sqrt{n}$大小的块。 每个块用$O(n)$的空间存储每种数的数量，如果全部相同则打$\text{tag}$。 首先，单点修改是$O(1)$的（某种数的数量$+1$，某种数的数量$-1$），整块修改也是$O(1)$的（打$\text{tag}$）。 不完整的块的修改则是$O(\sqrt{n})$的（可能需要拆$\text{tag}$，拆掉后相当于整个块进行修改，也是$O(\sqrt{n})$的）。 查询时，显然对于整块是$O(1)$的，对于不完整的块暴力是$O(\sqrt{n})$的。 所以时间复杂度和空间复杂度都是$O(n\sqrt{n})$，可以通过此题。 强制在线的话，可以用$\text{map}$来使空间复杂度保持$O(n\sqrt{n})$，而时间复杂度将变为$O(n\sqrt{n}\log_2n)$，大概应该或许能通过此题。 因加强版未找到题目，对于强制在线的时间复杂度，若能在保证空间的情况下做到更优，欢迎在评论区指出或私信本人！ 代码こ↑こ↓ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;namespace my_std&#123; using namespace std; #define reg register #define Rint register int #define FOR(i,a,b) for(register int i=(a);i&lt;=(b);++i) #define ROF(i,a,b) for(register int i=(a);i&gt;=(b);--i) #define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)+1;++i) #define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a);i!=(arr)+(b)-1;--i) #define GO(x,p,e,i,v) for(register int i=p[x].head,v;i;i=e[i].link) #define MEM(x,v) memset(x,v,sizeof(x)) #define fir first #define sec second #define pq priority_queue #define PII pair&lt;int,int&gt; #define MP make_pair typedef long long LL; typedef double DB; inline int read()&#123; int ans=0,f=1;char c=getchar(); while(!isdigit(c))&#123; f^=(c=='-'); c=getchar(); &#125; for(;isdigit(c);c=getchar()) ans=(ans&lt;&lt;1)+(ans&lt;&lt;3)+(c^48); return f?ans:-ans; &#125; const int mod = 998244353 , N = 100010 , SN = 280; inline void inc(int &amp;x,const int &amp;y)&#123; x+=y; if(x&gt;=mod) x-=mod; &#125; inline int ksm(int x,LL y)&#123; int res=1; for(;y;y&gt;&gt;=1,x=1ll*x*x%mod) if(y&amp;1) res=1ll*res*x%mod; return res;&#125; inline int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); return y?gcd(y,x%y):x; &#125; #define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)&#125;using namespace my_std;int n,blo,a[N],b[N &lt;&lt; 1],bl[N],bid[SN],siz,sam[SN];int num[SN][N &lt;&lt; 1],ql[N],qr[N],qc[N];inline void check(int b)&#123; if(!sam[b]) return; Rint v = b[bid][a]; FOR(i,bid[b - 1] + 1,bid[b] - 1) --num[b][a[i]] , a[i] = v , ++num[b][v]; return;&#125;inline int query(int l,int r,int val)&#123; Rint lb = bl[l] , rb = bl[r] , res = 0; check(lb); if(lb == rb)&#123; FOR(i,l,r) res += (a[i] == val); return res; &#125; check(rb); FOR(i,l,bid[lb]) res += (a[i] == val); ROF(i,r,bid[rb-1]+1) res += (a[i] == val); FOR(i,lb + 1,rb - 1) res += sam[i] ? ((i[bid][a] == val) ? blo : 0) : num[i][val] ; return res;&#125;inline void update(int l,int r,int val)&#123; Rint lb = bl[l] , rb = bl[r]; if(lb == rb)&#123; if(sam[lb])&#123; FOR(i,bid[lb - 1] + 1,bid[lb])&#123; --num[lb][a[i]]; a[i] = (l &lt;= i &amp;&amp; i &lt;= r) ? val : lb[bid][a] ; ++num[lb][a[i]]; &#125; return (void)(sam[lb] = (l == bid[lb - 1] + 1 &amp;&amp; r == bid[lb])); &#125; FOR(i,l,r) --num[lb][a[i]] , a[i] = val , ++num[lb][a[i]]; return (void)(sam[lb] = (l == bid[lb - 1] + 1 &amp;&amp; r == bid[lb])); &#125; if(sam[lb])&#123; FOR(i,bid[lb - 1] + 1,bid[lb]) --num[lb][a[i]] , a[i] = ((l &lt;= i) ? val : lb[bid][a]) , ++num[lb][a[i]]; &#125; else FOR(i,l,bid[lb]) --num[lb][a[i]] , a[i] = val , ++num[lb][val]; if(sam[rb])&#123; FOR(i,bid[rb - 1] + 1,bid[rb]) --num[rb][a[i]] , a[i] = ((i &lt;= r) ? val : rb[bid][a]) , ++num[rb][a[i]]; &#125; else FOR(i,bid[rb-1]+1,r) --num[rb][a[i]] , a[i] = val , ++num[rb][val]; sam[lb] = (l == bid[lb - 1] + 1) , sam[rb] = (r == bid[rb]); FOR(i,lb + 1,rb - 1)&#123; sam[i] = 1; --num[i][i[bid][a]] , i[bid][a] = val , ++num[i][val]; &#125; return;&#125;int main()&#123; n = read() , blo = ceil(pow(n,0.514)) , siz = n;// return printf("%d %d\n",blo,(int)(ceil(n / (DB)blo))),0; Rint t = 1; FOR(i,1,n - 1)&#123; b[i] = a[i] = read() , bl[i] = t; if(!(i % blo)) bid[t++] = i; &#125; b[n] = a[n] = read() , bl[n] = t , bid[t] = n; FOR(i,1,n) ql[i] = read() , qr[i] = read() , qc[i] = read() , b[++siz] = qc[i]; sort(b + 1,b + siz + 1); siz = unique(b + 1,b + siz + 1) - b - 1; FOR(i,1,n)&#123; a[i] = lower_bound(b + 1,b + siz + 1,a[i]) - b; qc[i] = lower_bound(b + 1,b + siz + 1,qc[i]) - b; t = bl[i]; num[t][a[i]]++; if(i == bid[t] &amp;&amp; num[t][a[i]] == bid[t] - bid[t - 1]) sam[t] = 1; &#125; FOR(i,1,n)&#123; printf("%d\n",query(ql[i],qr[i],qc[i])); update(ql[i],qr[i],qc[i]); #ifdef NTF_AK_IOI printf("Maybe the array : "); FOR(i,1,n) printf("%d ",a[i]); puts(""); FOR(i,1,bl[n])&#123; printf("block[%d] : ",i); if(sam[i])&#123; printf("same %d\n",i[bid][a]); continue; &#125; FOR(j,1,siz) printf("%d ",num[i][j]); puts(""); &#125; #endif &#125; return 0;&#125; 数列分块入门 9[LOJ 6285] 题意给出一个长为$n$的数列，以及$n$个询问，询问涉及求区间最小众数。 $1\leq l\leq r\leq n\leq 100000$,输入的所有数均为$\text{int}$范围的整数，不强制在线。 思路离线下来，做个莫队，块大小$\lfloor\frac{n}{\sqrt{n\log_2n}}\rfloor$。 具体实现我不会……啊啊我好菜 代码我不会啊 加强强制在线。见强制在线不带修区间众数。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫无止境的八月计划]]></title>
    <url>%2Fblog%2F%E6%BC%AB%E6%97%A0%E6%AD%A2%E5%A2%83%E7%9A%84%E5%85%AB%E6%9C%88%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[八月来了。秉着鸽子的本能，写一个计划安排。 其实写不写都没什么关系，反正最后还是会咕的。 绝对不能咕的东西刷分块、莫队等各种其他根号算法。 被迫写Ynoi。 CF上分。 大概会咕的东西改漫无止境的集训题目。 学字符串，刷网络流，学数论并被线性代数搞自闭。 洛谷AC数达到150。 做完文化课作业。 多写平衡树直到像mj一样熟练。 把这个计划写到250字。 事后统计果然所有计划都咕掉了……]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>计划与总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello_World]]></title>
    <url>%2Fblog%2FHello-World%2F</url>
    <content type="text"><![CDATA[瞎搞了一整天终于大概搞好了。 首先感谢ouuan的博客给我提供了大量美化教程。 安装sudo npm install hexo-cli -g装 hexo。 hexo init创建 blog。 改的各种东西到 source 分支去找就行。 然后用的是 v6.6.0 的 NexT 主题。 目前实现的功能常用命令好像并不多，放在这里只是为了防止忘记。下面所有命令都是在根目录使用Git Bash输入的。 hexo new: 后面接一个模板名和用&quot;&quot;括起来的新文件名，就可以新建一个文件。 hexo cl: hexo clean的简写，大概是个更新缓存？反正每次 deploy 前用一下就好了。 hexo g: hexo generate的简写， deploy 之前用一下。 hexo d: hexo deploy的简写，使用后即发布博客。 hexo s: hexo server的简写，输入后可以在localhost:4000本地预览博客。 网站内部有了网站的图标、背景、页脚、站内搜索、关于、标签和分类。 也有了友链。 一言（ヒトコト）懒得弄，先咕了。 博文支持 $\LaTeX$ 语法和markdown。不知道有没有未发现的锅。 $f_{f_i}$ ， $a * b * c$ ， $[x,y] (0&lt;x&lt;y&lt;1)$ 均正常。 支持折叠块： 这是一个折叠块。 也可以引用图片。 网络上的图片： 本地图片： 还有这种引用方式： 1&#123;% asset_img 图片地址(可以本地) 图片描述 %&#125; 然后鼠标放在上面就能看到描述。 书签咕了，复制提醒咕了。 README 与 404页面咕了。 搭建博客时遇到的问题关于$\LaTeX$关于双下划线匹配问题： f_{f_i} : $f_{f_i}$ 这个好像本来就没问题？ （如果锅了大不了每个下划线前后都空格就行了，参见下文） 关于双星号匹配问题： a * b * c : $a * b * c$ 加空格就没问题了。 关于方括号后接圆括号匹配问题： [x,y] (0&lt;x&lt;y&lt;1) : $[x,y] (0&lt;x&lt;y&lt;1)$ 还是加空格…… 关于双斜杠匹配问题： 这个要单独拎出来说一下。例如下面这条： \begin{bmatrix}{1,0,0\\0,1,0\\0,0,1}\end{bmatrix} 正常情况应该是这样的：$\begin{bmatrix}{1,0,0\\0,1,0\\0,0,1}\end{bmatrix}$ 但由于神奇的Hexo博客先渲染Markdown，\\就会被转译为\（在需要在正文使用这类字符的时候可以在前面加入一个\来表示） 所以将\\改为\\\\即可。（上面那个没锅的矩阵就是这么来的） 历史遗留问题deploy 后仓库内显示账号名错误曾经这个博客 deploy 之后在仓库内显示的 deploy 账户是 name ，而且没有邮箱，不能点进个人页面。 从这个博客诞生以来（2019.7.21）日就一直在困扰着本人的问题，已经提交了上百次后（2020.1.10）才解决。 尝试了诸多方法，比如重置 ssh ，重新登录 git ，把 deployer 删了重装……无果。 解决方式也很奇葩：把本地博客转移到另一个文件夹里，重新hexo init，然后提交。 然而这样就导致以前的所有提交记录没了，不过那大概不重要？ 参考资料及鸣谢ouuan的博客]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
</search>
